{
  "version": 3,
  "sources": ["../../node_modules/dill-pixel/src/plugins/audio/VoiceOverPlugin.ts"],
  "sourcesContent": ["import { Signal } from '../../signals';\nimport { Logger } from '../../utils';\nimport type { IPlugin } from '../Plugin';\nimport { Plugin } from '../Plugin';\nimport { IAudioInstance } from './AudioInstance';\n\nexport type PlayMode = 'append' | 'override' | 'new';\nexport type VoCallback = (didPlay: boolean) => void;\nexport type VoKey = string | number;\n\nexport type Caption = {\n  id: string;\n  args?: { [key: string]: string };\n};\n\nexport interface IPlayVoiceOverOptions {\n  mode?: PlayMode;\n  priority?: number;\n  callback?: VoCallback;\n  localized?: boolean;\n}\n\ninterface IQueueItem extends IPlayVoiceOverOptions {\n  key: string;\n  delay?: number;\n  timeout?: gsap.core.Tween;\n}\n\nexport interface IVoiceOverPlugin extends IPlugin {\n  fadeOutDuration: number;\n  debug: boolean;\n  onVoiceOverStart: Signal<(instance: IAudioInstance) => void>;\n  onVoiceOverPaused: Signal<(instance: IAudioInstance) => void>;\n  onVoiceOverResumed: Signal<(instance: IAudioInstance) => void>;\n  onVoiceOverComplete: Signal<(instance: IAudioInstance) => void>;\n  onVoiceOverStopped: Signal<(instance?: IAudioInstance) => void>;\n  paused: boolean;\n\n  playVO(key: VoKey | VoKey[], mode?: PlayMode, callback?: VoCallback): Promise<IAudioInstance>;\n\n  playVO(key: VoKey | VoKey[], callback?: VoCallback): Promise<IAudioInstance>;\n\n  playVO(key: VoKey | VoKey[], options?: IPlayVoiceOverOptions): Promise<IAudioInstance>;\n\n  stopVO(): Promise<void>;\n\n  pauseVO(): void;\n\n  resumeVO(): void;\n}\n\nexport class VoiceOverPlugin extends Plugin implements IVoiceOverPlugin {\n  public readonly id = 'voiceover';\n  public fadeOutDuration = 0.15;\n  public debug = false;\n  public onVoiceOverStart: Signal<(instance: IAudioInstance) => void> = new Signal<\n    (instance: IAudioInstance) => void\n  >();\n  public onVoiceOverPaused: Signal<(instance: IAudioInstance) => void> = new Signal<\n    (instance: IAudioInstance) => void\n  >();\n  public onVoiceOverComplete: Signal<(instance: IAudioInstance) => void> = new Signal<\n    (instance: IAudioInstance) => void\n  >();\n  public onVoiceOverResumed: Signal<(instance: IAudioInstance) => void> = new Signal<\n    (instance: IAudioInstance) => void\n  >();\n  public onVoiceOverStopped: Signal<(instance?: IAudioInstance) => void> = new Signal<\n    (instance: IAudioInstance) => void\n  >();\n  private readonly _queue: IQueueItem[] = [];\n  private readonly _pausedQueue: IQueueItem[] = [];\n  private _paused: boolean = false;\n\n  get paused() {\n    return this._paused;\n  }\n\n  get activeTimeout(): gsap.core.Tween | undefined {\n    return this._queue[0]?.timeout;\n  }\n\n  get activeVO(): IAudioInstance | undefined {\n    if (this._queue.length > 0 && this._queue[0].key) {\n      return this.app.audio.getAudioInstance(this._queue[0].key, 'voiceover') as IAudioInstance | undefined;\n    }\n    return undefined;\n  }\n\n  async initialize() {\n    this.app.actions('pause').connect(this.onPause);\n    this.app.actions('unpause').connect(this.onResume);\n    this.app.scenes.onSceneChangeStart.connect(this.stopVO);\n  }\n\n  playVO(key: VoKey | VoKey[], mode?: PlayMode, callback?: VoCallback): Promise<IAudioInstance>;\n\n  playVO(key: VoKey | VoKey[], callback?: VoCallback): Promise<IAudioInstance>;\n\n  playVO(key: VoKey | VoKey[], options?: IPlayVoiceOverOptions): Promise<IAudioInstance>;\n\n  async playVO(\n    key: VoKey | VoKey[],\n    modeOrCallbackOrOptions?: PlayMode | VoCallback | IPlayVoiceOverOptions,\n    callback?: VoCallback,\n  ): Promise<IAudioInstance | void> {\n    if (!Array.isArray(key)) {\n      key = [key];\n    }\n\n    let priority = 0;\n    let mode: string | undefined = 'override';\n    let locale: string = '';\n\n    if (typeof modeOrCallbackOrOptions === 'function') {\n      callback = modeOrCallbackOrOptions;\n    } else if (typeof modeOrCallbackOrOptions === 'object') {\n      const modeAsOptions = modeOrCallbackOrOptions as IPlayVoiceOverOptions;\n      priority = modeAsOptions.priority ?? 0;\n      callback = modeAsOptions.callback;\n      mode = modeAsOptions.mode ?? 'override';\n      if (modeAsOptions.localized) {\n        locale = this.app.i18n.locale;\n        key = key.map((k) => `${k}_${locale}`);\n      }\n    }\n\n    if (typeof modeOrCallbackOrOptions === 'string') {\n      mode = modeOrCallbackOrOptions;\n    }\n    this._paused = false;\n    if (key.length === 1 && this._queue.length === 1 && this._queue[0].key === key[0]) {\n      Logger.warn(`üîá Skipped VO ${key[0]} because it is already playing`);\n      if (callback) {\n        callback(false);\n      }\n    } else if (\n      this._queue.length === 0 ||\n      (mode === 'override' && priority >= this._queue[0].priority!) ||\n      (mode === 'new' && priority > this._queue[0].priority!)\n    ) {\n      await this.stopVO();\n      this.addToQueue(key, callback, priority);\n      return this.playNext();\n    } else if (mode === 'append') {\n      this.addToQueue(key, callback, priority);\n    } else if (callback) {\n      Logger.warn(`üéüüîá Firing callback without playing VO(s) ${key.join(', ')}`);\n      callback(false);\n    } else {\n      Logger.warn(`üîá Skipped VO(s) ${key.join(', ')} because it is lower priority than what was already playing`);\n    }\n  }\n\n  public async stopVO(): Promise<void> {\n    const activeVO: IAudioInstance | undefined = this.activeVO;\n    const activeItem: IQueueItem | undefined = this._queue[0];\n    this._queue.splice(0, this._queue.length);\n    this._pausedQueue.splice(0, this._pausedQueue.length);\n    activeItem?.timeout?.kill();\n    if (activeVO) {\n      if (!activeVO.media) {\n        Logger.warn(`üõë Stopping VO %c%s%c while it is still loading ${activeVO.id}`);\n        activeVO.remove();\n      } else if (activeVO.isPlaying) {\n        Logger.log(`ü§´ Fading out VO ${activeVO.id} (duration:${this.fadeOutDuration})`);\n        await activeVO.fadeTo(0, this.fadeOutDuration);\n        activeVO.stop();\n      } else {\n        activeVO.stop();\n      }\n    } else {\n      Logger.warn('üõë No active VO to stop');\n      this.activeTimeout?.kill();\n    }\n    this.clearSignalConnections();\n    this._paused = false;\n    this.onVoiceOverStopped.emit(activeVO);\n  }\n\n  pauseVO() {\n    if (this._paused) return;\n    if (this._queue.length > 0) {\n      this._paused = true;\n      this._pausedQueue.push(...this._queue);\n      const activeVO = this.activeVO;\n      const activeTimeout = this.activeTimeout;\n      activeVO?.pause();\n      activeTimeout?.pause();\n      this._queue.splice(0, this._queue.length);\n    }\n  }\n\n  resumeVO() {\n    if (!this._paused) return;\n    this._paused = false;\n    if (this._pausedQueue.length > 0) {\n      this._queue.push(...this._pausedQueue);\n      this._pausedQueue.splice(0, this._pausedQueue.length);\n      const activeVO = this.activeVO;\n      const activeTimeout = this.activeTimeout;\n      activeVO?.resume();\n      activeTimeout?.resume();\n      if (activeVO) {\n        this.onVoiceOverStart.emit(activeVO);\n      }\n    }\n  }\n\n  protected getCoreSignals(): string[] {\n    return ['onVoiceOverStart', 'onVoiceOverPaused', 'onVoiceOverComplete', 'onVoiceOverResumed', 'onVoiceOverStopped'];\n  }\n\n  private addToQueue(keys: VoKey[], cb?: VoCallback, priority?: number) {\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (typeof key === 'number') {\n        Logger.log(`‚ûï Queueing delay ${key}`);\n      } else {\n        Logger.log(`‚ûï Queueing VO ${key}`);\n      }\n\n      this._queue.push({\n        key: typeof key === 'string' ? key : '',\n        delay: typeof key === 'number' ? key : undefined,\n        callback: i === keys.length - 1 ? cb : undefined,\n        priority,\n      });\n    }\n    const toLoad = keys.filter((it) => typeof it === 'string') as string[];\n    Logger.log(`üìÇ Loading VO(s) ${toLoad.join(', ')}`);\n    this.app.audio.load(toLoad, 'voiceover');\n  }\n\n  private async playNext(): Promise<IAudioInstance | void> {\n    if (this._queue.length > 0) {\n      const item = this._queue[0];\n      if (item.delay !== undefined) {\n        this.activeTimeout?.kill();\n        if (this._queue.length === 1) {\n          // skip delay if last item in queue\n          Logger.log('‚åõ Skipping delay because there are no more items in queue');\n          this._queue.shift();\n          if (item.callback) {\n            item.callback(true);\n          }\n          return this.playNext();\n        } else {\n          Logger.log('‚è≥ Waiting %s seconds before next VO', item.delay);\n          item.timeout = gsap.delayedCall(item.delay, () => {\n            this._queue.shift();\n            if (item.callback) {\n              item.callback(true);\n            }\n            return this.playNext();\n          });\n        }\n      } else {\n        const existing = this.app.audio.getAudioInstance(item.key, 'voiceover');\n        if (existing) {\n          if (existing.isPlaying) {\n            Logger.warn('üõë Stopping VO %c%s%c (no fade out)', existing.id);\n            existing.stop();\n            this.onVoiceOverComplete.emit(existing);\n          }\n        } else {\n          Logger.log('üìÇ Loading VO %c%s%c', item.key);\n        }\n        const instance = await this.app.audio.play(item.key, 'voiceover', { singleInstance: true });\n        if (this.activeVO) {\n          this.onVoiceOverStart.emit(this.activeVO);\n        }\n        if (this._queue[0] !== item) {\n          return;\n        }\n        Logger.log(`‚ñ∂Ô∏è‚ñ∂Ô∏è Playing VO ${item.key}`);\n        Logger.log('‚ÑπÔ∏è Queue length:', this._queue.length);\n\n        if (this.activeVO) {\n          this.addSignalConnection(\n            this.activeVO.onEnd.connectOnce(this._handleActiveVOEnded),\n            this.activeVO.onPaused.connectOnce(this._handleActiveVOPaused),\n            this.activeVO.onResumed.connectOnce(this._handleActiveVOResumed),\n            this.activeVO.onStart.connectOnce(this._handleActiveVOStarted),\n          );\n        } else {\n          Logger.error('‚ö†Ô∏è Vo %c%s%c completed early (did not play?)', item.key);\n          this._handleActiveVOEndedWithoutPlaying(instance);\n        }\n        return instance;\n      }\n    } else {\n      Logger.log('‚úÖ Nothing left in queue');\n    }\n  }\n\n  private _handleActiveVOStarted(instance: IAudioInstance) {\n    this.onVoiceOverStart.emit(this.activeVO || instance);\n  }\n\n  private _handleActiveVOPaused(instance: IAudioInstance) {\n    this.onVoiceOverPaused.emit(this.activeVO || instance);\n  }\n\n  private _handleActiveVOResumed(instance: IAudioInstance) {\n    this.onVoiceOverResumed.emit(this.activeVO || instance);\n  }\n\n  private _handleActiveVOEndedWithoutPlaying(instance: IAudioInstance) {\n    this.onVoiceOverComplete.emit(this.activeVO || instance);\n    this.activeTimeout?.kill();\n    this._currentItemCallback(false);\n    this._queue.shift();\n    this.playNext();\n  }\n\n  private _handleActiveVOEnded(instance: IAudioInstance) {\n    this.onVoiceOverComplete.emit(this.activeVO || instance);\n    this.activeTimeout?.kill();\n    this._currentItemCallback();\n    this._queue.shift();\n    this.playNext();\n  }\n\n  private _currentItemCallback(didPlay: boolean = true) {\n    const item = this._queue[0];\n    if (!item) {\n      return;\n    }\n    Logger.log(`üèÅ Completed VO ${item.key}`);\n    if (item.callback) {\n      Logger.log(`'üéü Firing callback for`, item.key);\n      item.callback(didPlay);\n    }\n  }\n\n  private onPause() {\n    if (this.activeVO !== undefined && this.activeVO.isPlaying) {\n      Logger.log('‚è∏ Pausing VO', this.activeVO.id);\n      this.activeVO.pause();\n      this.onVoiceOverComplete.emit(this.activeVO);\n    }\n    this.activeTimeout?.pause();\n  }\n\n  private onResume() {\n    if (this.activeVO !== undefined && !this.activeVO.isPlaying) {\n      Logger.log('‚èØ Resuming VO', this.activeVO.id);\n      this.activeVO.resume();\n      this.onVoiceOverStart.emit(this.activeVO);\n    }\n    this.activeTimeout?.resume();\n  }\n}\n"],
  "mappings": "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",
  "names": ["VoiceOverPlugin", "Plugin", "Signal", "_a", "key", "modeOrCallbackOrOptions", "callback", "priority", "mode", "locale", "modeAsOptions", "k", "Logger", "activeVO", "activeItem", "_b", "activeTimeout", "keys", "cb", "i", "toLoad", "it", "item", "existing", "instance", "didPlay"]
}
