{"version":3,"file":"SpinePlugin-DDC9c4H0.mjs","sources":["../src/plugins/spine/spine-core/Utils.ts","../src/plugins/spine/spine-core/attachments/Attachment.ts","../src/plugins/spine/spine-core/attachments/Sequence.ts","../src/plugins/spine/spine-core/Animation.ts","../src/plugins/spine/spine-core/AnimationState.ts","../src/plugins/spine/spine-core/AnimationStateData.ts","../src/plugins/spine/spine-core/attachments/BoundingBoxAttachment.ts","../src/plugins/spine/spine-core/attachments/ClippingAttachment.ts","../src/plugins/spine/spine-core/Texture.ts","../src/plugins/spine/spine-core/TextureAtlas.ts","../src/plugins/spine/spine-core/attachments/MeshAttachment.ts","../src/plugins/spine/spine-core/attachments/PathAttachment.ts","../src/plugins/spine/spine-core/attachments/PointAttachment.ts","../src/plugins/spine/spine-core/attachments/RegionAttachment.ts","../src/plugins/spine/spine-core/AtlasAttachmentLoader.ts","../src/plugins/spine/spine-core/BoneData.ts","../src/plugins/spine/spine-core/Bone.ts","../src/plugins/spine/spine-core/ConstraintData.ts","../src/plugins/spine/spine-core/Event.ts","../src/plugins/spine/spine-core/EventData.ts","../src/plugins/spine/spine-core/IkConstraint.ts","../src/plugins/spine/spine-core/IkConstraintData.ts","../src/plugins/spine/spine-core/PathConstraintData.ts","../src/plugins/spine/spine-core/PathConstraint.ts","../src/plugins/spine/spine-core/Slot.ts","../src/plugins/spine/spine-core/TransformConstraint.ts","../src/plugins/spine/spine-core/Skeleton.ts","../src/plugins/spine/spine-core/SkeletonData.ts","../src/plugins/spine/spine-core/Skin.ts","../src/plugins/spine/spine-core/SlotData.ts","../src/plugins/spine/spine-core/TransformConstraintData.ts","../src/plugins/spine/spine-core/SkeletonBinary.ts","../src/plugins/spine/spine-core/SkeletonBounds.ts","../src/plugins/spine/spine-core/Triangulator.ts","../src/plugins/spine/spine-core/SkeletonClipping.ts","../src/plugins/spine/spine-core/SkeletonJson.ts","../src/plugins/spine/spine-core/polyfills.ts","../src/plugins/spine/pixi-spine/SpineTexture.ts","../src/plugins/spine/pixi-spine/assets/atlasLoader.ts","../src/plugins/spine/pixi-spine/assets/skeletonLoader.ts","../src/plugins/spine/pixi-spine/BatchableClippedSpineSlot.ts","../src/plugins/spine/pixi-spine/BatchableSpineSlot.ts","../src/plugins/spine/pixi-spine/SpinePipe.ts","../src/plugins/spine/pixi-spine/getSkeletonBounds.ts","../src/plugins/spine/pixi-spine/Spine.ts","../src/plugins/spine/SpinePlugin.ts"],"sourcesContent":["/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { MixBlend } from './Animation';\nimport { Skeleton } from './Skeleton';\n\nexport interface StringMap<T> {\n  [key: string]: T;\n}\n\nexport class IntSet {\n  array = new Array<number | undefined>();\n\n  add(value: number): boolean {\n    const contains = this.contains(value);\n    this.array[value | 0] = value | 0;\n    return !contains;\n  }\n\n  contains(value: number) {\n    return this.array[value | 0] != undefined;\n  }\n\n  remove(value: number) {\n    this.array[value | 0] = undefined;\n  }\n\n  clear() {\n    this.array.length = 0;\n  }\n}\n\nexport class StringSet {\n  entries: StringMap<boolean> = {};\n  size = 0;\n\n  add(value: string): boolean {\n    const contains = this.entries[value];\n    this.entries[value] = true;\n    if (!contains) {\n      this.size++;\n      return true;\n    }\n    return false;\n  }\n\n  addAll(values: string[]): boolean {\n    const oldSize = this.size;\n    for (let i = 0, n = values.length; i < n; i++) this.add(values[i]);\n    return oldSize != this.size;\n  }\n\n  contains(value: string) {\n    return this.entries[value];\n  }\n\n  clear() {\n    this.entries = {};\n    this.size = 0;\n  }\n}\n\nexport interface NumberArrayLike {\n  readonly length: number;\n\n  [n: number]: number;\n}\n\nexport interface Disposable {\n  dispose(): void;\n}\n\nexport interface Restorable {\n  restore(): void;\n}\n\nexport class Color {\n  // public static WHITE = new Color(1, 1, 1, 1);\n  // public static RED = new Color(1, 0, 0, 1);\n  // public static GREEN = new Color(0, 1, 0, 1);\n  // public static BLUE = new Color(0, 0, 1, 1);\n  // public static MAGENTA = new Color(1, 0, 1, 1);\n\n  public static WHITE: Color;\n  public static RED: Color;\n  public static GREEN: Color;\n  public static BLUE: Color;\n  public static MAGENTA: Color;\n\n  static rgba8888ToColor(color: Color, value: number) {\n    color.r = ((value & 0xff000000) >>> 24) / 255;\n    color.g = ((value & 0x00ff0000) >>> 16) / 255;\n    color.b = ((value & 0x0000ff00) >>> 8) / 255;\n    color.a = (value & 0x000000ff) / 255;\n  }\n\n  static rgb888ToColor(color: Color, value: number) {\n    color.r = ((value & 0x00ff0000) >>> 16) / 255;\n    color.g = ((value & 0x0000ff00) >>> 8) / 255;\n    color.b = (value & 0x000000ff) / 255;\n  }\n\n  static fromString(hex: string): Color {\n    return new Color().setFromString(hex);\n  }\n\n  constructor(\n    public r: number = 0,\n    public g: number = 0,\n    public b: number = 0,\n    public a: number = 0,\n  ) {}\n\n  set(r: number, g: number, b: number, a: number) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n    return this.clamp();\n  }\n\n  setFromColor(c: Color) {\n    this.r = c.r;\n    this.g = c.g;\n    this.b = c.b;\n    this.a = c.a;\n    return this;\n  }\n\n  setFromString(hex: string) {\n    hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\n    this.r = parseInt(hex.substr(0, 2), 16) / 255;\n    this.g = parseInt(hex.substr(2, 2), 16) / 255;\n    this.b = parseInt(hex.substr(4, 2), 16) / 255;\n    this.a = hex.length != 8 ? 1 : parseInt(hex.substr(6, 2), 16) / 255;\n    return this;\n  }\n\n  add(r: number, g: number, b: number, a: number) {\n    this.r += r;\n    this.g += g;\n    this.b += b;\n    this.a += a;\n    return this.clamp();\n  }\n\n  clamp() {\n    if (this.r < 0) this.r = 0;\n    else if (this.r > 1) this.r = 1;\n\n    if (this.g < 0) this.g = 0;\n    else if (this.g > 1) this.g = 1;\n\n    if (this.b < 0) this.b = 0;\n    else if (this.b > 1) this.b = 1;\n\n    if (this.a < 0) this.a = 0;\n    else if (this.a > 1) this.a = 1;\n    return this;\n  }\n}\n\nColor.WHITE = new Color(1, 1, 1, 1);\nColor.RED = new Color(1, 0, 0, 1);\nColor.GREEN = new Color(0, 1, 0, 1);\nColor.BLUE = new Color(0, 0, 1, 1);\nColor.MAGENTA = new Color(1, 0, 1, 1);\n\nexport class MathUtils {\n  static PI: number;\n  static PI2: number;\n  static radiansToDegrees: number;\n  static radDeg: number;\n  static degreesToRadians: number;\n  static degRad: number;\n\n  static clamp(value: number, min: number, max: number) {\n    if (value < min) return min;\n    if (value > max) return max;\n    return value;\n  }\n\n  static cosDeg(degrees: number) {\n    return Math.cos(degrees * MathUtils.degRad);\n  }\n\n  static sinDeg(degrees: number) {\n    return Math.sin(degrees * MathUtils.degRad);\n  }\n\n  static signum(value: number): number {\n    return value > 0 ? 1 : value < 0 ? -1 : 0;\n  }\n\n  static toInt(x: number) {\n    return x > 0 ? Math.floor(x) : Math.ceil(x);\n  }\n\n  static cbrt(x: number) {\n    const y = Math.pow(Math.abs(x), 1 / 3);\n    return x < 0 ? -y : y;\n  }\n\n  static randomTriangular(min: number, max: number): number {\n    return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\n  }\n\n  static randomTriangularWith(min: number, max: number, mode: number): number {\n    const u = Math.random();\n    const d = max - min;\n    if (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));\n    return max - Math.sqrt((1 - u) * d * (max - mode));\n  }\n\n  static isPowerOfTwo(value: number) {\n    return value && (value & (value - 1)) === 0;\n  }\n}\n\nMathUtils.PI = Math.PI;\nMathUtils.PI2 = Math.PI * 2;\nMathUtils.radiansToDegrees = 180 / MathUtils.PI;\nMathUtils.radDeg = MathUtils.radiansToDegrees;\nMathUtils.degreesToRadians = MathUtils.PI / 180;\nMathUtils.degRad = MathUtils.degreesToRadians;\n\nexport abstract class Interpolation {\n  apply(start: number, end: number, a: number): number {\n    return start + (end - start) * this.applyInternal(a);\n  }\n\n  protected abstract applyInternal(a: number): number;\n}\n\nexport class Pow extends Interpolation {\n  protected power = 2;\n\n  constructor(power: number) {\n    super();\n    this.power = power;\n  }\n\n  applyInternal(a: number): number {\n    if (a <= 0.5) return Math.pow(a * 2, this.power) / 2;\n    return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\n  }\n}\n\nexport class PowOut extends Pow {\n  constructor(power: number) {\n    super(power);\n  }\n\n  applyInternal(a: number): number {\n    return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\n  }\n}\n\nexport class Utils {\n  static SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== 'undefined';\n\n  static arrayCopy<T>(\n    source: ArrayLike<T>,\n    sourceStart: number,\n    dest: ArrayLike<T>,\n    destStart: number,\n    numElements: number,\n  ) {\n    for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\n      dest[j] = source[i];\n    }\n  }\n\n  static arrayFill<T>(array: ArrayLike<T>, fromIndex: number, toIndex: number, value: T) {\n    for (let i = fromIndex; i < toIndex; i++) array[i] = value;\n  }\n\n  static setArraySize<T>(array: Array<T>, size: number, value: any = 0): Array<T> {\n    const oldSize = array.length;\n    if (oldSize == size) return array;\n    array.length = size;\n    if (oldSize < size) {\n      for (let i = oldSize; i < size; i++) array[i] = value;\n    }\n    return array;\n  }\n\n  static ensureArrayCapacity<T>(array: Array<T>, size: number, value: any = 0): Array<T> {\n    if (array.length >= size) return array;\n    return Utils.setArraySize(array, size, value);\n  }\n\n  static newArray<T>(size: number, defaultValue: T): Array<T> {\n    const array = new Array<T>(size);\n    for (let i = 0; i < size; i++) array[i] = defaultValue;\n    return array;\n  }\n\n  static newFloatArray(size: number): NumberArrayLike {\n    if (Utils.SUPPORTS_TYPED_ARRAYS) return new Float32Array(size);\n    else {\n      const array = new Array<number>(size);\n      for (let i = 0; i < array.length; i++) array[i] = 0;\n      return array;\n    }\n  }\n\n  static newShortArray(size: number): NumberArrayLike {\n    if (Utils.SUPPORTS_TYPED_ARRAYS) return new Int16Array(size);\n    else {\n      const array = new Array<number>(size);\n      for (let i = 0; i < array.length; i++) array[i] = 0;\n      return array;\n    }\n  }\n\n  static toFloatArray(array: Array<number>) {\n    return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\n  }\n\n  static toSinglePrecision(value: number) {\n    return Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\n  }\n\n  // This function is used to fix WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n  static webkit602BugfixHelper(alpha: number, blend: MixBlend) {}\n\n  static contains<T>(array: Array<T>, element: T, identity = true) {\n    for (let i = 0; i < array.length; i++) if (array[i] == element) return true;\n    return false;\n  }\n\n  static enumValue(type: any, name: string) {\n    return type[name[0].toUpperCase() + name.slice(1)];\n  }\n}\n\nexport class DebugUtils {\n  static logBones(skeleton: Skeleton) {\n    for (let i = 0; i < skeleton.bones.length; i++) {\n      const bone = skeleton.bones[i];\n      console.log(\n        bone.data.name +\n          ', ' +\n          bone.a +\n          ', ' +\n          bone.b +\n          ', ' +\n          bone.c +\n          ', ' +\n          bone.d +\n          ', ' +\n          bone.worldX +\n          ', ' +\n          bone.worldY,\n      );\n    }\n  }\n}\n\nexport class Pool<T> {\n  private items = new Array<T>();\n  private instantiator: () => T;\n\n  constructor(instantiator: () => T) {\n    this.instantiator = instantiator;\n  }\n\n  obtain() {\n    return this.items.length > 0 ? this.items.pop()! : this.instantiator();\n  }\n\n  free(item: T) {\n    if ((item as any).reset) (item as any).reset();\n    this.items.push(item);\n  }\n\n  freeAll(items: ArrayLike<T>) {\n    for (let i = 0; i < items.length; i++) this.free(items[i]);\n  }\n\n  clear() {\n    this.items.length = 0;\n  }\n}\n\nexport class Vector2 {\n  constructor(\n    public x = 0,\n    public y = 0,\n  ) {}\n\n  set(x: number, y: number): Vector2 {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  length() {\n    const x = this.x;\n    const y = this.y;\n    return Math.sqrt(x * x + y * y);\n  }\n\n  normalize() {\n    const len = this.length();\n    if (len != 0) {\n      this.x /= len;\n      this.y /= len;\n    }\n    return this;\n  }\n}\n\nexport class TimeKeeper {\n  maxDelta = 0.064;\n  framesPerSecond = 0;\n  delta = 0;\n  totalTime = 0;\n\n  private lastTime = Date.now() / 1000;\n  private frameCount = 0;\n  private frameTime = 0;\n\n  update() {\n    const now = Date.now() / 1000;\n    this.delta = now - this.lastTime;\n    this.frameTime += this.delta;\n    this.totalTime += this.delta;\n    if (this.delta > this.maxDelta) this.delta = this.maxDelta;\n    this.lastTime = now;\n\n    this.frameCount++;\n    if (this.frameTime > 1) {\n      this.framesPerSecond = this.frameCount / this.frameTime;\n      this.frameTime = 0;\n      this.frameCount = 0;\n    }\n  }\n}\n\nexport interface ArrayLike<T> {\n  length: number;\n\n  [n: number]: T;\n}\n\nexport class WindowedMean {\n  values: Array<number>;\n  addedValues = 0;\n  lastValue = 0;\n  mean = 0;\n  dirty = true;\n\n  constructor(windowSize: number = 32) {\n    this.values = new Array<number>(windowSize);\n  }\n\n  hasEnoughData() {\n    return this.addedValues >= this.values.length;\n  }\n\n  addValue(value: number) {\n    if (this.addedValues < this.values.length) this.addedValues++;\n    this.values[this.lastValue++] = value;\n    if (this.lastValue > this.values.length - 1) this.lastValue = 0;\n    this.dirty = true;\n  }\n\n  getMean() {\n    if (this.hasEnoughData()) {\n      if (this.dirty) {\n        let mean = 0;\n        for (let i = 0; i < this.values.length; i++) mean += this.values[i];\n        this.mean = mean / this.values.length;\n        this.dirty = false;\n      }\n      return this.mean;\n    }\n    return 0;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Slot } from '../Slot';\nimport { NumberArrayLike, Utils } from '../Utils';\n\n/** The base class for all attachments. */\nexport abstract class Attachment {\n  name: string;\n\n  constructor(name: string) {\n    if (!name) throw new Error('name cannot be null.');\n    this.name = name;\n  }\n\n  abstract copy(): Attachment;\n}\n\n/** Base class for an attachment with vertices that are transformed by one or more bones and can be deformed by a slot's\n * {@link Slot#deform}. */\nexport abstract class VertexAttachment extends Attachment {\n  private static nextID = 0;\n\n  /** The unique ID for this attachment. */\n  id = VertexAttachment.nextID++;\n\n  /** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting\n   * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null\n   * if this attachment has no weights. */\n  bones: Array<number> | null = null;\n\n  /** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`\n   * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting\n   * each vertex. */\n  vertices: NumberArrayLike = [];\n\n  /** The maximum number of world vertex values that can be output by\n   * {@link #computeWorldVertices()} using the `count` parameter. */\n  worldVerticesLength = 0;\n\n  /** Timelines for the timeline attachment are also applied to this attachment.\n   * May be null if no attachment-specific timelines should be applied. */\n  timelineAttachment: Attachment = this;\n\n  constructor(name: string) {\n    super(name);\n  }\n\n  /** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is\n   * not empty, it is used to deform the vertices.\n   *\n   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n   * Runtimes Guide.\n   * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.\n   * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.\n   * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *\n   *           `stride` / 2.\n   * @param offset The `worldVertices` index to begin writing values.\n   * @param stride The number of `worldVertices` entries between the value pairs written. */\n  computeWorldVertices(\n    slot: Slot,\n    start: number,\n    count: number,\n    worldVertices: NumberArrayLike,\n    offset: number,\n    stride: number,\n  ) {\n    count = offset + (count >> 1) * stride;\n    const skeleton = slot.bone.skeleton;\n    const deformArray = slot.deform;\n    let vertices = this.vertices;\n    const bones = this.bones;\n    if (!bones) {\n      if (deformArray.length > 0) vertices = deformArray;\n      const bone = slot.bone;\n      const x = bone.worldX;\n      const y = bone.worldY;\n      const a = bone.a,\n        b = bone.b,\n        c = bone.c,\n        d = bone.d;\n      for (let v = start, w = offset; w < count; v += 2, w += stride) {\n        const vx = vertices[v],\n          vy = vertices[v + 1];\n        worldVertices[w] = vx * a + vy * b + x;\n        worldVertices[w + 1] = vx * c + vy * d + y;\n      }\n      return;\n    }\n    let v = 0,\n      skip = 0;\n    for (let i = 0; i < start; i += 2) {\n      const n = bones[v];\n      v += n + 1;\n      skip += n;\n    }\n    const skeletonBones = skeleton.bones;\n    if (deformArray.length == 0) {\n      for (let w = offset, b = skip * 3; w < count; w += stride) {\n        let wx = 0,\n          wy = 0;\n        let n = bones[v++];\n        n += v;\n        for (; v < n; v++, b += 3) {\n          const bone = skeletonBones[bones[v]];\n          const vx = vertices[b],\n            vy = vertices[b + 1],\n            weight = vertices[b + 2];\n          wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\n          wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\n        }\n        worldVertices[w] = wx;\n        worldVertices[w + 1] = wy;\n      }\n    } else {\n      const deform = deformArray;\n      for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n        let wx = 0,\n          wy = 0;\n        let n = bones[v++];\n        n += v;\n        for (; v < n; v++, b += 3, f += 2) {\n          const bone = skeletonBones[bones[v]];\n          const vx = vertices[b] + deform[f],\n            vy = vertices[b + 1] + deform[f + 1],\n            weight = vertices[b + 2];\n          wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\n          wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\n        }\n        worldVertices[w] = wx;\n        worldVertices[w + 1] = wy;\n      }\n    }\n  }\n\n  /** Does not copy id (generated) or name (set on construction). **/\n  copyTo(attachment: VertexAttachment) {\n    if (this.bones) {\n      attachment.bones = new Array<number>(this.bones.length);\n      Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\n    } else attachment.bones = null;\n\n    if (this.vertices) {\n      attachment.vertices = Utils.newFloatArray(this.vertices.length);\n      Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\n    }\n\n    attachment.worldVerticesLength = this.worldVerticesLength;\n    attachment.timelineAttachment = this.timelineAttachment;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Slot } from '../Slot';\nimport { TextureRegion } from '../Texture';\nimport { Utils } from '../Utils';\nimport { HasTextureRegion } from './HasTextureRegion';\n\nexport class Sequence {\n  private static _nextID = 0;\n\n  id = Sequence.nextID();\n  regions: TextureRegion[];\n  start = 0;\n  digits = 0;\n  /** The index of the region to show for the setup pose. */\n  setupIndex = 0;\n\n  private static nextID(): number {\n    return Sequence._nextID++;\n  }\n\n  constructor(count: number) {\n    this.regions = new Array<TextureRegion>(count);\n  }\n\n  copy(): Sequence {\n    const copy = new Sequence(this.regions.length);\n    Utils.arrayCopy(this.regions, 0, copy.regions, 0, this.regions.length);\n    copy.start = this.start;\n    copy.digits = this.digits;\n    copy.setupIndex = this.setupIndex;\n    return copy;\n  }\n\n  apply(slot: Slot, attachment: HasTextureRegion) {\n    let index = slot.sequenceIndex;\n    if (index == -1) index = this.setupIndex;\n    if (index >= this.regions.length) index = this.regions.length - 1;\n    const region = this.regions[index];\n    if (attachment.region != region) {\n      attachment.region = region;\n      attachment.updateRegion();\n    }\n  }\n\n  getPath(basePath: string, index: number): string {\n    let result = basePath;\n    const frame = (this.start + index).toString();\n    for (let i = this.digits - frame.length; i > 0; i--) result += '0';\n    result += frame;\n    return result;\n  }\n}\n\nexport enum SequenceMode {\n  hold = 0,\n  once = 1,\n  loop = 2,\n  pingpong = 3,\n  onceReverse = 4,\n  loopReverse = 5,\n  pingpongReverse = 6,\n}\n\nexport const SequenceModeValues = [\n  SequenceMode.hold,\n  SequenceMode.once,\n  SequenceMode.loop,\n  SequenceMode.pingpong,\n  SequenceMode.onceReverse,\n  SequenceMode.loopReverse,\n  SequenceMode.pingpongReverse,\n];\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Attachment, VertexAttachment } from './attachments/Attachment';\nimport { HasTextureRegion } from './attachments/HasTextureRegion';\nimport { SequenceMode, SequenceModeValues } from './attachments/Sequence';\nimport { Event } from './Event';\nimport { IkConstraint } from './IkConstraint';\nimport { PathConstraint } from './PathConstraint';\nimport { Skeleton } from './Skeleton';\nimport { Slot } from './Slot';\nimport { TransformConstraint } from './TransformConstraint';\nimport { MathUtils, NumberArrayLike, StringSet, Utils } from './Utils';\n\n/** A simple container for a list of timelines and a name. */\nexport class Animation {\n  /** The animation's name, which is unique across all animations in the skeleton. */\n  name: string;\n  timelines: Array<Timeline> = [];\n  timelineIds: StringSet = new StringSet();\n\n  /** The duration of the animation in seconds, which is the highest time of all keys in the timeline. */\n  duration: number;\n\n  constructor(name: string, timelines: Array<Timeline>, duration: number) {\n    if (!name) throw new Error('name cannot be null.');\n    this.name = name;\n    this.setTimelines(timelines);\n    this.duration = duration;\n  }\n\n  setTimelines(timelines: Array<Timeline>) {\n    if (!timelines) throw new Error('timelines cannot be null.');\n    this.timelines = timelines;\n    this.timelineIds.clear();\n    for (let i = 0; i < timelines.length; i++) this.timelineIds.addAll(timelines[i].getPropertyIds());\n  }\n\n  hasTimeline(ids: string[]): boolean {\n    for (let i = 0; i < ids.length; i++) if (this.timelineIds.contains(ids[i])) return true;\n    return false;\n  }\n\n  /** Applies all the animation's timelines to the specified skeleton.\n   *\n   * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n   * @param loop If true, the animation repeats after {@link #getDuration()}.\n   * @param events May be null to ignore fired events. */\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    loop: boolean,\n    events: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    if (!skeleton) throw new Error('skeleton cannot be null.');\n\n    if (loop && this.duration != 0) {\n      time %= this.duration;\n      if (lastTime > 0) lastTime %= this.duration;\n    }\n\n    const timelines = this.timelines;\n    for (let i = 0, n = timelines.length; i < n; i++)\n      timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n  }\n}\n\n/** Controls how a timeline value is mixed with the setup pose value or current pose value when a timeline's `alpha`\n * < 1.\n *\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}. */\nexport enum MixBlend {\n  /** Transitions from the setup value to the timeline value (the current value is not used). Before the first key, the setup\n   * value is set. */\n  setup,\n  /** Transitions from the current value to the timeline value. Before the first key, transitions from the current value to\n   * the setup value. Timelines which perform instant transitions, such as {@link DrawOrderTimeline} or\n   * {@link AttachmentTimeline}, use the setup value before the first key.\n   *\n   * `first` is intended for the first animations applied, not for animations layered on top of those. */\n  first,\n  /** Transitions from the current value to the timeline value. No change is made before the first key (the current value is\n   * kept until the first key).\n   *\n   * `replace` is intended for animations layered on top of others, not for the first animations applied. */\n  replace,\n  /** Transitions from the current value to the current value plus the timeline value. No change is made before the first key\n   * (the current value is kept until the first key).\n   *\n   * `add` is intended for animations layered on top of others, not for the first animations applied. Properties\n   * keyed by additive animations must be set manually or by another animation before applying the additive animations, else\n   * the property values will increase continually. */\n  add,\n}\n\n/** Indicates whether a timeline's `alpha` is mixing out over time toward 0 (the setup or current pose value) or\n * mixing in toward 1 (the timeline's value).\n *\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}. */\nexport enum MixDirection {\n  mixIn,\n  mixOut,\n}\n\nconst Property = {\n  rotate: 0,\n  x: 1,\n  y: 2,\n  scaleX: 3,\n  scaleY: 4,\n  shearX: 5,\n  shearY: 6,\n\n  rgb: 7,\n  alpha: 8,\n  rgb2: 9,\n\n  attachment: 10,\n  deform: 11,\n\n  event: 12,\n  drawOrder: 13,\n\n  ikConstraint: 14,\n  transformConstraint: 15,\n\n  pathConstraintPosition: 16,\n  pathConstraintSpacing: 17,\n  pathConstraintMix: 18,\n\n  sequence: 19,\n};\n\n/** The interface for all timelines. */\nexport abstract class Timeline {\n  propertyIds: string[];\n  frames: NumberArrayLike;\n\n  static search1(frames: NumberArrayLike, time: number) {\n    const n = frames.length;\n    for (let i = 1; i < n; i++) if (frames[i] > time) return i - 1;\n    return n - 1;\n  }\n\n  static search(frames: NumberArrayLike, time: number, step: number) {\n    const n = frames.length;\n    for (let i = step; i < n; i += step) if (frames[i] > time) return i - step;\n    return n - step;\n  }\n\n  constructor(frameCount: number, propertyIds: string[]) {\n    this.propertyIds = propertyIds;\n    this.frames = Utils.newFloatArray(frameCount * this.getFrameEntries());\n  }\n\n  getPropertyIds() {\n    return this.propertyIds;\n  }\n\n  getFrameEntries(): number {\n    return 1;\n  }\n\n  getFrameCount() {\n    return this.frames.length / this.getFrameEntries();\n  }\n\n  getDuration(): number {\n    return this.frames[this.frames.length - this.getFrameEntries()];\n  }\n\n  abstract apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event> | null,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ): void;\n}\n\nexport interface BoneTimeline {\n  /** The index of the bone in {@link Skeleton#bones} that will be changed. */\n  boneIndex: number;\n}\n\nexport interface SlotTimeline {\n  /** The index of the slot in {@link Skeleton#slots} that will be changed. */\n  slotIndex: number;\n}\n\n/** The base class for timelines that use interpolation between key frame values. */\nexport abstract class CurveTimeline extends Timeline {\n  protected curves: NumberArrayLike; // type, x, y, ...\n\n  constructor(frameCount: number, bezierCount: number, propertyIds: string[]) {\n    super(frameCount, propertyIds);\n    this.curves = Utils.newFloatArray(frameCount + bezierCount * 18 /*BEZIER_SIZE*/);\n    this.curves[frameCount - 1] = 1 /*STEPPED*/;\n  }\n\n  /** Sets the specified key frame to linear interpolation. */\n  setLinear(frame: number) {\n    this.curves[frame] = 0 /*LINEAR*/;\n  }\n\n  /** Sets the specified key frame to stepped interpolation. */\n  setStepped(frame: number) {\n    this.curves[frame] = 1 /*STEPPED*/;\n  }\n\n  /** Shrinks the storage for Bezier curves, for use when <code>bezierCount</code> (specified in the constructor) was larger\n   * than the actual number of Bezier curves. */\n  shrink(bezierCount: number) {\n    const size = this.getFrameCount() + bezierCount * 18; /*BEZIER_SIZE*/\n    if (this.curves.length > size) {\n      const newCurves = Utils.newFloatArray(size);\n      Utils.arrayCopy(this.curves, 0, newCurves, 0, size);\n      this.curves = newCurves;\n    }\n  }\n\n  /** Stores the segments for the specified Bezier curve. For timelines that modify multiple values, there may be more than\n   * one curve per frame.\n   * @param bezier The ordinal of this Bezier curve for this timeline, between 0 and <code>bezierCount - 1</code> (specified\n   *           in the constructor), inclusive.\n   * @param frame Between 0 and <code>frameCount - 1</code>, inclusive.\n   * @param value The index of the value for this frame that this curve is used for.\n   * @param time1 The time for the first key.\n   * @param value1 The value for the first key.\n   * @param cx1 The time for the first Bezier handle.\n   * @param cy1 The value for the first Bezier handle.\n   * @param cx2 The time of the second Bezier handle.\n   * @param cy2 The value for the second Bezier handle.\n   * @param time2 The time for the second key.\n   * @param value2 The value for the second key. */\n  setBezier(\n    bezier: number,\n    frame: number,\n    value: number,\n    time1: number,\n    value1: number,\n    cx1: number,\n    cy1: number,\n    cx2: number,\n    cy2: number,\n    time2: number,\n    value2: number,\n  ) {\n    const curves = this.curves;\n    let i = this.getFrameCount() + bezier * 18; /*BEZIER_SIZE*/\n    if (value == 0) curves[frame] = 2 /*BEZIER*/ + i;\n    const tmpx = (time1 - cx1 * 2 + cx2) * 0.03,\n      tmpy = (value1 - cy1 * 2 + cy2) * 0.03;\n    const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006,\n      dddy = ((cy1 - cy2) * 3 - value1 + value2) * 0.006;\n    let ddx = tmpx * 2 + dddx,\n      ddy = tmpy * 2 + dddy;\n    let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667,\n      dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;\n    let x = time1 + dx,\n      y = value1 + dy;\n    for (let n = i + 18 /*BEZIER_SIZE*/; i < n; i += 2) {\n      curves[i] = x;\n      curves[i + 1] = y;\n      dx += ddx;\n      dy += ddy;\n      ddx += dddx;\n      ddy += dddy;\n      x += dx;\n      y += dy;\n    }\n  }\n\n  /** Returns the Bezier interpolated value for the specified time.\n   * @param frameIndex The index into {@link #getFrames()} for the values of the frame before <code>time</code>.\n   * @param valueOffset The offset from <code>frameIndex</code> to the value this curve is used for.\n   * @param i The index of the Bezier segments. See {@link #getCurveType(int)}. */\n  getBezierValue(time: number, frameIndex: number, valueOffset: number, i: number) {\n    const curves = this.curves;\n    if (curves[i] > time) {\n      const x = this.frames[frameIndex],\n        y = this.frames[frameIndex + valueOffset];\n      return y + ((time - x) / (curves[i] - x)) * (curves[i + 1] - y);\n    }\n    const n = i + 18; /*BEZIER_SIZE*/\n    for (i += 2; i < n; i += 2) {\n      if (curves[i] >= time) {\n        const x = curves[i - 2],\n          y = curves[i - 1];\n        return y + ((time - x) / (curves[i] - x)) * (curves[i + 1] - y);\n      }\n    }\n    frameIndex += this.getFrameEntries();\n    const x = curves[n - 2],\n      y = curves[n - 1];\n    return y + ((time - x) / (this.frames[frameIndex] - x)) * (this.frames[frameIndex + valueOffset] - y);\n  }\n}\n\nexport abstract class CurveTimeline1 extends CurveTimeline {\n  constructor(frameCount: number, bezierCount: number, propertyId: string) {\n    super(frameCount, bezierCount, [propertyId]);\n  }\n\n  getFrameEntries() {\n    return 2 /*ENTRIES*/;\n  }\n\n  /** Sets the time and value for the specified frame.\n   * @param frame Between 0 and <code>frameCount</code>, inclusive.\n   * @param time The frame time in seconds. */\n  setFrame(frame: number, time: number, value: number) {\n    frame <<= 1;\n    this.frames[frame] = time;\n    this.frames[frame + 1 /*VALUE*/] = value;\n  }\n\n  /** Returns the interpolated value for the specified time. */\n  getCurveValue(time: number) {\n    const frames = this.frames;\n    let i = frames.length - 2;\n    for (let ii = 2; ii <= i; ii += 2) {\n      if (frames[ii] > time) {\n        i = ii - 2;\n        break;\n      }\n    }\n\n    const curveType = this.curves[i >> 1];\n    switch (curveType) {\n      case 0 /*LINEAR*/:\n        const before = frames[i],\n          value = frames[i + 1 /*VALUE*/];\n        return (\n          value +\n          ((time - before) / (frames[i + 2 /*ENTRIES*/] - before)) * (frames[i + 2 /*ENTRIES*/ + 1 /*VALUE*/] - value)\n        );\n      case 1 /*STEPPED*/:\n        return frames[i + 1 /*VALUE*/];\n    }\n    return this.getBezierValue(time, i, 1 /*VALUE*/, curveType - 2 /*BEZIER*/);\n  }\n}\n\n/** The base class for a {@link CurveTimeline} which sets two properties. */\nexport abstract class CurveTimeline2 extends CurveTimeline {\n  /** @param bezierCount The maximum number of Bezier curves. See {@link #shrink(int)}.\n   * @param propertyIds Unique identifiers for the properties the timeline modifies. */\n  constructor(frameCount: number, bezierCount: number, propertyId1: string, propertyId2: string) {\n    super(frameCount, bezierCount, [propertyId1, propertyId2]);\n  }\n\n  getFrameEntries() {\n    return 3 /*ENTRIES*/;\n  }\n\n  /** Sets the time and values for the specified frame.\n   * @param frame Between 0 and <code>frameCount</code>, inclusive.\n   * @param time The frame time in seconds. */\n  setFrame(frame: number, time: number, value1: number, value2: number) {\n    frame *= 3 /*ENTRIES*/;\n    this.frames[frame] = time;\n    this.frames[frame + 1 /*VALUE1*/] = value1;\n    this.frames[frame + 2 /*VALUE2*/] = value2;\n  }\n}\n\n/** Changes a bone's local {@link Bone#rotation}. */\nexport class RotateTimeline extends CurveTimeline1 implements BoneTimeline {\n  boneIndex = 0;\n\n  constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n    super(frameCount, bezierCount, Property.rotate + '|' + boneIndex);\n    this.boneIndex = boneIndex;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event> | null,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.rotation = bone.data.rotation;\n          return;\n        case MixBlend.first:\n          bone.rotation += (bone.data.rotation - bone.rotation) * alpha;\n      }\n      return;\n    }\n\n    let r = this.getCurveValue(time);\n    switch (blend) {\n      case MixBlend.setup:\n        bone.rotation = bone.data.rotation + r * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        r += bone.data.rotation - bone.rotation;\n      case MixBlend.add:\n        bone.rotation += r * alpha;\n    }\n  }\n}\n\n/** Changes a bone's local {@link Bone#x} and {@link Bone#y}. */\nexport class TranslateTimeline extends CurveTimeline2 implements BoneTimeline {\n  boneIndex = 0;\n\n  constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n    super(frameCount, bezierCount, Property.x + '|' + boneIndex, Property.y + '|' + boneIndex);\n    this.boneIndex = boneIndex;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.x = bone.data.x;\n          bone.y = bone.data.y;\n          return;\n        case MixBlend.first:\n          bone.x += (bone.data.x - bone.x) * alpha;\n          bone.y += (bone.data.y - bone.y) * alpha;\n      }\n      return;\n    }\n\n    let x = 0,\n      y = 0;\n    const i = Timeline.search(frames, time, 3 /*ENTRIES*/);\n    const curveType = this.curves[i / 3 /*ENTRIES*/];\n    switch (curveType) {\n      case 0 /*LINEAR*/:\n        const before = frames[i];\n        x = frames[i + 1 /*VALUE1*/];\n        y = frames[i + 2 /*VALUE2*/];\n        const t = (time - before) / (frames[i + 3 /*ENTRIES*/] - before);\n        x += (frames[i + 3 /*ENTRIES*/ + 1 /*VALUE1*/] - x) * t;\n        y += (frames[i + 3 /*ENTRIES*/ + 2 /*VALUE2*/] - y) * t;\n        break;\n      case 1 /*STEPPED*/:\n        x = frames[i + 1 /*VALUE1*/];\n        y = frames[i + 2 /*VALUE2*/];\n        break;\n      default:\n        x = this.getBezierValue(time, i, 1 /*VALUE1*/, curveType - 2 /*BEZIER*/);\n        y = this.getBezierValue(time, i, 2 /*VALUE2*/, curveType + 18 /*BEZIER_SIZE*/ - 2 /*BEZIER*/);\n    }\n\n    switch (blend) {\n      case MixBlend.setup:\n        bone.x = bone.data.x + x * alpha;\n        bone.y = bone.data.y + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.x += (bone.data.x + x - bone.x) * alpha;\n        bone.y += (bone.data.y + y - bone.y) * alpha;\n        break;\n      case MixBlend.add:\n        bone.x += x * alpha;\n        bone.y += y * alpha;\n    }\n  }\n}\n\n/** Changes a bone's local {@link Bone#x}. */\nexport class TranslateXTimeline extends CurveTimeline1 implements BoneTimeline {\n  boneIndex = 0;\n\n  constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n    super(frameCount, bezierCount, Property.x + '|' + boneIndex);\n    this.boneIndex = boneIndex;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.x = bone.data.x;\n          return;\n        case MixBlend.first:\n          bone.x += (bone.data.x - bone.x) * alpha;\n      }\n      return;\n    }\n\n    const x = this.getCurveValue(time);\n    switch (blend) {\n      case MixBlend.setup:\n        bone.x = bone.data.x + x * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.x += (bone.data.x + x - bone.x) * alpha;\n        break;\n      case MixBlend.add:\n        bone.x += x * alpha;\n    }\n  }\n}\n\n/** Changes a bone's local {@link Bone#x}. */\nexport class TranslateYTimeline extends CurveTimeline1 implements BoneTimeline {\n  boneIndex = 0;\n\n  constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n    super(frameCount, bezierCount, Property.y + '|' + boneIndex);\n    this.boneIndex = boneIndex;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.y = bone.data.y;\n          return;\n        case MixBlend.first:\n          bone.y += (bone.data.y - bone.y) * alpha;\n      }\n      return;\n    }\n\n    const y = this.getCurveValue(time);\n    switch (blend) {\n      case MixBlend.setup:\n        bone.y = bone.data.y + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.y += (bone.data.y + y - bone.y) * alpha;\n        break;\n      case MixBlend.add:\n        bone.y += y * alpha;\n    }\n  }\n}\n\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}. */\nexport class ScaleTimeline extends CurveTimeline2 implements BoneTimeline {\n  boneIndex = 0;\n\n  constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n    super(frameCount, bezierCount, Property.scaleX + '|' + boneIndex, Property.scaleY + '|' + boneIndex);\n    this.boneIndex = boneIndex;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.scaleX = bone.data.scaleX;\n          bone.scaleY = bone.data.scaleY;\n          return;\n        case MixBlend.first:\n          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n      }\n      return;\n    }\n\n    let x, y;\n    const i = Timeline.search(frames, time, 3 /*ENTRIES*/);\n    const curveType = this.curves[i / 3 /*ENTRIES*/];\n    switch (curveType) {\n      case 0 /*LINEAR*/:\n        const before = frames[i];\n        x = frames[i + 1 /*VALUE1*/];\n        y = frames[i + 2 /*VALUE2*/];\n        const t = (time - before) / (frames[i + 3 /*ENTRIES*/] - before);\n        x += (frames[i + 3 /*ENTRIES*/ + 1 /*VALUE1*/] - x) * t;\n        y += (frames[i + 3 /*ENTRIES*/ + 2 /*VALUE2*/] - y) * t;\n        break;\n      case 1 /*STEPPED*/:\n        x = frames[i + 1 /*VALUE1*/];\n        y = frames[i + 2 /*VALUE2*/];\n        break;\n      default:\n        x = this.getBezierValue(time, i, 1 /*VALUE1*/, curveType - 2 /*BEZIER*/);\n        y = this.getBezierValue(time, i, 2 /*VALUE2*/, curveType + 18 /*BEZIER_SIZE*/ - 2 /*BEZIER*/);\n    }\n    x *= bone.data.scaleX;\n    y *= bone.data.scaleY;\n\n    if (alpha == 1) {\n      if (blend == MixBlend.add) {\n        bone.scaleX += x - bone.data.scaleX;\n        bone.scaleY += y - bone.data.scaleY;\n      } else {\n        bone.scaleX = x;\n        bone.scaleY = y;\n      }\n    } else {\n      let bx = 0,\n        by = 0;\n      if (direction == MixDirection.mixOut) {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = bone.data.scaleX;\n            by = bone.data.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = bone.scaleX;\n            by = bone.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleX += (x - bone.data.scaleX) * alpha;\n            bone.scaleY += (y - bone.data.scaleY) * alpha;\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n            bone.scaleX = bx + (x - bx) * alpha;\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n            by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n            bone.scaleX = bx + (x - bx) * alpha;\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleX += (x - bone.data.scaleX) * alpha;\n            bone.scaleY += (y - bone.data.scaleY) * alpha;\n        }\n      }\n    }\n  }\n}\n\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}. */\nexport class ScaleXTimeline extends CurveTimeline1 implements BoneTimeline {\n  boneIndex = 0;\n\n  constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n    super(frameCount, bezierCount, Property.scaleX + '|' + boneIndex);\n    this.boneIndex = boneIndex;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.scaleX = bone.data.scaleX;\n          return;\n        case MixBlend.first:\n          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n      }\n      return;\n    }\n\n    const x = this.getCurveValue(time) * bone.data.scaleX;\n    if (alpha == 1) {\n      if (blend == MixBlend.add) bone.scaleX += x - bone.data.scaleX;\n      else bone.scaleX = x;\n    } else {\n      // Mixing out uses sign of setup or current pose, else use sign of key.\n      let bx = 0;\n      if (direction == MixDirection.mixOut) {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = bone.data.scaleX;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = bone.scaleX;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleX += (x - bone.data.scaleX) * alpha;\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n            bone.scaleX = bx + (x - bx) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n            bone.scaleX = bx + (x - bx) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleX += (x - bone.data.scaleX) * alpha;\n        }\n      }\n    }\n  }\n}\n\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}. */\nexport class ScaleYTimeline extends CurveTimeline1 implements BoneTimeline {\n  boneIndex = 0;\n\n  constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n    super(frameCount, bezierCount, Property.scaleY + '|' + boneIndex);\n    this.boneIndex = boneIndex;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.scaleY = bone.data.scaleY;\n          return;\n        case MixBlend.first:\n          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n      }\n      return;\n    }\n\n    const y = this.getCurveValue(time) * bone.data.scaleY;\n    if (alpha == 1) {\n      if (blend == MixBlend.add) bone.scaleY += y - bone.data.scaleY;\n      else bone.scaleY = y;\n    } else {\n      // Mixing out uses sign of setup or current pose, else use sign of key.\n      let by = 0;\n      if (direction == MixDirection.mixOut) {\n        switch (blend) {\n          case MixBlend.setup:\n            by = bone.data.scaleY;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            by = bone.scaleY;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleY += (y - bone.data.scaleY) * alpha;\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup:\n            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleY += (y - bone.data.scaleY) * alpha;\n        }\n      }\n    }\n  }\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}. */\nexport class ShearTimeline extends CurveTimeline2 implements BoneTimeline {\n  boneIndex = 0;\n\n  constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n    super(frameCount, bezierCount, Property.shearX + '|' + boneIndex, Property.shearY + '|' + boneIndex);\n    this.boneIndex = boneIndex;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.shearX = bone.data.shearX;\n          bone.shearY = bone.data.shearY;\n          return;\n        case MixBlend.first:\n          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n      }\n      return;\n    }\n\n    let x = 0,\n      y = 0;\n    const i = Timeline.search(frames, time, 3 /*ENTRIES*/);\n    const curveType = this.curves[i / 3 /*ENTRIES*/];\n    switch (curveType) {\n      case 0 /*LINEAR*/:\n        const before = frames[i];\n        x = frames[i + 1 /*VALUE1*/];\n        y = frames[i + 2 /*VALUE2*/];\n        const t = (time - before) / (frames[i + 3 /*ENTRIES*/] - before);\n        x += (frames[i + 3 /*ENTRIES*/ + 1 /*VALUE1*/] - x) * t;\n        y += (frames[i + 3 /*ENTRIES*/ + 2 /*VALUE2*/] - y) * t;\n        break;\n      case 1 /*STEPPED*/:\n        x = frames[i + 1 /*VALUE1*/];\n        y = frames[i + 2 /*VALUE2*/];\n        break;\n      default:\n        x = this.getBezierValue(time, i, 1 /*VALUE1*/, curveType - 2 /*BEZIER*/);\n        y = this.getBezierValue(time, i, 2 /*VALUE2*/, curveType + 18 /*BEZIER_SIZE*/ - 2 /*BEZIER*/);\n    }\n\n    switch (blend) {\n      case MixBlend.setup:\n        bone.shearX = bone.data.shearX + x * alpha;\n        bone.shearY = bone.data.shearY + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n        break;\n      case MixBlend.add:\n        bone.shearX += x * alpha;\n        bone.shearY += y * alpha;\n    }\n  }\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}. */\nexport class ShearXTimeline extends CurveTimeline1 implements BoneTimeline {\n  boneIndex = 0;\n\n  constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n    super(frameCount, bezierCount, Property.shearX + '|' + boneIndex);\n    this.boneIndex = boneIndex;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.shearX = bone.data.shearX;\n          return;\n        case MixBlend.first:\n          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n      }\n      return;\n    }\n\n    const x = this.getCurveValue(time);\n    switch (blend) {\n      case MixBlend.setup:\n        bone.shearX = bone.data.shearX + x * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n        break;\n      case MixBlend.add:\n        bone.shearX += x * alpha;\n    }\n  }\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}. */\nexport class ShearYTimeline extends CurveTimeline1 implements BoneTimeline {\n  boneIndex = 0;\n\n  constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n    super(frameCount, bezierCount, Property.shearY + '|' + boneIndex);\n    this.boneIndex = boneIndex;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.shearY = bone.data.shearY;\n          return;\n        case MixBlend.first:\n          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n      }\n      return;\n    }\n\n    const y = this.getCurveValue(time);\n    switch (blend) {\n      case MixBlend.setup:\n        bone.shearY = bone.data.shearY + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n        break;\n      case MixBlend.add:\n        bone.shearY += y * alpha;\n    }\n  }\n}\n\n/** Changes a slot's {@link Slot#color}. */\nexport class RGBATimeline extends CurveTimeline implements SlotTimeline {\n  slotIndex = 0;\n\n  constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n    super(frameCount, bezierCount, [Property.rgb + '|' + slotIndex, Property.alpha + '|' + slotIndex]);\n    this.slotIndex = slotIndex;\n  }\n\n  getFrameEntries() {\n    return 5 /*ENTRIES*/;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n\n    const frames = this.frames;\n    const color = slot.color;\n    if (time < frames[0]) {\n      const setup = slot.data.color;\n      switch (blend) {\n        case MixBlend.setup:\n          color.setFromColor(setup);\n          return;\n        case MixBlend.first:\n          color.add(\n            (setup.r - color.r) * alpha,\n            (setup.g - color.g) * alpha,\n            (setup.b - color.b) * alpha,\n            (setup.a - color.a) * alpha,\n          );\n      }\n      return;\n    }\n\n    let r = 0,\n      g = 0,\n      b = 0,\n      a = 0;\n    const i = Timeline.search(frames, time, 5 /*ENTRIES*/);\n    const curveType = this.curves[i / 5 /*ENTRIES*/];\n    switch (curveType) {\n      case 0 /*LINEAR*/:\n        const before = frames[i];\n        r = frames[i + 1 /*R*/];\n        g = frames[i + 2 /*G*/];\n        b = frames[i + 3 /*B*/];\n        a = frames[i + 4 /*A*/];\n        const t = (time - before) / (frames[i + 5 /*ENTRIES*/] - before);\n        r += (frames[i + 5 /*ENTRIES*/ + 1 /*R*/] - r) * t;\n        g += (frames[i + 5 /*ENTRIES*/ + 2 /*G*/] - g) * t;\n        b += (frames[i + 5 /*ENTRIES*/ + 3 /*B*/] - b) * t;\n        a += (frames[i + 5 /*ENTRIES*/ + 4 /*A*/] - a) * t;\n        break;\n      case 1 /*STEPPED*/:\n        r = frames[i + 1 /*R*/];\n        g = frames[i + 2 /*G*/];\n        b = frames[i + 3 /*B*/];\n        a = frames[i + 4 /*A*/];\n        break;\n      default:\n        r = this.getBezierValue(time, i, 1 /*R*/, curveType - 2 /*BEZIER*/);\n        g = this.getBezierValue(time, i, 2 /*G*/, curveType + 18 /*BEZIER_SIZE*/ - 2 /*BEZIER*/);\n        b = this.getBezierValue(time, i, 3 /*B*/, curveType + 18 /*BEZIER_SIZE*/ * 2 - 2 /*BEZIER*/);\n        a = this.getBezierValue(time, i, 4 /*A*/, curveType + 18 /*BEZIER_SIZE*/ * 3 - 2 /*BEZIER*/);\n    }\n    if (alpha == 1) color.set(r, g, b, a);\n    else {\n      if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\n      color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n    }\n  }\n\n  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n  setFrame(frame: number, time: number, r: number, g: number, b: number, a: number) {\n    frame *= 5 /*ENTRIES*/;\n    this.frames[frame] = time;\n    this.frames[frame + 1 /*R*/] = r;\n    this.frames[frame + 2 /*G*/] = g;\n    this.frames[frame + 3 /*B*/] = b;\n    this.frames[frame + 4 /*A*/] = a;\n  }\n}\n\n/** Changes a slot's {@link Slot#color}. */\nexport class RGBTimeline extends CurveTimeline implements SlotTimeline {\n  slotIndex = 0;\n\n  constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n    super(frameCount, bezierCount, [Property.rgb + '|' + slotIndex]);\n    this.slotIndex = slotIndex;\n  }\n\n  getFrameEntries() {\n    return 4 /*ENTRIES*/;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n\n    const frames = this.frames;\n    const color = slot.color;\n    if (time < frames[0]) {\n      const setup = slot.data.color;\n      switch (blend) {\n        case MixBlend.setup:\n          color.r = setup.r;\n          color.g = setup.g;\n          color.b = setup.b;\n          return;\n        case MixBlend.first:\n          color.r += (setup.r - color.r) * alpha;\n          color.g += (setup.g - color.g) * alpha;\n          color.b += (setup.b - color.b) * alpha;\n      }\n      return;\n    }\n\n    let r = 0,\n      g = 0,\n      b = 0;\n    const i = Timeline.search(frames, time, 4 /*ENTRIES*/);\n    const curveType = this.curves[i >> 2];\n    switch (curveType) {\n      case 0 /*LINEAR*/:\n        const before = frames[i];\n        r = frames[i + 1 /*R*/];\n        g = frames[i + 2 /*G*/];\n        b = frames[i + 3 /*B*/];\n        const t = (time - before) / (frames[i + 4 /*ENTRIES*/] - before);\n        r += (frames[i + 4 /*ENTRIES*/ + 1 /*R*/] - r) * t;\n        g += (frames[i + 4 /*ENTRIES*/ + 2 /*G*/] - g) * t;\n        b += (frames[i + 4 /*ENTRIES*/ + 3 /*B*/] - b) * t;\n        break;\n      case 1 /*STEPPED*/:\n        r = frames[i + 1 /*R*/];\n        g = frames[i + 2 /*G*/];\n        b = frames[i + 3 /*B*/];\n        break;\n      default:\n        r = this.getBezierValue(time, i, 1 /*R*/, curveType - 2 /*BEZIER*/);\n        g = this.getBezierValue(time, i, 2 /*G*/, curveType + 18 /*BEZIER_SIZE*/ - 2 /*BEZIER*/);\n        b = this.getBezierValue(time, i, 3 /*B*/, curveType + 18 /*BEZIER_SIZE*/ * 2 - 2 /*BEZIER*/);\n    }\n    if (alpha == 1) {\n      color.r = r;\n      color.g = g;\n      color.b = b;\n    } else {\n      if (blend == MixBlend.setup) {\n        const setup = slot.data.color;\n        color.r = setup.r;\n        color.g = setup.g;\n        color.b = setup.b;\n      }\n      color.r += (r - color.r) * alpha;\n      color.g += (g - color.g) * alpha;\n      color.b += (b - color.b) * alpha;\n    }\n  }\n\n  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n  setFrame(frame: number, time: number, r: number, g: number, b: number) {\n    frame <<= 2;\n    this.frames[frame] = time;\n    this.frames[frame + 1 /*R*/] = r;\n    this.frames[frame + 2 /*G*/] = g;\n    this.frames[frame + 3 /*B*/] = b;\n  }\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}. */\nexport class AlphaTimeline extends CurveTimeline1 implements SlotTimeline {\n  slotIndex = 0;\n\n  constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n    super(frameCount, bezierCount, Property.alpha + '|' + slotIndex);\n    this.slotIndex = slotIndex;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n\n    const color = slot.color;\n    if (time < this.frames[0]) {\n      // Time is before first frame.\n      const setup = slot.data.color;\n      switch (blend) {\n        case MixBlend.setup:\n          color.a = setup.a;\n          return;\n        case MixBlend.first:\n          color.a += (setup.a - color.a) * alpha;\n      }\n      return;\n    }\n\n    const a = this.getCurveValue(time);\n    if (alpha == 1) color.a = a;\n    else {\n      if (blend == MixBlend.setup) color.a = slot.data.color.a;\n      color.a += (a - color.a) * alpha;\n    }\n  }\n}\n\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting. */\nexport class RGBA2Timeline extends CurveTimeline implements SlotTimeline {\n  slotIndex = 0;\n\n  constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n    super(frameCount, bezierCount, [\n      Property.rgb + '|' + slotIndex,\n      Property.alpha + '|' + slotIndex,\n      Property.rgb2 + '|' + slotIndex,\n    ]);\n    this.slotIndex = slotIndex;\n  }\n\n  getFrameEntries() {\n    return 8 /*ENTRIES*/;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n\n    const frames = this.frames;\n    const light = slot.color,\n      dark = slot.darkColor!;\n    if (time < frames[0]) {\n      const setupLight = slot.data.color,\n        setupDark = slot.data.darkColor!;\n      switch (blend) {\n        case MixBlend.setup:\n          light.setFromColor(setupLight);\n          dark.r = setupDark.r;\n          dark.g = setupDark.g;\n          dark.b = setupDark.b;\n          return;\n        case MixBlend.first:\n          light.add(\n            (setupLight.r - light.r) * alpha,\n            (setupLight.g - light.g) * alpha,\n            (setupLight.b - light.b) * alpha,\n            (setupLight.a - light.a) * alpha,\n          );\n          dark.r += (setupDark.r - dark.r) * alpha;\n          dark.g += (setupDark.g - dark.g) * alpha;\n          dark.b += (setupDark.b - dark.b) * alpha;\n      }\n      return;\n    }\n\n    let r = 0,\n      g = 0,\n      b = 0,\n      a = 0,\n      r2 = 0,\n      g2 = 0,\n      b2 = 0;\n    const i = Timeline.search(frames, time, 8 /*ENTRIES*/);\n    const curveType = this.curves[i >> 3];\n    switch (curveType) {\n      case 0 /*LINEAR*/:\n        const before = frames[i];\n        r = frames[i + 1 /*R*/];\n        g = frames[i + 2 /*G*/];\n        b = frames[i + 3 /*B*/];\n        a = frames[i + 4 /*A*/];\n        r2 = frames[i + 5 /*R2*/];\n        g2 = frames[i + 6 /*G2*/];\n        b2 = frames[i + 7 /*B2*/];\n        const t = (time - before) / (frames[i + 8 /*ENTRIES*/] - before);\n        r += (frames[i + 8 /*ENTRIES*/ + 1 /*R*/] - r) * t;\n        g += (frames[i + 8 /*ENTRIES*/ + 2 /*G*/] - g) * t;\n        b += (frames[i + 8 /*ENTRIES*/ + 3 /*B*/] - b) * t;\n        a += (frames[i + 8 /*ENTRIES*/ + 4 /*A*/] - a) * t;\n        r2 += (frames[i + 8 /*ENTRIES*/ + 5 /*R2*/] - r2) * t;\n        g2 += (frames[i + 8 /*ENTRIES*/ + 6 /*G2*/] - g2) * t;\n        b2 += (frames[i + 8 /*ENTRIES*/ + 7 /*B2*/] - b2) * t;\n        break;\n      case 1 /*STEPPED*/:\n        r = frames[i + 1 /*R*/];\n        g = frames[i + 2 /*G*/];\n        b = frames[i + 3 /*B*/];\n        a = frames[i + 4 /*A*/];\n        r2 = frames[i + 5 /*R2*/];\n        g2 = frames[i + 6 /*G2*/];\n        b2 = frames[i + 7 /*B2*/];\n        break;\n      default:\n        r = this.getBezierValue(time, i, 1 /*R*/, curveType - 2 /*BEZIER*/);\n        g = this.getBezierValue(time, i, 2 /*G*/, curveType + 18 /*BEZIER_SIZE*/ - 2 /*BEZIER*/);\n        b = this.getBezierValue(time, i, 3 /*B*/, curveType + 18 /*BEZIER_SIZE*/ * 2 - 2 /*BEZIER*/);\n        a = this.getBezierValue(time, i, 4 /*A*/, curveType + 18 /*BEZIER_SIZE*/ * 3 - 2 /*BEZIER*/);\n        r2 = this.getBezierValue(time, i, 5 /*R2*/, curveType + 18 /*BEZIER_SIZE*/ * 4 - 2 /*BEZIER*/);\n        g2 = this.getBezierValue(time, i, 6 /*G2*/, curveType + 18 /*BEZIER_SIZE*/ * 5 - 2 /*BEZIER*/);\n        b2 = this.getBezierValue(time, i, 7 /*B2*/, curveType + 18 /*BEZIER_SIZE*/ * 6 - 2 /*BEZIER*/);\n    }\n\n    if (alpha == 1) {\n      light.set(r, g, b, a);\n      dark.r = r2;\n      dark.g = g2;\n      dark.b = b2;\n    } else {\n      if (blend == MixBlend.setup) {\n        light.setFromColor(slot.data.color);\n        const setupDark = slot.data.darkColor!;\n        dark.r = setupDark.r;\n        dark.g = setupDark.g;\n        dark.b = setupDark.b;\n      }\n      light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n      dark.r += (r2 - dark.r) * alpha;\n      dark.g += (g2 - dark.g) * alpha;\n      dark.b += (b2 - dark.b) * alpha;\n    }\n  }\n\n  /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n  setFrame(\n    frame: number,\n    time: number,\n    r: number,\n    g: number,\n    b: number,\n    a: number,\n    r2: number,\n    g2: number,\n    b2: number,\n  ) {\n    frame <<= 3;\n    this.frames[frame] = time;\n    this.frames[frame + 1 /*R*/] = r;\n    this.frames[frame + 2 /*G*/] = g;\n    this.frames[frame + 3 /*B*/] = b;\n    this.frames[frame + 4 /*A*/] = a;\n    this.frames[frame + 5 /*R2*/] = r2;\n    this.frames[frame + 6 /*G2*/] = g2;\n    this.frames[frame + 7 /*B2*/] = b2;\n  }\n}\n\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting. */\nexport class RGB2Timeline extends CurveTimeline implements SlotTimeline {\n  slotIndex = 0;\n\n  constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n    super(frameCount, bezierCount, [Property.rgb + '|' + slotIndex, Property.rgb2 + '|' + slotIndex]);\n    this.slotIndex = slotIndex;\n  }\n\n  getFrameEntries() {\n    return 7 /*ENTRIES*/;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n\n    const frames = this.frames;\n    const light = slot.color,\n      dark = slot.darkColor!;\n    if (time < frames[0]) {\n      const setupLight = slot.data.color,\n        setupDark = slot.data.darkColor!;\n      switch (blend) {\n        case MixBlend.setup:\n          light.r = setupLight.r;\n          light.g = setupLight.g;\n          light.b = setupLight.b;\n          dark.r = setupDark.r;\n          dark.g = setupDark.g;\n          dark.b = setupDark.b;\n          return;\n        case MixBlend.first:\n          light.r += (setupLight.r - light.r) * alpha;\n          light.g += (setupLight.g - light.g) * alpha;\n          light.b += (setupLight.b - light.b) * alpha;\n          dark.r += (setupDark.r - dark.r) * alpha;\n          dark.g += (setupDark.g - dark.g) * alpha;\n          dark.b += (setupDark.b - dark.b) * alpha;\n      }\n      return;\n    }\n\n    let r = 0,\n      g = 0,\n      b = 0,\n      a = 0,\n      r2 = 0,\n      g2 = 0,\n      b2 = 0;\n    const i = Timeline.search(frames, time, 7 /*ENTRIES*/);\n    const curveType = this.curves[i / 7 /*ENTRIES*/];\n    switch (curveType) {\n      case 0 /*LINEAR*/:\n        const before = frames[i];\n        r = frames[i + 1 /*R*/];\n        g = frames[i + 2 /*G*/];\n        b = frames[i + 3 /*B*/];\n        r2 = frames[i + 4 /*R2*/];\n        g2 = frames[i + 5 /*G2*/];\n        b2 = frames[i + 6 /*B2*/];\n        const t = (time - before) / (frames[i + 7 /*ENTRIES*/] - before);\n        r += (frames[i + 7 /*ENTRIES*/ + 1 /*R*/] - r) * t;\n        g += (frames[i + 7 /*ENTRIES*/ + 2 /*G*/] - g) * t;\n        b += (frames[i + 7 /*ENTRIES*/ + 3 /*B*/] - b) * t;\n        r2 += (frames[i + 7 /*ENTRIES*/ + 4 /*R2*/] - r2) * t;\n        g2 += (frames[i + 7 /*ENTRIES*/ + 5 /*G2*/] - g2) * t;\n        b2 += (frames[i + 7 /*ENTRIES*/ + 6 /*B2*/] - b2) * t;\n        break;\n      case 1 /*STEPPED*/:\n        r = frames[i + 1 /*R*/];\n        g = frames[i + 2 /*G*/];\n        b = frames[i + 3 /*B*/];\n        r2 = frames[i + 4 /*R2*/];\n        g2 = frames[i + 5 /*G2*/];\n        b2 = frames[i + 6 /*B2*/];\n        break;\n      default:\n        r = this.getBezierValue(time, i, 1 /*R*/, curveType - 2 /*BEZIER*/);\n        g = this.getBezierValue(time, i, 2 /*G*/, curveType + 18 /*BEZIER_SIZE*/ - 2 /*BEZIER*/);\n        b = this.getBezierValue(time, i, 3 /*B*/, curveType + 18 /*BEZIER_SIZE*/ * 2 - 2 /*BEZIER*/);\n        r2 = this.getBezierValue(time, i, 4 /*R2*/, curveType + 18 /*BEZIER_SIZE*/ * 3 - 2 /*BEZIER*/);\n        g2 = this.getBezierValue(time, i, 5 /*G2*/, curveType + 18 /*BEZIER_SIZE*/ * 4 - 2 /*BEZIER*/);\n        b2 = this.getBezierValue(time, i, 6 /*B2*/, curveType + 18 /*BEZIER_SIZE*/ * 5 - 2 /*BEZIER*/);\n    }\n\n    if (alpha == 1) {\n      light.r = r;\n      light.g = g;\n      light.b = b;\n      dark.r = r2;\n      dark.g = g2;\n      dark.b = b2;\n    } else {\n      if (blend == MixBlend.setup) {\n        const setupLight = slot.data.color,\n          setupDark = slot.data.darkColor!;\n        light.r = setupLight.r;\n        light.g = setupLight.g;\n        light.b = setupLight.b;\n        dark.r = setupDark.r;\n        dark.g = setupDark.g;\n        dark.b = setupDark.b;\n      }\n      light.r += (r - light.r) * alpha;\n      light.g += (g - light.g) * alpha;\n      light.b += (b - light.b) * alpha;\n      dark.r += (r2 - dark.r) * alpha;\n      dark.g += (g2 - dark.g) * alpha;\n      dark.b += (b2 - dark.b) * alpha;\n    }\n  }\n\n  /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n  setFrame(frame: number, time: number, r: number, g: number, b: number, r2: number, g2: number, b2: number) {\n    frame *= 7 /*ENTRIES*/;\n    this.frames[frame] = time;\n    this.frames[frame + 1 /*R*/] = r;\n    this.frames[frame + 2 /*G*/] = g;\n    this.frames[frame + 3 /*B*/] = b;\n    this.frames[frame + 4 /*R2*/] = r2;\n    this.frames[frame + 5 /*G2*/] = g2;\n    this.frames[frame + 6 /*B2*/] = b2;\n  }\n}\n\n/** Changes a slot's {@link Slot#attachment}. */\nexport class AttachmentTimeline extends Timeline implements SlotTimeline {\n  slotIndex = 0;\n\n  /** The attachment name for each key frame. May contain null values to clear the attachment. */\n  attachmentNames: Array<string | null>;\n\n  constructor(frameCount: number, slotIndex: number) {\n    super(frameCount, [Property.attachment + '|' + slotIndex]);\n    this.slotIndex = slotIndex;\n    this.attachmentNames = new Array<string>(frameCount);\n  }\n\n  getFrameCount() {\n    return this.frames.length;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n\n    if (direction == MixDirection.mixOut) {\n      if (blend == MixBlend.setup) this.setAttachment(skeleton, slot, slot.data.attachmentName);\n      return;\n    }\n\n    if (time < this.frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first)\n        this.setAttachment(skeleton, slot, slot.data.attachmentName);\n      return;\n    }\n\n    this.setAttachment(skeleton, slot, this.attachmentNames[Timeline.search1(this.frames, time)]);\n  }\n\n  /** Sets the time in seconds and the attachment name for the specified key frame. */\n  setFrame(frame: number, time: number, attachmentName: string | null) {\n    this.frames[frame] = time;\n    this.attachmentNames[frame] = attachmentName;\n  }\n\n  setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string | null) {\n    slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n  }\n}\n\n/** Changes a slot's {@link Slot#deform} to deform a {@link VertexAttachment}. */\nexport class DeformTimeline extends CurveTimeline implements SlotTimeline {\n  slotIndex = 0;\n\n  /** The attachment that will be deformed. */\n  attachment: VertexAttachment;\n\n  /** The vertices for each key frame. */\n  vertices: Array<NumberArrayLike>;\n\n  constructor(frameCount: number, bezierCount: number, slotIndex: number, attachment: VertexAttachment) {\n    super(frameCount, bezierCount, [Property.deform + '|' + slotIndex + '|' + attachment.id]);\n    this.slotIndex = slotIndex;\n    this.attachment = attachment;\n    this.vertices = new Array<NumberArrayLike>(frameCount);\n  }\n\n  getFrameCount() {\n    return this.frames.length;\n  }\n\n  /** @param value1 Ignored (0 is used for a deform timeline).\n   * @param value2 Ignored (1 is used for a deform timeline). */\n  setBezier(\n    bezier: number,\n    frame: number,\n    value: number,\n    time1: number,\n    value1: number,\n    cx1: number,\n    cy1: number,\n    cx2: number,\n    cy2: number,\n    time2: number,\n    value2: number,\n  ) {\n    const curves = this.curves;\n    let i = this.getFrameCount() + bezier * 18; /*BEZIER_SIZE*/\n    if (value == 0) curves[frame] = 2 /*BEZIER*/ + i;\n    const tmpx = (time1 - cx1 * 2 + cx2) * 0.03,\n      tmpy = cy2 * 0.03 - cy1 * 0.06;\n    const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006,\n      dddy = (cy1 - cy2 + 0.33333333) * 0.018;\n    let ddx = tmpx * 2 + dddx,\n      ddy = tmpy * 2 + dddy;\n    let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667,\n      dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;\n    let x = time1 + dx,\n      y = dy;\n    for (let n = i + 18 /*BEZIER_SIZE*/; i < n; i += 2) {\n      curves[i] = x;\n      curves[i + 1] = y;\n      dx += ddx;\n      dy += ddy;\n      ddx += dddx;\n      ddy += dddy;\n      x += dx;\n      y += dy;\n    }\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    firedEvents: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const slot: Slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n    const slotAttachment: Attachment | null = slot.getAttachment();\n    if (!slotAttachment) return;\n    if (\n      !(slotAttachment instanceof VertexAttachment) ||\n      (<VertexAttachment>slotAttachment).timelineAttachment != this.attachment\n    )\n      return;\n\n    const deform: Array<number> = slot.deform;\n    if (deform.length == 0) blend = MixBlend.setup;\n\n    const vertices = this.vertices;\n    const vertexCount = vertices[0].length;\n\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          deform.length = 0;\n          return;\n        case MixBlend.first:\n          if (alpha == 1) {\n            deform.length = 0;\n            return;\n          }\n          deform.length = vertexCount;\n          const vertexAttachment = <VertexAttachment>slotAttachment;\n          if (!vertexAttachment.bones) {\n            // Unweighted vertex positions.\n            const setupVertices = vertexAttachment.vertices;\n            for (var i = 0; i < vertexCount; i++) deform[i] += (setupVertices[i] - deform[i]) * alpha;\n          } else {\n            // Weighted deform offsets.\n            alpha = 1 - alpha;\n            for (var i = 0; i < vertexCount; i++) deform[i] *= alpha;\n          }\n      }\n      return;\n    }\n\n    deform.length = vertexCount;\n    if (time >= frames[frames.length - 1]) {\n      // Time is after last frame.\n      const lastVertices = vertices[frames.length - 1];\n      if (alpha == 1) {\n        if (blend == MixBlend.add) {\n          const vertexAttachment = slotAttachment as VertexAttachment;\n          if (!vertexAttachment.bones) {\n            // Unweighted vertex positions, with alpha.\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] - setupVertices[i];\n          } else {\n            // Weighted deform offsets, with alpha.\n            for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i];\n          }\n        } else Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\n      } else {\n        switch (blend) {\n          case MixBlend.setup: {\n            const vertexAttachment = slotAttachment as VertexAttachment;\n            if (!vertexAttachment.bones) {\n              // Unweighted vertex positions, with alpha.\n              const setupVertices = vertexAttachment.vertices;\n              for (let i = 0; i < vertexCount; i++) {\n                const setup = setupVertices[i];\n                deform[i] = setup + (lastVertices[i] - setup) * alpha;\n              }\n            } else {\n              // Weighted deform offsets, with alpha.\n              for (let i = 0; i < vertexCount; i++) deform[i] = lastVertices[i] * alpha;\n            }\n            break;\n          }\n          case MixBlend.first:\n          case MixBlend.replace:\n            for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - deform[i]) * alpha;\n            break;\n          case MixBlend.add:\n            const vertexAttachment = slotAttachment as VertexAttachment;\n            if (!vertexAttachment.bones) {\n              // Unweighted vertex positions, with alpha.\n              const setupVertices = vertexAttachment.vertices;\n              for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\n            } else {\n              // Weighted deform offsets, with alpha.\n              for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] * alpha;\n            }\n        }\n      }\n      return;\n    }\n\n    // Interpolate between the previous frame and the current frame.\n    const frame = Timeline.search1(frames, time);\n    const percent = this.getCurvePercent(time, frame);\n    const prevVertices = vertices[frame];\n    const nextVertices = vertices[frame + 1];\n\n    if (alpha == 1) {\n      if (blend == MixBlend.add) {\n        const vertexAttachment = slotAttachment as VertexAttachment;\n        if (!vertexAttachment.bones) {\n          // Unweighted vertex positions, with alpha.\n          const setupVertices = vertexAttachment.vertices;\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\n          }\n        } else {\n          // Weighted deform offsets, with alpha.\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            deform[i] += prev + (nextVertices[i] - prev) * percent;\n          }\n        }\n      } else {\n        for (let i = 0; i < vertexCount; i++) {\n          const prev = prevVertices[i];\n          deform[i] = prev + (nextVertices[i] - prev) * percent;\n        }\n      }\n    } else {\n      switch (blend) {\n        case MixBlend.setup: {\n          const vertexAttachment = slotAttachment as VertexAttachment;\n          if (!vertexAttachment.bones) {\n            // Unweighted vertex positions, with alpha.\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i],\n                setup = setupVertices[i];\n              deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n            }\n          } else {\n            // Weighted deform offsets, with alpha.\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n            }\n          }\n          break;\n        }\n        case MixBlend.first:\n        case MixBlend.replace:\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\n          }\n          break;\n        case MixBlend.add:\n          const vertexAttachment = slotAttachment as VertexAttachment;\n          if (!vertexAttachment.bones) {\n            // Unweighted vertex positions, with alpha.\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\n            }\n          } else {\n            // Weighted deform offsets, with alpha.\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\n            }\n          }\n      }\n    }\n  }\n\n  /** Sets the time in seconds and the vertices for the specified key frame.\n   * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\n  setFrame(frame: number, time: number, vertices: NumberArrayLike) {\n    this.frames[frame] = time;\n    this.vertices[frame] = vertices;\n  }\n\n  getCurvePercent(time: number, frame: number) {\n    const curves = this.curves;\n    let i = curves[frame];\n    switch (i) {\n      case 0 /*LINEAR*/:\n        const x = this.frames[frame];\n        return (time - x) / (this.frames[frame + this.getFrameEntries()] - x);\n      case 1 /*STEPPED*/:\n        return 0;\n    }\n    i -= 2 /*BEZIER*/;\n    if (curves[i] > time) {\n      const x = this.frames[frame];\n      return (curves[i + 1] * (time - x)) / (curves[i] - x);\n    }\n    const n = i + 18; /*BEZIER_SIZE*/\n    for (i += 2; i < n; i += 2) {\n      if (curves[i] >= time) {\n        const x = curves[i - 2],\n          y = curves[i - 1];\n        return y + ((time - x) / (curves[i] - x)) * (curves[i + 1] - y);\n      }\n    }\n    const x = curves[n - 2],\n      y = curves[n - 1];\n    return y + ((1 - y) * (time - x)) / (this.frames[frame + this.getFrameEntries()] - x);\n  }\n}\n\n/** Fires an {@link Event} when specific animation times are reached. */\nexport class EventTimeline extends Timeline {\n  static propertyIds = ['' + Property.event];\n\n  /** The event for each key frame. */\n  events: Array<Event>;\n\n  constructor(frameCount: number) {\n    super(frameCount, EventTimeline.propertyIds);\n\n    this.events = new Array<Event>(frameCount);\n  }\n\n  getFrameCount() {\n    return this.frames.length;\n  }\n\n  /** Fires events for frames > `lastTime` and <= `time`. */\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    firedEvents: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    if (!firedEvents) return;\n\n    const frames = this.frames;\n    const frameCount = this.frames.length;\n\n    if (lastTime > time) {\n      // Fire events after last time for looped animations.\n      this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n      lastTime = -1;\n    } else if (lastTime >= frames[frameCount - 1])\n      // Last time is after last frame.\n      return;\n    if (time < frames[0]) return; // Time is before first frame.\n\n    let i = 0;\n    if (lastTime < frames[0]) i = 0;\n    else {\n      i = Timeline.search1(frames, lastTime) + 1;\n      const frameTime = frames[i];\n      while (i > 0) {\n        // Fire multiple events with the same frame.\n        if (frames[i - 1] != frameTime) break;\n        i--;\n      }\n    }\n    for (; i < frameCount && time >= frames[i]; i++) firedEvents.push(this.events[i]);\n  }\n\n  /** Sets the time in seconds and the event for the specified key frame. */\n  setFrame(frame: number, event: Event) {\n    this.frames[frame] = event.time;\n    this.events[frame] = event;\n  }\n}\n\n/** Changes a skeleton's {@link Skeleton#drawOrder}. */\nexport class DrawOrderTimeline extends Timeline {\n  static propertyIds = ['' + Property.drawOrder];\n\n  /** The draw order for each key frame. See {@link #setFrame(int, float, int[])}. */\n  drawOrders: Array<Array<number> | null>;\n\n  constructor(frameCount: number) {\n    super(frameCount, DrawOrderTimeline.propertyIds);\n    this.drawOrders = new Array<Array<number> | null>(frameCount);\n  }\n\n  getFrameCount() {\n    return this.frames.length;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    firedEvents: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    if (direction == MixDirection.mixOut) {\n      if (blend == MixBlend.setup) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n      return;\n    }\n\n    if (time < this.frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first)\n        Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n      return;\n    }\n\n    const idx = Timeline.search1(this.frames, time);\n    const drawOrderToSetupIndex = this.drawOrders[idx];\n    if (!drawOrderToSetupIndex) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n    else {\n      const drawOrder: Array<Slot> = skeleton.drawOrder;\n      const slots: Array<Slot> = skeleton.slots;\n      for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n    }\n  }\n\n  /** Sets the time in seconds and the draw order for the specified key frame.\n   * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\n   *           draw order. */\n  setFrame(frame: number, time: number, drawOrder: Array<number> | null) {\n    this.frames[frame] = time;\n    this.drawOrders[frame] = drawOrder;\n  }\n}\n\n/** Changes an IK constraint's {@link IkConstraint#mix}, {@link IkConstraint#softness},\n * {@link IkConstraint#bendDirection}, {@link IkConstraint#stretch}, and {@link IkConstraint#compress}. */\nexport class IkConstraintTimeline extends CurveTimeline {\n  /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */\n  ikConstraintIndex: number = 0;\n\n  constructor(frameCount: number, bezierCount: number, ikConstraintIndex: number) {\n    super(frameCount, bezierCount, [Property.ikConstraint + '|' + ikConstraintIndex]);\n    this.ikConstraintIndex = ikConstraintIndex;\n  }\n\n  getFrameEntries() {\n    return 6 /*ENTRIES*/;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    firedEvents: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\n    if (!constraint.active) return;\n\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.mix = constraint.data.mix;\n          constraint.softness = constraint.data.softness;\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.compress = constraint.data.compress;\n          constraint.stretch = constraint.data.stretch;\n          return;\n        case MixBlend.first:\n          constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n          constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.compress = constraint.data.compress;\n          constraint.stretch = constraint.data.stretch;\n      }\n      return;\n    }\n\n    let mix = 0,\n      softness = 0;\n    const i = Timeline.search(frames, time, 6 /*ENTRIES*/);\n    const curveType = this.curves[i / 6 /*ENTRIES*/];\n    switch (curveType) {\n      case 0 /*LINEAR*/:\n        const before = frames[i];\n        mix = frames[i + 1 /*MIX*/];\n        softness = frames[i + 2 /*SOFTNESS*/];\n        const t = (time - before) / (frames[i + 6 /*ENTRIES*/] - before);\n        mix += (frames[i + 6 /*ENTRIES*/ + 1 /*MIX*/] - mix) * t;\n        softness += (frames[i + 6 /*ENTRIES*/ + 2 /*SOFTNESS*/] - softness) * t;\n        break;\n      case 1 /*STEPPED*/:\n        mix = frames[i + 1 /*MIX*/];\n        softness = frames[i + 2 /*SOFTNESS*/];\n        break;\n      default:\n        mix = this.getBezierValue(time, i, 1 /*MIX*/, curveType - 2 /*BEZIER*/);\n        softness = this.getBezierValue(time, i, 2 /*SOFTNESS*/, curveType + 18 /*BEZIER_SIZE*/ - 2 /*BEZIER*/);\n    }\n\n    if (blend == MixBlend.setup) {\n      constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;\n      constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;\n\n      if (direction == MixDirection.mixOut) {\n        constraint.bendDirection = constraint.data.bendDirection;\n        constraint.compress = constraint.data.compress;\n        constraint.stretch = constraint.data.stretch;\n      } else {\n        constraint.bendDirection = frames[i + 3 /*BEND_DIRECTION*/];\n        constraint.compress = frames[i + 4 /*COMPRESS*/] != 0;\n        constraint.stretch = frames[i + 5 /*STRETCH*/] != 0;\n      }\n    } else {\n      constraint.mix += (mix - constraint.mix) * alpha;\n      constraint.softness += (softness - constraint.softness) * alpha;\n      if (direction == MixDirection.mixIn) {\n        constraint.bendDirection = frames[i + 3 /*BEND_DIRECTION*/];\n        constraint.compress = frames[i + 4 /*COMPRESS*/] != 0;\n        constraint.stretch = frames[i + 5 /*STRETCH*/] != 0;\n      }\n    }\n  }\n\n  /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */\n  setFrame(\n    frame: number,\n    time: number,\n    mix: number,\n    softness: number,\n    bendDirection: number,\n    compress: boolean,\n    stretch: boolean,\n  ) {\n    frame *= 6 /*ENTRIES*/;\n    this.frames[frame] = time;\n    this.frames[frame + 1 /*MIX*/] = mix;\n    this.frames[frame + 2 /*SOFTNESS*/] = softness;\n    this.frames[frame + 3 /*BEND_DIRECTION*/] = bendDirection;\n    this.frames[frame + 4 /*COMPRESS*/] = compress ? 1 : 0;\n    this.frames[frame + 5 /*STRETCH*/] = stretch ? 1 : 0;\n  }\n}\n\n/** Changes a transform constraint's {@link TransformConstraint#rotateMix}, {@link TransformConstraint#translateMix},\n * {@link TransformConstraint#scaleMix}, and {@link TransformConstraint#shearMix}. */\nexport class TransformConstraintTimeline extends CurveTimeline {\n  /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\n  transformConstraintIndex: number = 0;\n\n  constructor(frameCount: number, bezierCount: number, transformConstraintIndex: number) {\n    super(frameCount, bezierCount, [Property.transformConstraint + '|' + transformConstraintIndex]);\n    this.transformConstraintIndex = transformConstraintIndex;\n  }\n\n  getFrameEntries() {\n    return 7 /*ENTRIES*/;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    firedEvents: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\n    if (!constraint.active) return;\n\n    const frames = this.frames;\n    if (time < frames[0]) {\n      const data = constraint.data;\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.mixRotate = data.mixRotate;\n          constraint.mixX = data.mixX;\n          constraint.mixY = data.mixY;\n          constraint.mixScaleX = data.mixScaleX;\n          constraint.mixScaleY = data.mixScaleY;\n          constraint.mixShearY = data.mixShearY;\n          return;\n        case MixBlend.first:\n          constraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;\n          constraint.mixX += (data.mixX - constraint.mixX) * alpha;\n          constraint.mixY += (data.mixY - constraint.mixY) * alpha;\n          constraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;\n          constraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;\n          constraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;\n      }\n      return;\n    }\n\n    let rotate, x, y, scaleX, scaleY, shearY;\n    const i = Timeline.search(frames, time, 7 /*ENTRIES*/);\n    const curveType = this.curves[i / 7 /*ENTRIES*/];\n    switch (curveType) {\n      case 0 /*LINEAR*/:\n        const before = frames[i];\n        rotate = frames[i + 1 /*ROTATE*/];\n        x = frames[i + 2 /*X*/];\n        y = frames[i + 3 /*Y*/];\n        scaleX = frames[i + 4 /*SCALEX*/];\n        scaleY = frames[i + 5 /*SCALEY*/];\n        shearY = frames[i + 6 /*SHEARY*/];\n        const t = (time - before) / (frames[i + 7 /*ENTRIES*/] - before);\n        rotate += (frames[i + 7 /*ENTRIES*/ + 1 /*ROTATE*/] - rotate) * t;\n        x += (frames[i + 7 /*ENTRIES*/ + 2 /*X*/] - x) * t;\n        y += (frames[i + 7 /*ENTRIES*/ + 3 /*Y*/] - y) * t;\n        scaleX += (frames[i + 7 /*ENTRIES*/ + 4 /*SCALEX*/] - scaleX) * t;\n        scaleY += (frames[i + 7 /*ENTRIES*/ + 5 /*SCALEY*/] - scaleY) * t;\n        shearY += (frames[i + 7 /*ENTRIES*/ + 6 /*SHEARY*/] - shearY) * t;\n        break;\n      case 1 /*STEPPED*/:\n        rotate = frames[i + 1 /*ROTATE*/];\n        x = frames[i + 2 /*X*/];\n        y = frames[i + 3 /*Y*/];\n        scaleX = frames[i + 4 /*SCALEX*/];\n        scaleY = frames[i + 5 /*SCALEY*/];\n        shearY = frames[i + 6 /*SHEARY*/];\n        break;\n      default:\n        rotate = this.getBezierValue(time, i, 1 /*ROTATE*/, curveType - 2 /*BEZIER*/);\n        x = this.getBezierValue(time, i, 2 /*X*/, curveType + 18 /*BEZIER_SIZE*/ - 2 /*BEZIER*/);\n        y = this.getBezierValue(time, i, 3 /*Y*/, curveType + 18 /*BEZIER_SIZE*/ * 2 - 2 /*BEZIER*/);\n        scaleX = this.getBezierValue(time, i, 4 /*SCALEX*/, curveType + 18 /*BEZIER_SIZE*/ * 3 - 2 /*BEZIER*/);\n        scaleY = this.getBezierValue(time, i, 5 /*SCALEY*/, curveType + 18 /*BEZIER_SIZE*/ * 4 - 2 /*BEZIER*/);\n        shearY = this.getBezierValue(time, i, 6 /*SHEARY*/, curveType + 18 /*BEZIER_SIZE*/ * 5 - 2 /*BEZIER*/);\n    }\n\n    if (blend == MixBlend.setup) {\n      const data = constraint.data;\n      constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\n      constraint.mixX = data.mixX + (x - data.mixX) * alpha;\n      constraint.mixY = data.mixY + (y - data.mixY) * alpha;\n      constraint.mixScaleX = data.mixScaleX + (scaleX - data.mixScaleX) * alpha;\n      constraint.mixScaleY = data.mixScaleY + (scaleY - data.mixScaleY) * alpha;\n      constraint.mixShearY = data.mixShearY + (shearY - data.mixShearY) * alpha;\n    } else {\n      constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\n      constraint.mixX += (x - constraint.mixX) * alpha;\n      constraint.mixY += (y - constraint.mixY) * alpha;\n      constraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha;\n      constraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha;\n      constraint.mixShearY += (shearY - constraint.mixShearY) * alpha;\n    }\n  }\n\n  /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\n  setFrame(\n    frame: number,\n    time: number,\n    mixRotate: number,\n    mixX: number,\n    mixY: number,\n    mixScaleX: number,\n    mixScaleY: number,\n    mixShearY: number,\n  ) {\n    const frames = this.frames;\n    frame *= 7 /*ENTRIES*/;\n    frames[frame] = time;\n    frames[frame + 1 /*ROTATE*/] = mixRotate;\n    frames[frame + 2 /*X*/] = mixX;\n    frames[frame + 3 /*Y*/] = mixY;\n    frames[frame + 4 /*SCALEX*/] = mixScaleX;\n    frames[frame + 5 /*SCALEY*/] = mixScaleY;\n    frames[frame + 6 /*SHEARY*/] = mixShearY;\n  }\n}\n\n/** Changes a path constraint's {@link PathConstraint#position}. */\nexport class PathConstraintPositionTimeline extends CurveTimeline1 {\n  /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */\n  pathConstraintIndex: number = 0;\n\n  constructor(frameCount: number, bezierCount: number, pathConstraintIndex: number) {\n    super(frameCount, bezierCount, Property.pathConstraintPosition + '|' + pathConstraintIndex);\n    this.pathConstraintIndex = pathConstraintIndex;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    firedEvents: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active) return;\n\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.position = constraint.data.position;\n          return;\n        case MixBlend.first:\n          constraint.position += (constraint.data.position - constraint.position) * alpha;\n      }\n      return;\n    }\n\n    const position = this.getCurveValue(time);\n\n    if (blend == MixBlend.setup)\n      constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\n    else constraint.position += (position - constraint.position) * alpha;\n  }\n}\n\n/** Changes a path constraint's {@link PathConstraint#spacing}. */\nexport class PathConstraintSpacingTimeline extends CurveTimeline1 {\n  /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\n  pathConstraintIndex = 0;\n\n  constructor(frameCount: number, bezierCount: number, pathConstraintIndex: number) {\n    super(frameCount, bezierCount, Property.pathConstraintSpacing + '|' + pathConstraintIndex);\n    this.pathConstraintIndex = pathConstraintIndex;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    firedEvents: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active) return;\n\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.spacing = constraint.data.spacing;\n          return;\n        case MixBlend.first:\n          constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n      }\n      return;\n    }\n\n    const spacing = this.getCurveValue(time);\n\n    if (blend == MixBlend.setup)\n      constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\n    else constraint.spacing += (spacing - constraint.spacing) * alpha;\n  }\n}\n\n/** Changes a transform constraint's {@link PathConstraint#getMixRotate()}, {@link PathConstraint#getMixX()}, and\n * {@link PathConstraint#getMixY()}. */\nexport class PathConstraintMixTimeline extends CurveTimeline {\n  /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\n  pathConstraintIndex = 0;\n\n  constructor(frameCount: number, bezierCount: number, pathConstraintIndex: number) {\n    super(frameCount, bezierCount, [Property.pathConstraintMix + '|' + pathConstraintIndex]);\n    this.pathConstraintIndex = pathConstraintIndex;\n  }\n\n  getFrameEntries() {\n    return 4 /*ENTRIES*/;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    firedEvents: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active) return;\n\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.mixRotate = constraint.data.mixRotate;\n          constraint.mixX = constraint.data.mixX;\n          constraint.mixY = constraint.data.mixY;\n          return;\n        case MixBlend.first:\n          constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;\n          constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;\n          constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;\n      }\n      return;\n    }\n\n    let rotate, x, y;\n    const i = Timeline.search(frames, time, 4 /*ENTRIES*/);\n    const curveType = this.curves[i >> 2];\n    switch (curveType) {\n      case 0 /*LINEAR*/:\n        const before = frames[i];\n        rotate = frames[i + 1 /*ROTATE*/];\n        x = frames[i + 2 /*X*/];\n        y = frames[i + 3 /*Y*/];\n        const t = (time - before) / (frames[i + 4 /*ENTRIES*/] - before);\n        rotate += (frames[i + 4 /*ENTRIES*/ + 1 /*ROTATE*/] - rotate) * t;\n        x += (frames[i + 4 /*ENTRIES*/ + 2 /*X*/] - x) * t;\n        y += (frames[i + 4 /*ENTRIES*/ + 3 /*Y*/] - y) * t;\n        break;\n      case 1 /*STEPPED*/:\n        rotate = frames[i + 1 /*ROTATE*/];\n        x = frames[i + 2 /*X*/];\n        y = frames[i + 3 /*Y*/];\n        break;\n      default:\n        rotate = this.getBezierValue(time, i, 1 /*ROTATE*/, curveType - 2 /*BEZIER*/);\n        x = this.getBezierValue(time, i, 2 /*X*/, curveType + 18 /*BEZIER_SIZE*/ - 2 /*BEZIER*/);\n        y = this.getBezierValue(time, i, 3 /*Y*/, curveType + 18 /*BEZIER_SIZE*/ * 2 - 2 /*BEZIER*/);\n    }\n\n    if (blend == MixBlend.setup) {\n      const data = constraint.data;\n      constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\n      constraint.mixX = data.mixX + (x - data.mixX) * alpha;\n      constraint.mixY = data.mixY + (y - data.mixY) * alpha;\n    } else {\n      constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\n      constraint.mixX += (x - constraint.mixX) * alpha;\n      constraint.mixY += (y - constraint.mixY) * alpha;\n    }\n  }\n\n  setFrame(frame: number, time: number, mixRotate: number, mixX: number, mixY: number) {\n    const frames = this.frames;\n    frame <<= 2;\n    frames[frame] = time;\n    frames[frame + 1 /*ROTATE*/] = mixRotate;\n    frames[frame + 2 /*X*/] = mixX;\n    frames[frame + 3 /*Y*/] = mixY;\n  }\n}\n\n/** Changes a slot's {@link Slot#getSequenceIndex()} for an attachment's {@link Sequence}. */\nexport class SequenceTimeline extends Timeline implements SlotTimeline {\n  slotIndex: number;\n  static ENTRIES = 3;\n  static MODE = 1;\n  static DELAY = 2;\n  attachment: HasTextureRegion;\n\n  constructor(frameCount: number, slotIndex: number, attachment: HasTextureRegion) {\n    super(frameCount, [Property.sequence + '|' + slotIndex + '|' + attachment.sequence!.id]);\n    this.slotIndex = slotIndex;\n    this.attachment = attachment;\n  }\n\n  getFrameEntries() {\n    return SequenceTimeline.ENTRIES;\n  }\n\n  apply(\n    skeleton: Skeleton,\n    lastTime: number,\n    time: number,\n    events: Array<Event>,\n    alpha: number,\n    blend: MixBlend,\n    direction: MixDirection,\n  ) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n    const slotAttachment = slot.attachment;\n    const attachment = this.attachment as unknown as Attachment;\n    if (slotAttachment != attachment) {\n      if (\n        !(slotAttachment instanceof VertexAttachment) ||\n        (slotAttachment as VertexAttachment).timelineAttachment != attachment\n      )\n        return;\n    }\n\n    const frames = this.frames;\n    if (time < frames[0]) {\n      // Time is before first frame.\n      if (blend == MixBlend.setup || blend == MixBlend.first) slot.sequenceIndex = -1;\n      return;\n    }\n\n    const i = Timeline.search(frames, time, SequenceTimeline.ENTRIES);\n    const before = frames[i];\n    const modeAndIndex = frames[i + SequenceTimeline.MODE];\n    const delay = frames[i + SequenceTimeline.DELAY];\n\n    if (!this.attachment.sequence) return;\n    let index = modeAndIndex >> 4,\n      count = this.attachment.sequence!.regions.length;\n    const mode = SequenceModeValues[modeAndIndex & 0xf];\n    if (mode != SequenceMode.hold) {\n      index += ((time - before) / delay + 0.00001) | 0;\n      switch (mode) {\n        case SequenceMode.once:\n          index = Math.min(count - 1, index);\n          break;\n        case SequenceMode.loop:\n          index %= count;\n          break;\n        case SequenceMode.pingpong: {\n          const n = (count << 1) - 2;\n          index = n == 0 ? 0 : index % n;\n          if (index >= count) index = n - index;\n          break;\n        }\n        case SequenceMode.onceReverse:\n          index = Math.max(count - 1 - index, 0);\n          break;\n        case SequenceMode.loopReverse:\n          index = count - 1 - (index % count);\n          break;\n        case SequenceMode.pingpongReverse: {\n          const n = (count << 1) - 2;\n          index = n == 0 ? 0 : (index + count - 1) % n;\n          if (index >= count) index = n - index;\n        }\n      }\n    }\n    slot.sequenceIndex = index;\n  }\n\n  getSlotIndex() {\n    return this.slotIndex;\n  }\n\n  getAttachment() {\n    return this.attachment as unknown as Attachment;\n  }\n\n  /** Sets the time, mode, index, and frame time for the specified frame.\n   * @param frame Between 0 and <code>frameCount</code>, inclusive.\n   * @param time Seconds between frames. */\n  setFrame(frame: number, time: number, mode: SequenceMode, index: number, delay: number) {\n    const frames = this.frames;\n    frame *= SequenceTimeline.ENTRIES;\n    frames[frame] = time;\n    frames[frame + SequenceTimeline.MODE] = mode | (index << 4);\n    frames[frame + SequenceTimeline.DELAY] = delay;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport {\n  Animation,\n  AttachmentTimeline,\n  DrawOrderTimeline,\n  EventTimeline,\n  MixBlend,\n  MixDirection,\n  RotateTimeline,\n  Timeline,\n} from './Animation';\nimport { AnimationStateData } from './AnimationStateData';\nimport { Event } from './Event';\nimport { Skeleton } from './Skeleton';\nimport { Slot } from './Slot';\nimport { MathUtils, Pool, StringSet, Utils } from './Utils';\n\n/** Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies\n * multiple animations on top of each other (layering).\n *\n * See [Applying Animations](http://esotericsoftware.com/spine-applying-animations/) in the Spine Runtimes Guide. */\nexport class AnimationState {\n  static _emptyAnimation = new Animation('<empty>', [], 0);\n  /** The AnimationStateData to look up mix durations. */\n  data: AnimationStateData;\n  /** The list of tracks that currently have animations, which may contain null entries. */\n  tracks = new Array<TrackEntry | null>();\n  /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\n   * or faster. Defaults to 1.\n   *\n   * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\n  timeScale = 1;\n  unkeyedState = 0;\n  events = new Array<Event>();\n  listeners = new Array<AnimationStateListener>();\n  queue = new EventQueue(this);\n  propertyIDs = new StringSet();\n  animationsChanged = false;\n  trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\n\n  private static emptyAnimation(): Animation {\n    return AnimationState._emptyAnimation;\n  }\n\n  constructor(data: AnimationStateData) {\n    this.data = data;\n  }\n\n  /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\n  update(delta: number) {\n    delta *= this.timeScale;\n    const tracks = this.tracks;\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      const current = tracks[i];\n      if (!current) continue;\n\n      current.animationLast = current.nextAnimationLast;\n      current.trackLast = current.nextTrackLast;\n\n      let currentDelta = delta * current.timeScale;\n\n      if (current.delay > 0) {\n        current.delay -= currentDelta;\n        if (current.delay > 0) continue;\n        currentDelta = -current.delay;\n        current.delay = 0;\n      }\n\n      let next = current.next;\n      if (next) {\n        // When the next entry's delay is passed, change to the next entry, preserving leftover time.\n        const nextTime = current.trackLast - next.delay;\n        if (nextTime >= 0) {\n          next.delay = 0;\n          next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n          current.trackTime += currentDelta;\n          this.setCurrent(i, next, true);\n          while (next.mixingFrom) {\n            next.mixTime += delta;\n            next = next.mixingFrom;\n          }\n          continue;\n        }\n      } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {\n        tracks[i] = null;\n        this.queue.end(current);\n        this.clearNext(current);\n        continue;\n      }\n      if (current.mixingFrom && this.updateMixingFrom(current, delta)) {\n        // End mixing from entries once all have completed.\n        let from: TrackEntry | null = current.mixingFrom;\n        current.mixingFrom = null;\n        if (from) from.mixingTo = null;\n        while (from) {\n          this.queue.end(from);\n          from = from.mixingFrom;\n        }\n      }\n\n      current.trackTime += currentDelta;\n    }\n\n    this.queue.drain();\n  }\n\n  /** Returns true when all mixing from entries are complete. */\n  updateMixingFrom(to: TrackEntry, delta: number): boolean {\n    const from = to.mixingFrom;\n    if (!from) return true;\n\n    const finished = this.updateMixingFrom(from, delta);\n\n    from.animationLast = from.nextAnimationLast;\n    from.trackLast = from.nextTrackLast;\n\n    // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\n    if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n      // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\n      if (from.totalAlpha == 0 || to.mixDuration == 0) {\n        to.mixingFrom = from.mixingFrom;\n        if (from.mixingFrom) from.mixingFrom.mixingTo = to;\n        to.interruptAlpha = from.interruptAlpha;\n        this.queue.end(from);\n      }\n      return finished;\n    }\n\n    from.trackTime += delta * from.timeScale;\n    to.mixTime += delta;\n    return false;\n  }\n\n  /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\n   * animation state can be applied to multiple skeletons to pose them identically.\n   * @returns True if any animations were applied. */\n  apply(skeleton: Skeleton): boolean {\n    if (!skeleton) throw new Error('skeleton cannot be null.');\n    if (this.animationsChanged) this._animationsChanged();\n\n    const events = this.events;\n    const tracks = this.tracks;\n    let applied = false;\n\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      const current = tracks[i];\n      if (!current || current.delay > 0) continue;\n      applied = true;\n      const blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\n\n      // Apply mixing from entries first.\n      let mix = current.alpha;\n      if (current.mixingFrom) mix *= this.applyMixingFrom(current, skeleton, blend);\n      else if (current.trackTime >= current.trackEnd && !current.next) mix = 0;\n\n      // Apply current entry.\n      let animationLast = current.animationLast,\n        animationTime = current.getAnimationTime(),\n        applyTime = animationTime;\n      let applyEvents: Event[] | null = events;\n      if (current.reverse) {\n        applyTime = current.animation!.duration - applyTime;\n        applyEvents = null;\n      }\n      const timelines = current.animation!.timelines;\n      const timelineCount = timelines.length;\n      if ((i == 0 && mix == 1) || blend == MixBlend.add) {\n        for (let ii = 0; ii < timelineCount; ii++) {\n          // Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\n          // to sometimes stop rendering when using color correction, as their RGBA values become NaN.\n          // (https://github.com/pixijs/pixi-spine/issues/302)\n          Utils.webkit602BugfixHelper(mix, blend);\n          const timeline = timelines[ii];\n          if (timeline instanceof AttachmentTimeline)\n            this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\n          else timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, blend, MixDirection.mixIn);\n        }\n      } else {\n        const timelineMode = current.timelineMode;\n\n        const shortestRotation = current.shortestRotation;\n        const firstFrame = !shortestRotation && current.timelinesRotation.length != timelineCount << 1;\n        if (firstFrame) current.timelinesRotation.length = timelineCount << 1;\n\n        for (let ii = 0; ii < timelineCount; ii++) {\n          const timeline = timelines[ii];\n          const timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : MixBlend.setup;\n          if (!shortestRotation && timeline instanceof RotateTimeline) {\n            this.applyRotateTimeline(\n              timeline,\n              skeleton,\n              applyTime,\n              mix,\n              timelineBlend,\n              current.timelinesRotation,\n              ii << 1,\n              firstFrame,\n            );\n          } else if (timeline instanceof AttachmentTimeline) {\n            this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\n          } else {\n            // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n            Utils.webkit602BugfixHelper(mix, blend);\n            timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, timelineBlend, MixDirection.mixIn);\n          }\n        }\n      }\n      this.queueEvents(current, animationTime);\n      events.length = 0;\n      current.nextAnimationLast = animationTime;\n      current.nextTrackLast = current.trackTime;\n    }\n\n    // Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so\n    // subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or\n    // the time is before the first key).\n    const setupState = this.unkeyedState + SETUP;\n    const slots = skeleton.slots;\n    for (let i = 0, n = skeleton.slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.attachmentState == setupState) {\n        const attachmentName = slot.data.attachmentName;\n        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n      }\n    }\n    this.unkeyedState += 2; // Increasing after each use avoids the need to reset attachmentState for every slot.\n\n    this.queue.drain();\n    return applied;\n  }\n\n  applyMixingFrom(to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\n    const from = to.mixingFrom!;\n    if (from.mixingFrom) this.applyMixingFrom(from, skeleton, blend);\n\n    let mix = 0;\n    if (to.mixDuration == 0) {\n      // Single frame mix to undo mixingFrom changes.\n      mix = 1;\n      if (blend == MixBlend.first) blend = MixBlend.setup;\n    } else {\n      mix = to.mixTime / to.mixDuration;\n      if (mix > 1) mix = 1;\n      if (blend != MixBlend.first) blend = from.mixBlend;\n    }\n\n    const attachments = mix < from.attachmentThreshold,\n      drawOrder = mix < from.drawOrderThreshold;\n    const timelines = from.animation!.timelines;\n    const timelineCount = timelines.length;\n    const alphaHold = from.alpha * to.interruptAlpha,\n      alphaMix = alphaHold * (1 - mix);\n    let animationLast = from.animationLast,\n      animationTime = from.getAnimationTime(),\n      applyTime = animationTime;\n    let events = null;\n    if (from.reverse) applyTime = from.animation!.duration - applyTime;\n    else if (mix < from.eventThreshold) events = this.events;\n\n    if (blend == MixBlend.add) {\n      for (let i = 0; i < timelineCount; i++)\n        timelines[i].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, MixDirection.mixOut);\n    } else {\n      const timelineMode = from.timelineMode;\n      const timelineHoldMix = from.timelineHoldMix;\n\n      const shortestRotation = from.shortestRotation;\n      const firstFrame = !shortestRotation && from.timelinesRotation.length != timelineCount << 1;\n      if (firstFrame) from.timelinesRotation.length = timelineCount << 1;\n\n      from.totalAlpha = 0;\n      for (let i = 0; i < timelineCount; i++) {\n        const timeline = timelines[i];\n        let direction = MixDirection.mixOut;\n        let timelineBlend: MixBlend;\n        let alpha = 0;\n        switch (timelineMode[i]) {\n          case SUBSEQUENT:\n            if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\n            timelineBlend = blend;\n            alpha = alphaMix;\n            break;\n          case FIRST:\n            timelineBlend = MixBlend.setup;\n            alpha = alphaMix;\n            break;\n          case HOLD_SUBSEQUENT:\n            timelineBlend = blend;\n            alpha = alphaHold;\n            break;\n          case HOLD_FIRST:\n            timelineBlend = MixBlend.setup;\n            alpha = alphaHold;\n            break;\n          default:\n            timelineBlend = MixBlend.setup;\n            const holdMix = timelineHoldMix[i];\n            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n            break;\n        }\n        from.totalAlpha += alpha;\n\n        if (!shortestRotation && timeline instanceof RotateTimeline)\n          this.applyRotateTimeline(\n            timeline,\n            skeleton,\n            applyTime,\n            alpha,\n            timelineBlend,\n            from.timelinesRotation,\n            i << 1,\n            firstFrame,\n          );\n        else if (timeline instanceof AttachmentTimeline)\n          this.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments);\n        else {\n          // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n          Utils.webkit602BugfixHelper(alpha, blend);\n          if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup)\n            direction = MixDirection.mixIn;\n          timeline.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);\n        }\n      }\n    }\n\n    if (to.mixDuration > 0) this.queueEvents(from, animationTime);\n    this.events.length = 0;\n    from.nextAnimationLast = animationTime;\n    from.nextTrackLast = from.trackTime;\n\n    return mix;\n  }\n\n  applyAttachmentTimeline(\n    timeline: AttachmentTimeline,\n    skeleton: Skeleton,\n    time: number,\n    blend: MixBlend,\n    attachments: boolean,\n  ) {\n    const slot = skeleton.slots[timeline.slotIndex];\n    if (!slot.bone.active) return;\n\n    if (time < timeline.frames[0]) {\n      // Time is before first frame.\n      if (blend == MixBlend.setup || blend == MixBlend.first)\n        this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\n    } else\n      this.setAttachment(\n        skeleton,\n        slot,\n        timeline.attachmentNames[Timeline.search1(timeline.frames, time)],\n        attachments,\n      );\n\n    // If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.\n    if (slot.attachmentState <= this.unkeyedState) slot.attachmentState = this.unkeyedState + SETUP;\n  }\n\n  setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string | null, attachments: boolean) {\n    slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n    if (attachments) slot.attachmentState = this.unkeyedState + CURRENT;\n  }\n\n  applyRotateTimeline(\n    timeline: RotateTimeline,\n    skeleton: Skeleton,\n    time: number,\n    alpha: number,\n    blend: MixBlend,\n    timelinesRotation: Array<number>,\n    i: number,\n    firstFrame: boolean,\n  ) {\n    if (firstFrame) timelinesRotation[i] = 0;\n\n    if (alpha == 1) {\n      timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\n      return;\n    }\n\n    const bone = skeleton.bones[timeline.boneIndex];\n    if (!bone.active) return;\n    const frames = timeline.frames;\n    let r1 = 0,\n      r2 = 0;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.rotation = bone.data.rotation;\n        default:\n          return;\n        case MixBlend.first:\n          r1 = bone.rotation;\n          r2 = bone.data.rotation;\n      }\n    } else {\n      r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\n      r2 = bone.data.rotation + timeline.getCurveValue(time);\n    }\n\n    // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\n    let total = 0,\n      diff = r2 - r1;\n    diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\n    if (diff == 0) {\n      total = timelinesRotation[i];\n    } else {\n      let lastTotal = 0,\n        lastDiff = 0;\n      if (firstFrame) {\n        lastTotal = 0;\n        lastDiff = diff;\n      } else {\n        lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\n        lastDiff = timelinesRotation[i + 1]; // Difference between bones.\n      }\n      let current = diff > 0,\n        dir = lastTotal >= 0;\n      // Detect cross at 0 (not 180).\n      if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n        // A cross after a 360 rotation is a loop.\n        if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\n        dir = current;\n      }\n      total = diff + lastTotal - (lastTotal % 360); // Store loops as part of lastTotal.\n      if (dir != current) total += 360 * MathUtils.signum(lastTotal);\n      timelinesRotation[i] = total;\n    }\n    timelinesRotation[i + 1] = diff;\n    bone.rotation = r1 + total * alpha;\n  }\n\n  queueEvents(entry: TrackEntry, animationTime: number) {\n    const animationStart = entry.animationStart,\n      animationEnd = entry.animationEnd;\n    const duration = animationEnd - animationStart;\n    const trackLastWrapped = entry.trackLast % duration;\n\n    // Queue events before complete.\n    const events = this.events;\n    let i = 0,\n      n = events.length;\n    for (; i < n; i++) {\n      const event = events[i];\n      if (event.time < trackLastWrapped) break;\n      if (event.time > animationEnd) continue; // Discard events outside animation start/end.\n      this.queue.event(entry, event);\n    }\n\n    // Queue complete if completed a loop iteration or the animation.\n    let complete = false;\n    if (entry.loop) complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\n    else complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n    if (complete) this.queue.complete(entry);\n\n    // Queue events after complete.\n    for (; i < n; i++) {\n      const event = events[i];\n      if (event.time < animationStart) continue; // Discard events outside animation start/end.\n      this.queue.event(entry, event);\n    }\n  }\n\n  /** Removes all animations from all tracks, leaving skeletons in their current pose.\n   *\n   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n   * rather than leaving them in their current pose. */\n  clearTracks() {\n    const oldDrainDisabled = this.queue.drainDisabled;\n    this.queue.drainDisabled = true;\n    for (let i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);\n    this.tracks.length = 0;\n    this.queue.drainDisabled = oldDrainDisabled;\n    this.queue.drain();\n  }\n\n  /** Removes all animations from the track, leaving skeletons in their current pose.\n   *\n   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n   * rather than leaving them in their current pose. */\n  clearTrack(trackIndex: number) {\n    if (trackIndex >= this.tracks.length) return;\n    const current = this.tracks[trackIndex];\n    if (!current) return;\n\n    this.queue.end(current);\n\n    this.clearNext(current);\n\n    let entry = current;\n    while (true) {\n      const from = entry.mixingFrom;\n      if (!from) break;\n      this.queue.end(from);\n      entry.mixingFrom = null;\n      entry.mixingTo = null;\n      entry = from;\n    }\n\n    this.tracks[current.trackIndex] = null;\n\n    this.queue.drain();\n  }\n\n  setCurrent(index: number, current: TrackEntry, interrupt: boolean) {\n    const from = this.expandToIndex(index);\n    this.tracks[index] = current;\n    current.previous = null;\n\n    if (from) {\n      if (interrupt) this.queue.interrupt(from);\n      current.mixingFrom = from;\n      from.mixingTo = current;\n      current.mixTime = 0;\n\n      // Store the interrupted mix percentage.\n      if (from.mixingFrom && from.mixDuration > 0)\n        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n\n      from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\n    }\n\n    this.queue.start(current);\n  }\n\n  /** Sets an animation by name.\n   *\n   * See {@link #setAnimationWith()}. */\n  setAnimation(trackIndex: number, animationName: string, loop: boolean = false) {\n    const animation = this.data.skeletonData.findAnimation(animationName);\n    if (!animation) throw new Error('Animation not found: ' + animationName);\n    return this.setAnimationWith(trackIndex, animation, loop);\n  }\n\n  /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\n   * applied to a skeleton, it is replaced (not mixed from).\n   * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n   *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\n   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n  setAnimationWith(trackIndex: number, animation: Animation, loop: boolean = false) {\n    if (!animation) throw new Error('animation cannot be null.');\n    let interrupt = true;\n    let current = this.expandToIndex(trackIndex);\n    if (current) {\n      if (current.nextTrackLast == -1) {\n        // Don't mix from an entry that was never applied.\n        this.tracks[trackIndex] = current.mixingFrom;\n        this.queue.interrupt(current);\n        this.queue.end(current);\n        this.clearNext(current);\n        current = current.mixingFrom;\n        interrupt = false;\n      } else this.clearNext(current);\n    }\n    const entry = this.trackEntry(trackIndex, animation, loop, current);\n    this.setCurrent(trackIndex, entry, interrupt);\n    this.queue.drain();\n    return entry;\n  }\n\n  /** Queues an animation by name.\n   *\n   * See {@link #addAnimationWith()}. */\n  addAnimation(trackIndex: number, animationName: string, loop: boolean = false, delay: number = 0) {\n    const animation = this.data.skeletonData.findAnimation(animationName);\n    if (!animation) throw new Error('Animation not found: ' + animationName);\n    return this.addAnimationWith(trackIndex, animation, loop, delay);\n  }\n\n  /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\n   * equivalent to calling {@link #setAnimationWith()}.\n   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n   *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\n   *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\n   *           previous entry is looping, its next loop completion is used instead of its duration.\n   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n  addAnimationWith(trackIndex: number, animation: Animation, loop: boolean = false, delay: number = 0) {\n    if (!animation) throw new Error('animation cannot be null.');\n\n    let last = this.expandToIndex(trackIndex);\n    if (last) {\n      while (last.next) last = last.next;\n    }\n\n    const entry = this.trackEntry(trackIndex, animation, loop, last);\n\n    if (!last) {\n      this.setCurrent(trackIndex, entry, true);\n      this.queue.drain();\n    } else {\n      last.next = entry;\n      entry.previous = last;\n      if (delay <= 0) delay += last.getTrackComplete() - entry.mixDuration;\n    }\n\n    entry.delay = delay;\n    return entry;\n  }\n\n  /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\n   * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\n   *\n   * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\n   * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\n   * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\n   * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\n   * 0 still mixes out over one frame.\n   *\n   * Mixing in is done by first setting an empty animation, then adding an animation using\n   * {@link #addAnimation()} and on the returned track entry, set the\n   * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\n   * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\n   * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\n  setEmptyAnimation(trackIndex: number, mixDuration: number = 0) {\n    const entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation(), false);\n    entry.mixDuration = mixDuration;\n    entry.trackEnd = mixDuration;\n    return entry;\n  }\n\n  /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\n   * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\n   * {@link #setEmptyAnimation()}.\n   *\n   * See {@link #setEmptyAnimation()}.\n   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n   *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\n   *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\n   *           loop completion is used instead of its duration.\n   * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n  addEmptyAnimation(trackIndex: number, mixDuration: number = 0, delay: number = 0) {\n    const entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation(), false, delay);\n    if (delay <= 0) entry.delay += entry.mixDuration - mixDuration;\n    entry.mixDuration = mixDuration;\n    entry.trackEnd = mixDuration;\n    return entry;\n  }\n\n  /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\n   * duration. */\n  setEmptyAnimations(mixDuration: number = 0) {\n    const oldDrainDisabled = this.queue.drainDisabled;\n    this.queue.drainDisabled = true;\n    for (let i = 0, n = this.tracks.length; i < n; i++) {\n      const current = this.tracks[i];\n      if (current) this.setEmptyAnimation(current.trackIndex, mixDuration);\n    }\n    this.queue.drainDisabled = oldDrainDisabled;\n    this.queue.drain();\n  }\n\n  expandToIndex(index: number) {\n    if (index < this.tracks.length) return this.tracks[index];\n    Utils.ensureArrayCapacity(this.tracks, index + 1, null);\n    this.tracks.length = index + 1;\n    return null;\n  }\n\n  /** @param last May be null. */\n  trackEntry(trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry | null) {\n    const entry = this.trackEntryPool.obtain();\n    entry.reset();\n    entry.trackIndex = trackIndex;\n    entry.animation = animation;\n    entry.loop = loop;\n    entry.holdPrevious = false;\n\n    entry.reverse = false;\n    entry.shortestRotation = false;\n\n    entry.eventThreshold = 0;\n    entry.attachmentThreshold = 0;\n    entry.drawOrderThreshold = 0;\n\n    entry.animationStart = 0;\n    entry.animationEnd = animation.duration;\n    entry.animationLast = -1;\n    entry.nextAnimationLast = -1;\n\n    entry.delay = 0;\n    entry.trackTime = 0;\n    entry.trackLast = -1;\n    entry.nextTrackLast = -1;\n    entry.trackEnd = Number.MAX_VALUE;\n    entry.timeScale = 1;\n\n    entry.alpha = 1;\n    entry.mixTime = 0;\n    entry.mixDuration = !last ? 0 : this.data.getMix(last.animation!, animation);\n    entry.interruptAlpha = 1;\n    entry.totalAlpha = 0;\n    entry.mixBlend = MixBlend.replace;\n    return entry;\n  }\n\n  /** Removes the {@link TrackEntry#getNext() next entry} and all entries after it for the specified entry. */\n  clearNext(entry: TrackEntry) {\n    let next = entry.next;\n    while (next) {\n      this.queue.dispose(next);\n      next = next.next;\n    }\n    entry.next = null;\n  }\n\n  _animationsChanged() {\n    this.animationsChanged = false;\n\n    this.propertyIDs.clear();\n    const tracks = this.tracks;\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      let entry = tracks[i];\n      if (!entry) continue;\n      while (entry.mixingFrom) entry = entry.mixingFrom;\n      do {\n        if (!entry.mixingTo || entry.mixBlend != MixBlend.add) this.computeHold(entry);\n        entry = entry.mixingTo;\n      } while (entry);\n    }\n  }\n\n  computeHold(entry: TrackEntry) {\n    const to = entry.mixingTo;\n    const timelines = entry.animation!.timelines;\n    const timelinesCount = entry.animation!.timelines.length;\n    const timelineMode = entry.timelineMode;\n    timelineMode.length = timelinesCount;\n    const timelineHoldMix = entry.timelineHoldMix;\n    timelineHoldMix.length = 0;\n    const propertyIDs = this.propertyIDs;\n\n    if (to && to.holdPrevious) {\n      for (let i = 0; i < timelinesCount; i++)\n        timelineMode[i] = propertyIDs.addAll(timelines[i].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;\n      return;\n    }\n\n    outer: for (let i = 0; i < timelinesCount; i++) {\n      const timeline = timelines[i];\n      const ids = timeline.getPropertyIds();\n      if (!propertyIDs.addAll(ids)) timelineMode[i] = SUBSEQUENT;\n      else if (\n        !to ||\n        timeline instanceof AttachmentTimeline ||\n        timeline instanceof DrawOrderTimeline ||\n        timeline instanceof EventTimeline ||\n        !to.animation!.hasTimeline(ids)\n      ) {\n        timelineMode[i] = FIRST;\n      } else {\n        for (let next = to.mixingTo; next; next = next!.mixingTo) {\n          if (next.animation!.hasTimeline(ids)) continue;\n          if (entry.mixDuration > 0) {\n            timelineMode[i] = HOLD_MIX;\n            timelineHoldMix[i] = next;\n            continue outer;\n          }\n          break;\n        }\n        timelineMode[i] = HOLD_FIRST;\n      }\n    }\n  }\n\n  /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\n  getCurrent(trackIndex: number) {\n    if (trackIndex >= this.tracks.length) return null;\n    return this.tracks[trackIndex];\n  }\n\n  /** Adds a listener to receive events for all track entries. */\n  addListener(listener: AnimationStateListener) {\n    if (!listener) throw new Error('listener cannot be null.');\n    this.listeners.push(listener);\n  }\n\n  /** Removes the listener added with {@link #addListener()}. */\n  removeListener(listener: AnimationStateListener) {\n    const index = this.listeners.indexOf(listener);\n    if (index >= 0) this.listeners.splice(index, 1);\n  }\n\n  /** Removes all listeners added with {@link #addListener()}. */\n  clearListeners() {\n    this.listeners.length = 0;\n  }\n\n  /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\n   * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\n   * are not wanted because new animations are being set. */\n  clearListenerNotifications() {\n    this.queue.clear();\n  }\n}\n\n/** Stores settings and other state for the playback of an animation on an {@link AnimationState} track.\n *\n * References to a track entry must not be kept after the {@link AnimationStateListener#dispose()} event occurs. */\nexport class TrackEntry {\n  /** The animation to apply for this track entry. */\n  animation: Animation | null = null;\n\n  previous: TrackEntry | null = null;\n\n  /** The animation queued to start after this animation, or null. `next` makes up a linked list. */\n  next: TrackEntry | null = null;\n\n  /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\n   * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\n  mixingFrom: TrackEntry | null = null;\n\n  /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\n   * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\n  mixingTo: TrackEntry | null = null;\n\n  /** The listener for events generated by this track entry, or null.\n   *\n   * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\n   * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\n  listener: AnimationStateListener | null = null;\n\n  /** The index of the track where this track entry is either current or queued.\n   *\n   * See {@link AnimationState#getCurrent()}. */\n  trackIndex: number = 0;\n\n  /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n   * duration. */\n  loop: boolean = false;\n\n  /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\n   * of being mixed out.\n   *\n   * When mixing between animations that key the same property, if a lower track also keys that property then the value will\n   * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\n   * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\n   * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\n   * keys the property, only when a higher track also keys the property.\n   *\n   * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\n   * previous animation. */\n  holdPrevious: boolean = false;\n\n  reverse: boolean = false;\n\n  shortestRotation: boolean = false;\n\n  /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n   * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\n   * timelines are not applied while this animation is being mixed out. */\n  eventThreshold: number = 0;\n\n  /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\n   * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\n   * 0, so attachment timelines are not applied while this animation is being mixed out. */\n  attachmentThreshold: number = 0;\n\n  /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n   * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,\n   * so draw order timelines are not applied while this animation is being mixed out. */\n  drawOrderThreshold: number = 0;\n\n  /** Seconds when this animation starts, both initially and after looping. Defaults to 0.\n   *\n   * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\n   * value to prevent timeline keys before the start time from triggering. */\n  animationStart: number = 0;\n\n  /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\n   * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\n  animationEnd: number = 0;\n\n  /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\n   * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\n   * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\n   * is applied. */\n  animationLast: number = 0;\n\n  nextAnimationLast: number = 0;\n\n  /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\n   * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\n   * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\n   * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\n   *\n   * {@link #timeScale} affects the delay. */\n  delay: number = 0;\n\n  /** Current time in seconds this track entry has been the current track entry. The track time determines\n   * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\n   * looping. */\n  trackTime: number = 0;\n\n  trackLast: number = 0;\n  nextTrackLast: number = 0;\n\n  /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\n   * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\n   * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\n   * properties keyed by the animation are set to the setup pose and the track is cleared.\n   *\n   * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\n   * abruptly cease being applied. */\n  trackEnd: number = 0;\n\n  /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\n   * faster. Defaults to 1.\n   *\n   * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\n   * match the animation speed.\n   *\n   * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n   * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\n   * the time scale is not 1, the delay may need to be adjusted.\n   *\n   * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\n  timeScale: number = 0;\n\n  /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\n   * to 1, which overwrites the skeleton's current pose with this animation.\n   *\n   * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\n   * use alpha on track 0 if the skeleton pose is from the last frame render. */\n  alpha: number = 0;\n\n  /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\n   * slightly more than `mixDuration` when the mix is complete. */\n  mixTime: number = 0;\n\n  /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\n   * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\n   *\n   * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\n   * properties it was animating.\n   *\n   * The `mixDuration` can be set manually rather than use the value from\n   * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\n   * track entry only before {@link AnimationState#update(float)} is first called.\n   *\n   * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n   * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\n   * afterward. */\n  mixDuration: number = 0;\n  interruptAlpha: number = 0;\n  totalAlpha: number = 0;\n\n  /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\n   * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\n   * the values from the lower tracks.\n   *\n   * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\n   * called. */\n  mixBlend = MixBlend.replace;\n  timelineMode = new Array<number>();\n  timelineHoldMix = new Array<TrackEntry>();\n  timelinesRotation = new Array<number>();\n\n  reset() {\n    this.next = null;\n    this.previous = null;\n    this.mixingFrom = null;\n    this.mixingTo = null;\n    this.animation = null;\n    this.listener = null;\n    this.timelineMode.length = 0;\n    this.timelineHoldMix.length = 0;\n    this.timelinesRotation.length = 0;\n  }\n\n  /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\n   * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\n   * `animationStart` time. */\n  getAnimationTime() {\n    if (this.loop) {\n      const duration = this.animationEnd - this.animationStart;\n      if (duration == 0) return this.animationStart;\n      return (this.trackTime % duration) + this.animationStart;\n    }\n    return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n  }\n\n  setAnimationLast(animationLast: number) {\n    this.animationLast = animationLast;\n    this.nextAnimationLast = animationLast;\n  }\n\n  /** Returns true if at least one loop has been completed.\n   *\n   * See {@link AnimationStateListener#complete()}. */\n  isComplete() {\n    return this.trackTime >= this.animationEnd - this.animationStart;\n  }\n\n  /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\n   * long way around when using {@link #alpha} and starting animations on other tracks.\n   *\n   * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\n   * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\n   * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\n   * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\n  resetRotationDirections() {\n    this.timelinesRotation.length = 0;\n  }\n\n  getTrackComplete() {\n    const duration = this.animationEnd - this.animationStart;\n    if (duration != 0) {\n      if (this.loop) return duration * (1 + ((this.trackTime / duration) | 0)); // Completion of next loop.\n      if (this.trackTime < duration) return duration; // Before duration.\n    }\n    return this.trackTime; // Next update.\n  }\n}\n\nexport class EventQueue {\n  objects: Array<any> = [];\n  drainDisabled = false;\n  animState: AnimationState;\n\n  constructor(animState: AnimationState) {\n    this.animState = animState;\n  }\n\n  start(entry: TrackEntry) {\n    this.objects.push(EventType.start);\n    this.objects.push(entry);\n    this.animState.animationsChanged = true;\n  }\n\n  interrupt(entry: TrackEntry) {\n    this.objects.push(EventType.interrupt);\n    this.objects.push(entry);\n  }\n\n  end(entry: TrackEntry) {\n    this.objects.push(EventType.end);\n    this.objects.push(entry);\n    this.animState.animationsChanged = true;\n  }\n\n  dispose(entry: TrackEntry) {\n    this.objects.push(EventType.dispose);\n    this.objects.push(entry);\n  }\n\n  complete(entry: TrackEntry) {\n    this.objects.push(EventType.complete);\n    this.objects.push(entry);\n  }\n\n  event(entry: TrackEntry, event: Event) {\n    this.objects.push(EventType.event);\n    this.objects.push(entry);\n    this.objects.push(event);\n  }\n\n  drain() {\n    if (this.drainDisabled) return;\n    this.drainDisabled = true;\n\n    const objects = this.objects;\n    const listeners = this.animState.listeners;\n\n    for (let i = 0; i < objects.length; i += 2) {\n      const type = objects[i] as EventType;\n      const entry = objects[i + 1] as TrackEntry;\n      switch (type) {\n        case EventType.start:\n          if (entry.listener && entry.listener.start) entry.listener.start(entry);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.start) listener.start(entry);\n          }\n          break;\n        case EventType.interrupt:\n          if (entry.listener && entry.listener.interrupt) entry.listener.interrupt(entry);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.interrupt) listener.interrupt(entry);\n          }\n          break;\n        case EventType.end:\n          if (entry.listener && entry.listener.end) entry.listener.end(entry);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.end) listener.end(entry);\n          }\n        // Fall through.\n        case EventType.dispose:\n          if (entry.listener && entry.listener.dispose) entry.listener.dispose(entry);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.dispose) listener.dispose(entry);\n          }\n          this.animState.trackEntryPool.free(entry);\n          break;\n        case EventType.complete:\n          if (entry.listener && entry.listener.complete) entry.listener.complete(entry);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.complete) listener.complete(entry);\n          }\n          break;\n        case EventType.event:\n          const event = objects[i++ + 2] as Event;\n          if (entry.listener && entry.listener.event) entry.listener.event(entry, event);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.event) listener.event(entry, event);\n          }\n          break;\n      }\n    }\n    this.clear();\n\n    this.drainDisabled = false;\n  }\n\n  clear() {\n    this.objects.length = 0;\n  }\n}\n\nexport enum EventType {\n  start,\n  interrupt,\n  end,\n  dispose,\n  complete,\n  event,\n}\n\n/** The interface to implement for receiving TrackEntry events. It is always safe to call AnimationState methods when receiving\n * events.\n *\n * See TrackEntry {@link TrackEntry#listener} and AnimationState\n * {@link AnimationState#addListener()}. */\nexport interface AnimationStateListener {\n  /** Invoked when this entry has been set as the current entry. */\n  start?: (entry: TrackEntry) => void;\n\n  /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\n   * mixing. */\n  interrupt?: (entry: TrackEntry) => void;\n\n  /** Invoked when this entry is no longer the current entry and will never be applied again. */\n  end?: (entry: TrackEntry) => void;\n\n  /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\n   * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\n  dispose?: (entry: TrackEntry) => void;\n\n  /** Invoked every time this entry's animation completes a loop. */\n  complete?: (entry: TrackEntry) => void;\n\n  /** Invoked when this entry's animation triggers an event. */\n  event?: (entry: TrackEntry, event: Event) => void;\n}\n\nexport abstract class AnimationStateAdapter implements AnimationStateListener {\n  start(entry: TrackEntry) {}\n\n  interrupt(entry: TrackEntry) {}\n\n  end(entry: TrackEntry) {}\n\n  dispose(entry: TrackEntry) {}\n\n  complete(entry: TrackEntry) {}\n\n  event(entry: TrackEntry, event: Event) {}\n}\n\n/** 1. A previously applied timeline has set this property.\n *\n * Result: Mix from the current pose to the timeline pose. */\nexport const SUBSEQUENT = 0;\n/** 1. This is the first timeline to set this property.\n * 2. The next track entry applied after this one does not have a timeline to set this property.\n *\n * Result: Mix from the setup pose to the timeline pose. */\nexport const FIRST = 1;\n/** 1) A previously applied timeline has set this property.<br>\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\n * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\n * animations that key the same property. A subsequent timeline will set this property using a mix. */\nexport const HOLD_SUBSEQUENT = 2;\n/** 1) This is the first timeline to set this property.<br>\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\n * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\n * that key the same property. A subsequent timeline will set this property using a mix. */\nexport const HOLD_FIRST = 3;\n/** 1. This is the first timeline to set this property.\n * 2. The next track entry to be applied does have a timeline to set this property.\n * 3. The next track entry after that one does have a timeline to set this property.\n * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\n *\n * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\n * 2 track entries in a row have a timeline that sets the same property.\n *\n * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\n * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\n * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\n * place. */\nexport const HOLD_MIX = 4;\n\nexport const SETUP = 1;\nexport const CURRENT = 2;\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Animation } from './Animation';\nimport { SkeletonData } from './SkeletonData';\nimport { StringMap } from './Utils';\n\n/** Stores mix (crossfade) durations to be applied when {@link AnimationState} animations are changed. */\nexport class AnimationStateData {\n  /** The SkeletonData to look up animations when they are specified by name. */\n  skeletonData: SkeletonData;\n\n  animationToMixTime: StringMap<number> = {};\n\n  /** The mix duration to use when no mix duration has been defined between two animations. */\n  defaultMix = 0;\n\n  constructor(skeletonData: SkeletonData) {\n    if (!skeletonData) throw new Error('skeletonData cannot be null.');\n    this.skeletonData = skeletonData;\n  }\n\n  /** Sets a mix duration by animation name.\n   *\n   * See {@link #setMixWith()}. */\n  setMix(fromName: string, toName: string, duration: number) {\n    const from = this.skeletonData.findAnimation(fromName);\n    if (!from) throw new Error('Animation not found: ' + fromName);\n    const to = this.skeletonData.findAnimation(toName);\n    if (!to) throw new Error('Animation not found: ' + toName);\n    this.setMixWith(from, to, duration);\n  }\n\n  /** Sets the mix duration when changing from the specified animation to the other.\n   *\n   * See {@link TrackEntry#mixDuration}. */\n  setMixWith(from: Animation, to: Animation, duration: number) {\n    if (!from) throw new Error('from cannot be null.');\n    if (!to) throw new Error('to cannot be null.');\n    const key = from.name + '.' + to.name;\n    this.animationToMixTime[key] = duration;\n  }\n\n  /** Returns the mix duration to use when changing from the specified animation to the other, or the {@link #defaultMix} if\n   * no mix duration has been set. */\n  getMix(from: Animation, to: Animation) {\n    const key = from.name + '.' + to.name;\n    const value = this.animationToMixTime[key];\n    return value === undefined ? this.defaultMix : value;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Color } from '../Utils';\nimport { Attachment, VertexAttachment } from './Attachment';\n\n/** An attachment with vertices that make up a polygon. Can be used for hit detection, creating physics bodies, spawning particle\n * effects, and more.\n *\n * See {@link SkeletonBounds} and [Bounding Boxes](http://esotericsoftware.com/spine-bounding-boxes) in the Spine User\n * Guide. */\nexport class BoundingBoxAttachment extends VertexAttachment {\n  color = new Color(1, 1, 1, 1);\n\n  constructor(name: string) {\n    super(name);\n  }\n\n  copy(): Attachment {\n    const copy = new BoundingBoxAttachment(this.name);\n    this.copyTo(copy);\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { SlotData } from '../SlotData';\nimport { Color } from '../Utils';\nimport { Attachment, VertexAttachment } from './Attachment';\n\n/** An attachment with vertices that make up a polygon used for clipping the rendering of other attachments. */\nexport class ClippingAttachment extends VertexAttachment {\n  /** Clipping is performed between the clipping polygon's slot and the end slot. Returns null if clipping is done until the end of\n   * the skeleton's rendering. */\n  endSlot: SlotData | null = null;\n\n  // Nonessential.\n  /** The color of the clipping polygon as it was in Spine. Available only when nonessential data was exported. Clipping polygons\n   * are not usually rendered at runtime. */\n  color = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\n\n  constructor(name: string) {\n    super(name);\n  }\n\n  copy(): Attachment {\n    const copy = new ClippingAttachment(this.name);\n    this.copyTo(copy);\n    copy.endSlot = this.endSlot;\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport abstract class Texture {\n\tprotected _image: HTMLImageElement | ImageBitmap;\n\n\tconstructor (image: HTMLImageElement | ImageBitmap) {\n\t\tthis._image = image;\n\t}\n\n\tgetImage (): HTMLImageElement | ImageBitmap {\n\t\treturn this._image;\n\t}\n\n\tabstract setFilters (minFilter: TextureFilter, magFilter: TextureFilter): void;\n\tabstract setWraps (uWrap: TextureWrap, vWrap: TextureWrap): void;\n\tabstract dispose (): void;\n}\n\nexport enum TextureFilter {\n\tNearest = 9728, // WebGLRenderingContext.NEAREST\n\tLinear = 9729, // WebGLRenderingContext.LINEAR\n\tMipMap = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n\tMipMapNearestNearest = 9984, // WebGLRenderingContext.NEAREST_MIPMAP_NEAREST\n\tMipMapLinearNearest = 9985, // WebGLRenderingContext.LINEAR_MIPMAP_NEAREST\n\tMipMapNearestLinear = 9986, // WebGLRenderingContext.NEAREST_MIPMAP_LINEAR\n\tMipMapLinearLinear = 9987 // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n}\n\nexport enum TextureWrap {\n\tMirroredRepeat = 33648, // WebGLRenderingContext.MIRRORED_REPEAT\n\tClampToEdge = 33071, // WebGLRenderingContext.CLAMP_TO_EDGE\n\tRepeat = 10497 // WebGLRenderingContext.REPEAT\n}\n\nexport class TextureRegion {\n\ttexture: any;\n\tu = 0; v = 0;\n\tu2 = 0; v2 = 0;\n\twidth = 0; height = 0;\n\tdegrees = 0;\n\toffsetX = 0; offsetY = 0;\n\toriginalWidth = 0; originalHeight = 0;\n}\n\nexport class FakeTexture extends Texture {\n\tsetFilters (minFilter: TextureFilter, magFilter: TextureFilter) { }\n\tsetWraps (uWrap: TextureWrap, vWrap: TextureWrap) { }\n\tdispose () { }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { AssetManagerBase } from './AssetManagerBase';\nimport { Texture, TextureFilter, TextureRegion, TextureWrap } from './Texture';\nimport { Disposable, StringMap, Utils } from './Utils';\n\nexport class TextureAtlas implements Disposable {\n  pages = new Array<TextureAtlasPage>();\n  regions = new Array<TextureAtlasRegion>();\n\n  constructor(atlasText: string) {\n    const reader = new TextureAtlasReader(atlasText);\n    const entry = new Array<string>(4);\n\n    const pageFields: StringMap<(page: TextureAtlasPage) => void> = {};\n    pageFields['size'] = (page: TextureAtlasPage) => {\n      page!.width = parseInt(entry[1]);\n      page!.height = parseInt(entry[2]);\n    };\n    pageFields['format'] = () => {\n      // page.format = Format[tuple[0]]; we don't need format in WebGL\n    };\n    pageFields['filter'] = (page: TextureAtlasPage) => {\n      page!.minFilter = Utils.enumValue(TextureFilter, entry[1]);\n      page!.magFilter = Utils.enumValue(TextureFilter, entry[2]);\n    };\n    pageFields['repeat'] = (page: TextureAtlasPage) => {\n      if (entry[1].indexOf('x') != -1) page!.uWrap = TextureWrap.Repeat;\n      if (entry[1].indexOf('y') != -1) page!.vWrap = TextureWrap.Repeat;\n    };\n    pageFields['pma'] = (page: TextureAtlasPage) => {\n      page!.pma = entry[1] == 'true';\n    };\n\n    const regionFields: StringMap<(region: TextureAtlasRegion) => void> = {};\n    regionFields['xy'] = (region: TextureAtlasRegion) => {\n      // Deprecated, use bounds.\n      region.x = parseInt(entry[1]);\n      region.y = parseInt(entry[2]);\n    };\n    regionFields['size'] = (region: TextureAtlasRegion) => {\n      // Deprecated, use bounds.\n      region.width = parseInt(entry[1]);\n      region.height = parseInt(entry[2]);\n    };\n    regionFields['bounds'] = (region: TextureAtlasRegion) => {\n      region.x = parseInt(entry[1]);\n      region.y = parseInt(entry[2]);\n      region.width = parseInt(entry[3]);\n      region.height = parseInt(entry[4]);\n    };\n    regionFields['offset'] = (region: TextureAtlasRegion) => {\n      // Deprecated, use offsets.\n      region.offsetX = parseInt(entry[1]);\n      region.offsetY = parseInt(entry[2]);\n    };\n    regionFields['orig'] = (region: TextureAtlasRegion) => {\n      // Deprecated, use offsets.\n      region.originalWidth = parseInt(entry[1]);\n      region.originalHeight = parseInt(entry[2]);\n    };\n    regionFields['offsets'] = (region: TextureAtlasRegion) => {\n      region.offsetX = parseInt(entry[1]);\n      region.offsetY = parseInt(entry[2]);\n      region.originalWidth = parseInt(entry[3]);\n      region.originalHeight = parseInt(entry[4]);\n    };\n    regionFields['rotate'] = (region: TextureAtlasRegion) => {\n      const value = entry[1];\n      if (value == 'true') region.degrees = 90;\n      else if (value != 'false') region.degrees = parseInt(value);\n    };\n    regionFields['index'] = (region: TextureAtlasRegion) => {\n      region.index = parseInt(entry[1]);\n    };\n\n    let line = reader.readLine();\n    // Ignore empty lines before first entry.\n    while (line && line.trim().length == 0) line = reader.readLine();\n    // Header entries.\n    while (true) {\n      if (!line || line.trim().length == 0) break;\n      if (reader.readEntry(entry, line) == 0) break; // Silently ignore all header fields.\n      line = reader.readLine();\n    }\n\n    // Page and region entries.\n    let page: TextureAtlasPage | null = null;\n    let names: string[] | null = null;\n    let values: number[][] | null = null;\n    while (true) {\n      if (line === null) break;\n      if (line.trim().length == 0) {\n        page = null;\n        line = reader.readLine();\n      } else if (!page) {\n        page = new TextureAtlasPage(line.trim());\n        while (true) {\n          if (reader.readEntry(entry, (line = reader.readLine())) == 0) break;\n          const field = pageFields[entry[0]];\n          if (field) field(page);\n        }\n        this.pages.push(page);\n      } else {\n        const region = new TextureAtlasRegion(page, line);\n\n        while (true) {\n          const count = reader.readEntry(entry, (line = reader.readLine()));\n          if (count == 0) break;\n          const field = regionFields[entry[0]];\n          if (field) field(region);\n          else {\n            if (!names) names = [];\n            if (!values) values = [];\n            names.push(entry[0]);\n            const entryValues: number[] = [];\n            for (let i = 0; i < count; i++) entryValues.push(parseInt(entry[i + 1]));\n            values.push(entryValues);\n          }\n        }\n        if (region.originalWidth == 0 && region.originalHeight == 0) {\n          region.originalWidth = region.width;\n          region.originalHeight = region.height;\n        }\n        if (names && names.length > 0 && values && values.length > 0) {\n          region.names = names;\n          region.values = values;\n          names = null;\n          values = null;\n        }\n        region.u = region.x / page.width;\n        region.v = region.y / page.height;\n        if (region.degrees == 90) {\n          region.u2 = (region.x + region.height) / page.width;\n          region.v2 = (region.y + region.width) / page.height;\n        } else {\n          region.u2 = (region.x + region.width) / page.width;\n          region.v2 = (region.y + region.height) / page.height;\n        }\n        this.regions.push(region);\n      }\n    }\n  }\n\n  dispose() {\n    for (let i = 0; i < this.pages.length; i++) {\n      this.pages[i].texture?.dispose();\n    }\n  }\n\n  findRegion(name: string): TextureAtlasRegion | null {\n    for (let i = 0; i < this.regions.length; i++) {\n      if (this.regions[i].name == name) {\n        return this.regions[i];\n      }\n    }\n    return null;\n  }\n\n  setTextures(assetManager: AssetManagerBase, pathPrefix: string = '') {\n    for (const page of this.pages) page.setTexture(assetManager.get(pathPrefix + page.name));\n  }\n}\n\nclass TextureAtlasReader {\n  lines: Array<string>;\n  index: number = 0;\n\n  constructor(text: string) {\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\n  }\n\n  readLine(): string | null {\n    if (this.index >= this.lines.length) return null;\n    return this.lines[this.index++];\n  }\n\n  readEntry(entry: string[], line: string | null): number {\n    if (!line) return 0;\n    line = line.trim();\n    if (line.length == 0) return 0;\n\n    const colon = line.indexOf(':');\n    if (colon == -1) return 0;\n    entry[0] = line.substr(0, colon).trim();\n    for (let i = 1, lastMatch = colon + 1; ; i++) {\n      const comma = line.indexOf(',', lastMatch);\n      if (comma == -1) {\n        entry[i] = line.substr(lastMatch).trim();\n        return i;\n      }\n      entry[i] = line.substr(lastMatch, comma - lastMatch).trim();\n      lastMatch = comma + 1;\n      if (i == 4) return 4;\n    }\n  }\n}\n\nexport class TextureAtlasPage {\n  name: string;\n  minFilter: TextureFilter = TextureFilter.Nearest;\n  magFilter: TextureFilter = TextureFilter.Nearest;\n  uWrap: TextureWrap = TextureWrap.ClampToEdge;\n  vWrap: TextureWrap = TextureWrap.ClampToEdge;\n  texture: Texture | null = null;\n  width: number = 0;\n  height: number = 0;\n  pma: boolean = false;\n  regions = new Array<TextureAtlasRegion>();\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  setTexture(texture: Texture) {\n    this.texture = texture;\n    texture.setFilters(this.minFilter, this.magFilter);\n    texture.setWraps(this.uWrap, this.vWrap);\n    for (const region of this.regions) region.texture = texture;\n  }\n}\n\nexport class TextureAtlasRegion extends TextureRegion {\n  offsetX: number = 0;\n  offsetY: number = 0;\n  originalWidth: number = 0;\n  originalHeight: number = 0;\n  degrees: number = 0;\n  page: TextureAtlasPage;\n  name: string;\n  x: number = 0;\n  y: number = 0;\n  index: number = 0;\n  names: string[] | null = null;\n  values: number[][] | null = null;\n\n  constructor(page: TextureAtlasPage, name: string) {\n    super();\n    this.page = page;\n    this.name = name;\n    page.regions.push(this);\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Slot } from '../Slot';\nimport { TextureRegion } from '../Texture';\nimport { TextureAtlasRegion } from '../TextureAtlas';\nimport { Color, NumberArrayLike, Utils } from '../Utils';\nimport { Attachment, VertexAttachment } from './Attachment';\nimport { HasTextureRegion } from './HasTextureRegion';\nimport { Sequence } from './Sequence';\n\n/** An attachment that displays a textured mesh. A mesh has hull vertices and internal vertices within the hull. Holes are not\n * supported. Each vertex has UVs (texture coordinates) and triangles are used to map an image on to the mesh.\n *\n * See [Mesh attachments](http://esotericsoftware.com/spine-meshes) in the Spine User Guide. */\nexport class MeshAttachment extends VertexAttachment implements HasTextureRegion {\n  region: TextureRegion | null = null;\n\n  /** The name of the texture region for this attachment. */\n  path: string;\n  /** The color to tint the mesh. */\n  color = new Color(1, 1, 1, 1);\n  sequence: Sequence | null = null;\n  /** The UV pair for each vertex, normalized within the texture region. */\n  regionUVs: NumberArrayLike = [];\n  /** The UV pair for each vertex, normalized within the entire texture.\n   *\n   * See {@link #updateUVs}. */\n  uvs: NumberArrayLike = [];\n  /** Triplets of vertex indices which describe the mesh's triangulation. */\n  triangles: Array<number> = [];\n  /** The width of the mesh's image. Available only when nonessential data was exported. */\n  width: number = 0;\n  /** The height of the mesh's image. Available only when nonessential data was exported. */\n  height: number = 0;\n  /** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */\n  hullLength: number = 0;\n  /** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if\n   * nonessential data was exported. Triangulation is not performed at runtime. */\n  edges: Array<number> = [];\n  tempColor = new Color(0, 0, 0, 0);\n  private parentMesh: MeshAttachment | null = null;\n\n  constructor(name: string, path: string) {\n    super(name);\n    this.path = path;\n  }\n\n  /** Calculates {@link #uvs} using the {@link #regionUVs} and region. Must be called if the region, the region's properties, or\n   * the {@link #regionUVs} are changed. */\n  updateRegion() {\n    if (!this.region) throw new Error('Region not set.');\n    const regionUVs = this.regionUVs;\n    if (!this.uvs || this.uvs.length != regionUVs.length) this.uvs = Utils.newFloatArray(regionUVs.length);\n    const uvs = this.uvs;\n    const n = this.uvs.length;\n    let u = this.region.u,\n      v = this.region.v,\n      width = 0,\n      height = 0;\n    if (this.region instanceof TextureAtlasRegion) {\n      const region = this.region,\n        image = region.page!.texture!.getImage();\n      const textureWidth = image.width,\n        textureHeight = image.height;\n      switch (region.degrees) {\n        case 90:\n          u -= (region.originalHeight - region.offsetY - region.height) / textureWidth;\n          v -= (region.originalWidth - region.offsetX - region.width) / textureHeight;\n          width = region.originalHeight / textureWidth;\n          height = region.originalWidth / textureHeight;\n          for (let i = 0; i < n; i += 2) {\n            uvs[i] = u + regionUVs[i + 1] * width;\n            uvs[i + 1] = v + (1 - regionUVs[i]) * height;\n          }\n          return;\n        case 180:\n          u -= (region.originalWidth - region.offsetX - region.width) / textureWidth;\n          v -= region.offsetY / textureHeight;\n          width = region.originalWidth / textureWidth;\n          height = region.originalHeight / textureHeight;\n          for (let i = 0; i < n; i += 2) {\n            uvs[i] = u + (1 - regionUVs[i]) * width;\n            uvs[i + 1] = v + (1 - regionUVs[i + 1]) * height;\n          }\n          return;\n        case 270:\n          u -= region.offsetY / textureWidth;\n          v -= region.offsetX / textureHeight;\n          width = region.originalHeight / textureWidth;\n          height = region.originalWidth / textureHeight;\n          for (let i = 0; i < n; i += 2) {\n            uvs[i] = u + (1 - regionUVs[i + 1]) * width;\n            uvs[i + 1] = v + regionUVs[i] * height;\n          }\n          return;\n      }\n      u -= region.offsetX / textureWidth;\n      v -= (region.originalHeight - region.offsetY - region.height) / textureHeight;\n      width = region.originalWidth / textureWidth;\n      height = region.originalHeight / textureHeight;\n    } else if (!this.region) {\n      u = v = 0;\n      width = height = 1;\n    } else {\n      width = this.region.u2 - u;\n      height = this.region.v2 - v;\n    }\n\n    for (let i = 0; i < n; i += 2) {\n      uvs[i] = u + regionUVs[i] * width;\n      uvs[i + 1] = v + regionUVs[i + 1] * height;\n    }\n  }\n\n  copy(): Attachment {\n    if (this.parentMesh) return this.newLinkedMesh();\n\n    const copy = new MeshAttachment(this.name, this.path);\n    copy.region = this.region;\n    copy.color.setFromColor(this.color);\n\n    this.copyTo(copy);\n    copy.regionUVs = new Array<number>(this.regionUVs.length);\n    Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\n    copy.uvs = new Array<number>(this.uvs.length);\n    Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, this.uvs.length);\n    copy.triangles = new Array<number>(this.triangles.length);\n    Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\n    copy.hullLength = this.hullLength;\n\n    copy.sequence = this.sequence != null ? this.sequence.copy() : null;\n\n    // Nonessential.\n    if (this.edges) {\n      copy.edges = new Array<number>(this.edges.length);\n      Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\n    }\n    copy.width = this.width;\n    copy.height = this.height;\n\n    return copy;\n  }\n\n  computeWorldVertices(\n    slot: Slot,\n    start: number,\n    count: number,\n    worldVertices: NumberArrayLike,\n    offset: number,\n    stride: number,\n  ) {\n    if (this.sequence != null) this.sequence.apply(slot, this);\n    super.computeWorldVertices(slot, start, count, worldVertices, offset, stride);\n  }\n\n  /** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},\n   * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the\n   * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */\n  getParentMesh() {\n    return this.parentMesh;\n  }\n\n  /** @param parentMesh May be null. */\n  setParentMesh(parentMesh: MeshAttachment) {\n    this.parentMesh = parentMesh;\n    if (parentMesh) {\n      this.bones = parentMesh.bones;\n      this.vertices = parentMesh.vertices;\n      this.worldVerticesLength = parentMesh.worldVerticesLength;\n      this.regionUVs = parentMesh.regionUVs;\n      this.triangles = parentMesh.triangles;\n      this.hullLength = parentMesh.hullLength;\n      this.worldVerticesLength = parentMesh.worldVerticesLength;\n    }\n  }\n\n  /** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/\n  newLinkedMesh(): MeshAttachment {\n    const copy = new MeshAttachment(this.name, this.path);\n    copy.region = this.region;\n    copy.color.setFromColor(this.color);\n    copy.timelineAttachment = this.timelineAttachment;\n    copy.setParentMesh(this.parentMesh ? this.parentMesh : this);\n    if (copy.region != null) copy.updateRegion();\n    return copy;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Color, Utils } from '../Utils';\nimport { Attachment, VertexAttachment } from './Attachment';\n\n/** An attachment whose vertices make up a composite Bezier curve.\n *\n * See {@link PathConstraint} and [Paths](http://esotericsoftware.com/spine-paths) in the Spine User Guide. */\nexport class PathAttachment extends VertexAttachment {\n  /** The lengths along the path in the setup pose from the start of the path to the end of each Bezier curve. */\n  lengths: Array<number> = [];\n\n  /** If true, the start and end knots are connected. */\n  closed = false;\n\n  /** If true, additional calculations are performed to make calculating positions along the path more accurate. If false, fewer\n   * calculations are performed but calculating positions along the path is less accurate. */\n  constantSpeed = false;\n\n  /** The color of the path as it was in Spine. Available only when nonessential data was exported. Paths are not usually\n   * rendered at runtime. */\n  color = new Color(1, 1, 1, 1);\n\n  constructor(name: string) {\n    super(name);\n  }\n\n  copy(): Attachment {\n    const copy = new PathAttachment(this.name);\n    this.copyTo(copy);\n    copy.lengths = new Array<number>(this.lengths.length);\n    Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\n    copy.closed = closed;\n    copy.constantSpeed = this.constantSpeed;\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Bone } from '../Bone';\nimport { Color, MathUtils, Vector2 } from '../Utils';\nimport { Attachment, VertexAttachment } from './Attachment';\n\n/** An attachment which is a single point and a rotation. This can be used to spawn projectiles, particles, etc. A bone can be\n * used in similar ways, but a PointAttachment is slightly less expensive to compute and can be hidden, shown, and placed in a\n * skin.\n *\n * See [Point Attachments](http://esotericsoftware.com/spine-point-attachments) in the Spine User Guide. */\nexport class PointAttachment extends VertexAttachment {\n  x: number = 0;\n  y: number = 0;\n  rotation: number = 0;\n\n  /** The color of the point attachment as it was in Spine. Available only when nonessential data was exported. Point attachments\n   * are not usually rendered at runtime. */\n  color = new Color(0.38, 0.94, 0, 1);\n\n  constructor(name: string) {\n    super(name);\n  }\n\n  copy(): Attachment {\n    const copy = new PointAttachment(this.name);\n    copy.x = this.x;\n    copy.y = this.y;\n    copy.rotation = this.rotation;\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n\n  computeWorldPosition(bone: Bone, point: Vector2) {\n    point.x = this.x * bone.a + this.y * bone.b + bone.worldX;\n    point.y = this.x * bone.c + this.y * bone.d + bone.worldY;\n    return point;\n  }\n\n  computeWorldRotation(bone: Bone) {\n    const cos = MathUtils.cosDeg(this.rotation),\n      sin = MathUtils.sinDeg(this.rotation);\n    const x = cos * bone.a + sin * bone.b;\n    const y = cos * bone.c + sin * bone.d;\n    return Math.atan2(y, x) * MathUtils.radDeg;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Slot } from '../Slot';\nimport { TextureRegion } from '../Texture';\nimport { Color, NumberArrayLike, Utils } from '../Utils';\nimport { Attachment } from './Attachment';\nimport { HasTextureRegion } from './HasTextureRegion';\nimport { Sequence } from './Sequence';\n\n/** An attachment that displays a textured quadrilateral.\n *\n * See [Region attachments](http://esotericsoftware.com/spine-regions) in the Spine User Guide. */\nexport class RegionAttachment extends Attachment implements HasTextureRegion {\n  /** The color to tint the region attachment. */\n  color = new Color(1, 1, 1, 1);\n  /** The name of the texture region for this attachment. */\n  path: string;\n  region: TextureRegion | null = null;\n  sequence: Sequence | null = null;\n  /** The local x translation. */\n  x = 0;\n  /** The local y translation. */\n  y = 0;\n  /** The local scaleX. */\n  scaleX = 1;\n  /** The local scaleY. */\n  scaleY = 1;\n  /** The local rotation. */\n  rotation = 0;\n  /** The width of the region attachment in Spine. */\n  width = 0;\n  /** The height of the region attachment in Spine. */\n  height = 0;\n  /** For each of the 4 vertices, a pair of <code>x,y</code> values that is the local position of the vertex.\n   *\n   * See {@link #updateOffset()}. */\n  offset = Utils.newFloatArray(8);\n\n  uvs = Utils.newFloatArray(8);\n\n  tempColor = new Color(1, 1, 1, 1);\n  static X1 = 0;\n  static Y1 = 1;\n  static C1R = 2;\n  static C1G = 3;\n  static C1B = 4;\n  static C1A = 5;\n  static U1 = 6;\n  static V1 = 7;\n  static X2 = 8;\n  static Y2 = 9;\n  static C2R = 10;\n  static C2G = 11;\n  static C2B = 12;\n  static C2A = 13;\n  static U2 = 14;\n  static V2 = 15;\n  static X3 = 16;\n  static Y3 = 17;\n  static C3R = 18;\n  static C3G = 19;\n  static C3B = 20;\n  static C3A = 21;\n  static U3 = 22;\n  static V3 = 23;\n  static X4 = 24;\n  static Y4 = 25;\n  static C4R = 26;\n  static C4G = 27;\n  static C4B = 28;\n  static C4A = 29;\n  static U4 = 30;\n  static V4 = 31;\n\n  constructor(name: string, path: string) {\n    super(name);\n    this.path = path;\n  }\n\n  /** Calculates the {@link #offset} using the region settings. Must be called after changing region settings. */\n  updateRegion(): void {\n    if (!this.region) throw new Error('Region not set.');\n    const region = this.region;\n    const uvs = this.uvs;\n\n    if (region == null) {\n      uvs[0] = 0;\n      uvs[1] = 0;\n      uvs[2] = 0;\n      uvs[3] = 1;\n      uvs[4] = 1;\n      uvs[5] = 1;\n      uvs[6] = 1;\n      uvs[7] = 0;\n      return;\n    }\n\n    const regionScaleX = (this.width / this.region.originalWidth) * this.scaleX;\n    const regionScaleY = (this.height / this.region.originalHeight) * this.scaleY;\n    const localX = (-this.width / 2) * this.scaleX + this.region.offsetX * regionScaleX;\n    const localY = (-this.height / 2) * this.scaleY + this.region.offsetY * regionScaleY;\n    const localX2 = localX + this.region.width * regionScaleX;\n    const localY2 = localY + this.region.height * regionScaleY;\n    const radians = (this.rotation * Math.PI) / 180;\n    const cos = Math.cos(radians);\n    const sin = Math.sin(radians);\n    const x = this.x,\n      y = this.y;\n    const localXCos = localX * cos + x;\n    const localXSin = localX * sin;\n    const localYCos = localY * cos + y;\n    const localYSin = localY * sin;\n    const localX2Cos = localX2 * cos + x;\n    const localX2Sin = localX2 * sin;\n    const localY2Cos = localY2 * cos + y;\n    const localY2Sin = localY2 * sin;\n    const offset = this.offset;\n    offset[0] = localXCos - localYSin;\n    offset[1] = localYCos + localXSin;\n    offset[2] = localXCos - localY2Sin;\n    offset[3] = localY2Cos + localXSin;\n    offset[4] = localX2Cos - localY2Sin;\n    offset[5] = localY2Cos + localX2Sin;\n    offset[6] = localX2Cos - localYSin;\n    offset[7] = localYCos + localX2Sin;\n\n    if (region.degrees == 90) {\n      uvs[0] = region.u2;\n      uvs[1] = region.v2;\n      uvs[2] = region.u;\n      uvs[3] = region.v2;\n      uvs[4] = region.u;\n      uvs[5] = region.v;\n      uvs[6] = region.u2;\n      uvs[7] = region.v;\n    } else {\n      uvs[0] = region.u;\n      uvs[1] = region.v2;\n      uvs[2] = region.u;\n      uvs[3] = region.v;\n      uvs[4] = region.u2;\n      uvs[5] = region.v;\n      uvs[6] = region.u2;\n      uvs[7] = region.v2;\n    }\n  }\n\n  copy(): Attachment {\n    const copy = new RegionAttachment(this.name, this.path);\n    copy.region = this.region;\n    copy.x = this.x;\n    copy.y = this.y;\n    copy.scaleX = this.scaleX;\n    copy.scaleY = this.scaleY;\n    copy.rotation = this.rotation;\n    copy.width = this.width;\n    copy.height = this.height;\n    Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\n    Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\n    copy.color.setFromColor(this.color);\n    copy.sequence = this.sequence != null ? this.sequence.copy() : null;\n    return copy;\n  }\n\n  /** Transforms the attachment's four vertices to world coordinates. If the attachment has a {@link #sequence}, the region may\n   * be changed.\n   * <p>\n   * See <a href=\"http://esotericsoftware.com/spine-runtime-skeletons#World-transforms\">World transforms</a> in the Spine\n   * Runtimes Guide.\n   * @param worldVertices The output world vertices. Must have a length >= <code>offset</code> + 8.\n   * @param offset The <code>worldVertices</code> index to begin writing values.\n   * @param stride The number of <code>worldVertices</code> entries between the value pairs written. */\n  computeWorldVertices(slot: Slot, worldVertices: NumberArrayLike, offset: number, stride: number) {\n    if (this.sequence != null) this.sequence.apply(slot, this);\n\n    const bone = slot.bone;\n    const vertexOffset = this.offset;\n    const x = bone.worldX,\n      y = bone.worldY;\n    const a = bone.a,\n      b = bone.b,\n      c = bone.c,\n      d = bone.d;\n    let offsetX = 0,\n      offsetY = 0;\n\n    offsetX = vertexOffset[0];\n    offsetY = vertexOffset[1];\n    worldVertices[offset] = offsetX * a + offsetY * b + x; // br\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n\n    offsetX = vertexOffset[2];\n    offsetY = vertexOffset[3];\n    worldVertices[offset] = offsetX * a + offsetY * b + x; // bl\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n\n    offsetX = vertexOffset[4];\n    offsetY = vertexOffset[5];\n    worldVertices[offset] = offsetX * a + offsetY * b + x; // ul\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n\n    offsetX = vertexOffset[6];\n    offsetY = vertexOffset[7];\n    worldVertices[offset] = offsetX * a + offsetY * b + x; // ur\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport {\n  AttachmentLoader,\n  BoundingBoxAttachment,\n  ClippingAttachment,\n  MeshAttachment,\n  PathAttachment,\n  PointAttachment,\n  RegionAttachment,\n} from './attachments';\nimport { Sequence } from './attachments/Sequence';\nimport { Skin } from './Skin';\nimport { TextureAtlas } from './TextureAtlas';\n\n/** An {@link AttachmentLoader} that configures attachments using texture regions from an {@link TextureAtlas}.\n *\n * See [Loading skeleton data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the\n * Spine Runtimes Guide. */\nexport class AtlasAttachmentLoader implements AttachmentLoader {\n  atlas: TextureAtlas;\n\n  constructor(atlas: TextureAtlas) {\n    this.atlas = atlas;\n  }\n\n  newRegionAttachment(skin: Skin, name: string, path: string, sequence: Sequence): RegionAttachment {\n    const attachment = new RegionAttachment(name, path);\n    if (sequence != null) {\n      this.loadSequence(name, path, sequence);\n    } else {\n      const region = this.atlas.findRegion(path);\n      if (!region) throw new Error('Region not found in atlas: ' + path + ' (region attachment: ' + name + ')');\n      attachment.region = region;\n    }\n    return attachment;\n  }\n\n  newMeshAttachment(skin: Skin, name: string, path: string, sequence: Sequence): MeshAttachment {\n    const attachment = new MeshAttachment(name, path);\n    if (sequence != null) {\n      this.loadSequence(name, path, sequence);\n    } else {\n      const region = this.atlas.findRegion(path);\n      if (!region) throw new Error('Region not found in atlas: ' + path + ' (mesh attachment: ' + name + ')');\n      attachment.region = region;\n    }\n    return attachment;\n  }\n\n  newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment {\n    return new BoundingBoxAttachment(name);\n  }\n\n  newPathAttachment(skin: Skin, name: string): PathAttachment {\n    return new PathAttachment(name);\n  }\n\n  newPointAttachment(skin: Skin, name: string): PointAttachment {\n    return new PointAttachment(name);\n  }\n\n  newClippingAttachment(skin: Skin, name: string): ClippingAttachment {\n    return new ClippingAttachment(name);\n  }\n\n  loadSequence(name: string, basePath: string, sequence: Sequence) {\n    const regions = sequence.regions;\n    for (let i = 0, n = regions.length; i < n; i++) {\n      const path = sequence.getPath(basePath, i);\n      const region = this.atlas.findRegion(path);\n      if (region == null) throw new Error('Region not found in atlas: ' + path + ' (sequence: ' + name + ')');\n      regions[i] = region;\n    }\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Color } from './Utils';\n\n/** Stores the setup pose for a {@link Bone}. */\nexport class BoneData {\n  /** The index of the bone in {@link Skeleton#getBones()}. */\n  index: number = 0;\n\n  /** The name of the bone, which is unique across all bones in the skeleton. */\n  name: string;\n\n  /** @returns May be null. */\n  parent: BoneData | null = null;\n\n  /** The bone's length. */\n  length: number = 0;\n\n  /** The local x translation. */\n  x = 0;\n\n  /** The local y translation. */\n  y = 0;\n\n  /** The local rotation. */\n  rotation = 0;\n\n  /** The local scaleX. */\n  scaleX = 1;\n\n  /** The local scaleY. */\n  scaleY = 1;\n\n  /** The local shearX. */\n  shearX = 0;\n\n  /** The local shearX. */\n  shearY = 0;\n\n  /** The transform mode for how parent world transforms affect this bone. */\n  transformMode = TransformMode.Normal;\n\n  /** When true, {@link Skeleton#updateWorldTransform()} only updates this bone if the {@link Skeleton#skin} contains this\n   * bone.\n   * @see Skin#bones */\n  skinRequired = false;\n\n  /** The color of the bone as it was in Spine. Available only when nonessential data was exported. Bones are not usually\n   * rendered at runtime. */\n  color = new Color();\n\n  constructor(index: number, name: string, parent: BoneData | null) {\n    if (index < 0) throw new Error('index must be >= 0.');\n    if (!name) throw new Error('name cannot be null.');\n    this.index = index;\n    this.name = name;\n    this.parent = parent;\n  }\n}\n\n/** Determines how a bone inherits world transforms from parent bones. */\nexport enum TransformMode {\n  Normal,\n  OnlyTranslation,\n  NoRotationOrReflection,\n  NoScale,\n  NoScaleOrReflection,\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { BoneData, TransformMode } from './BoneData';\nimport { Skeleton } from './Skeleton';\nimport { Updatable } from './Updatable';\nimport { MathUtils, Vector2 } from './Utils';\n\n/** Stores a bone's current pose.\n *\n * A bone has a local transform which is used to compute its world transform. A bone also has an applied transform, which is a\n * local transform that can be applied to compute the world transform. The local transform and applied transform may differ if a\n * constraint or application code modifies the world transform after it was computed from the local transform. */\nexport class Bone implements Updatable {\n  /** The bone's setup pose data. */\n  data: BoneData;\n\n  /** The skeleton this bone belongs to. */\n  skeleton: Skeleton;\n\n  /** The parent bone, or null if this is the root bone. */\n  parent: Bone | null = null;\n\n  /** The immediate children of this bone. */\n  children = new Array<Bone>();\n\n  /** The local x translation. */\n  x = 0;\n\n  /** The local y translation. */\n  y = 0;\n\n  /** The local rotation in degrees, counter clockwise. */\n  rotation = 0;\n\n  /** The local scaleX. */\n  scaleX = 0;\n\n  /** The local scaleY. */\n  scaleY = 0;\n\n  /** The local shearX. */\n  shearX = 0;\n\n  /** The local shearY. */\n  shearY = 0;\n\n  /** The applied local x translation. */\n  ax = 0;\n\n  /** The applied local y translation. */\n  ay = 0;\n\n  /** The applied local rotation in degrees, counter clockwise. */\n  arotation = 0;\n\n  /** The applied local scaleX. */\n  ascaleX = 0;\n\n  /** The applied local scaleY. */\n  ascaleY = 0;\n\n  /** The applied local shearX. */\n  ashearX = 0;\n\n  /** The applied local shearY. */\n  ashearY = 0;\n\n  /** Part of the world transform matrix for the X axis. If changed, {@link #updateAppliedTransform()} should be called. */\n  a = 0;\n\n  /** Part of the world transform matrix for the Y axis. If changed, {@link #updateAppliedTransform()} should be called. */\n  b = 0;\n\n  /** Part of the world transform matrix for the X axis. If changed, {@link #updateAppliedTransform()} should be called. */\n  c = 0;\n\n  /** Part of the world transform matrix for the Y axis. If changed, {@link #updateAppliedTransform()} should be called. */\n  d = 0;\n\n  /** The world X position. If changed, {@link #updateAppliedTransform()} should be called. */\n  worldY = 0;\n\n  /** The world Y position. If changed, {@link #updateAppliedTransform()} should be called. */\n  worldX = 0;\n\n  sorted = false;\n  active = false;\n\n  /** @param parent May be null. */\n  constructor(data: BoneData, skeleton: Skeleton, parent: Bone | null) {\n    if (!data) throw new Error('data cannot be null.');\n    if (!skeleton) throw new Error('skeleton cannot be null.');\n    this.data = data;\n    this.skeleton = skeleton;\n    this.parent = parent;\n    this.setToSetupPose();\n  }\n\n  /** Returns false when the bone has not been computed because {@link BoneData#skinRequired} is true and the\n   * {@link Skeleton#skin active skin} does not {@link Skin#bones contain} this bone. */\n  isActive() {\n    return this.active;\n  }\n\n  /** Computes the world transform using the parent bone and this bone's local applied transform. */\n  update() {\n    this.updateWorldTransformWith(\n      this.ax,\n      this.ay,\n      this.arotation,\n      this.ascaleX,\n      this.ascaleY,\n      this.ashearX,\n      this.ashearY,\n    );\n  }\n\n  /** Computes the world transform using the parent bone and this bone's local transform.\n   *\n   * See {@link #updateWorldTransformWith()}. */\n  updateWorldTransform() {\n    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n  }\n\n  /** Computes the world transform using the parent bone and the specified local transform. The applied transform is set to the\n   * specified local transform. Child bones are not updated.\n   *\n   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n   * Runtimes Guide. */\n  updateWorldTransformWith(\n    x: number,\n    y: number,\n    rotation: number,\n    scaleX: number,\n    scaleY: number,\n    shearX: number,\n    shearY: number,\n  ) {\n    this.ax = x;\n    this.ay = y;\n    this.arotation = rotation;\n    this.ascaleX = scaleX;\n    this.ascaleY = scaleY;\n    this.ashearX = shearX;\n    this.ashearY = shearY;\n\n    const parent = this.parent;\n    if (!parent) {\n      // Root bone.\n      const skeleton = this.skeleton;\n      const rotationY = rotation + 90 + shearY;\n      const sx = skeleton.scaleX;\n      const sy = skeleton.scaleY;\n      this.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n      this.b = MathUtils.cosDeg(rotationY) * scaleY * sx;\n      this.c = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\n      this.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\n      this.worldX = x * sx + skeleton.x;\n      this.worldY = y * sy + skeleton.y;\n      return;\n    }\n\n    let pa = parent.a,\n      pb = parent.b,\n      pc = parent.c,\n      pd = parent.d;\n    this.worldX = pa * x + pb * y + parent.worldX;\n    this.worldY = pc * x + pd * y + parent.worldY;\n\n    switch (this.data.transformMode) {\n      case TransformMode.Normal: {\n        const rotationY = rotation + 90 + shearY;\n        const la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n        const lb = MathUtils.cosDeg(rotationY) * scaleY;\n        const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n        const ld = MathUtils.sinDeg(rotationY) * scaleY;\n        this.a = pa * la + pb * lc;\n        this.b = pa * lb + pb * ld;\n        this.c = pc * la + pd * lc;\n        this.d = pc * lb + pd * ld;\n        return;\n      }\n      case TransformMode.OnlyTranslation: {\n        const rotationY = rotation + 90 + shearY;\n        this.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n        this.b = MathUtils.cosDeg(rotationY) * scaleY;\n        this.c = MathUtils.sinDeg(rotation + shearX) * scaleX;\n        this.d = MathUtils.sinDeg(rotationY) * scaleY;\n        break;\n      }\n      case TransformMode.NoRotationOrReflection: {\n        let s = pa * pa + pc * pc;\n        let prx = 0;\n        if (s > 0.0001) {\n          s = Math.abs(pa * pd - pb * pc) / s;\n          pa /= this.skeleton.scaleX;\n          pc /= this.skeleton.scaleY;\n          pb = pc * s;\n          pd = pa * s;\n          prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n        } else {\n          pa = 0;\n          pc = 0;\n          prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n        }\n        const rx = rotation + shearX - prx;\n        const ry = rotation + shearY - prx + 90;\n        const la = MathUtils.cosDeg(rx) * scaleX;\n        const lb = MathUtils.cosDeg(ry) * scaleY;\n        const lc = MathUtils.sinDeg(rx) * scaleX;\n        const ld = MathUtils.sinDeg(ry) * scaleY;\n        this.a = pa * la - pb * lc;\n        this.b = pa * lb - pb * ld;\n        this.c = pc * la + pd * lc;\n        this.d = pc * lb + pd * ld;\n        break;\n      }\n      case TransformMode.NoScale:\n      case TransformMode.NoScaleOrReflection: {\n        const cos = MathUtils.cosDeg(rotation);\n        const sin = MathUtils.sinDeg(rotation);\n        let za = (pa * cos + pb * sin) / this.skeleton.scaleX;\n        let zc = (pc * cos + pd * sin) / this.skeleton.scaleY;\n        let s = Math.sqrt(za * za + zc * zc);\n        if (s > 0.00001) s = 1 / s;\n        za *= s;\n        zc *= s;\n        s = Math.sqrt(za * za + zc * zc);\n        if (\n          this.data.transformMode == TransformMode.NoScale &&\n          pa * pd - pb * pc < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0)\n        )\n          s = -s;\n        const r = Math.PI / 2 + Math.atan2(zc, za);\n        const zb = Math.cos(r) * s;\n        const zd = Math.sin(r) * s;\n        const la = MathUtils.cosDeg(shearX) * scaleX;\n        const lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n        const lc = MathUtils.sinDeg(shearX) * scaleX;\n        const ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n        this.a = za * la + zb * lc;\n        this.b = za * lb + zb * ld;\n        this.c = zc * la + zd * lc;\n        this.d = zc * lb + zd * ld;\n        break;\n      }\n    }\n    this.a *= this.skeleton.scaleX;\n    this.b *= this.skeleton.scaleX;\n    this.c *= this.skeleton.scaleY;\n    this.d *= this.skeleton.scaleY;\n  }\n\n  /** Sets this bone's local transform to the setup pose. */\n  setToSetupPose() {\n    const data = this.data;\n    this.x = data.x;\n    this.y = data.y;\n    this.rotation = data.rotation;\n    this.scaleX = data.scaleX;\n    this.scaleY = data.scaleY;\n    this.shearX = data.shearX;\n    this.shearY = data.shearY;\n  }\n\n  /** The world rotation for the X axis, calculated using {@link #a} and {@link #c}. */\n  getWorldRotationX() {\n    return Math.atan2(this.c, this.a) * MathUtils.radDeg;\n  }\n\n  /** The world rotation for the Y axis, calculated using {@link #b} and {@link #d}. */\n  getWorldRotationY() {\n    return Math.atan2(this.d, this.b) * MathUtils.radDeg;\n  }\n\n  /** The magnitude (always positive) of the world scale X, calculated using {@link #a} and {@link #c}. */\n  getWorldScaleX() {\n    return Math.sqrt(this.a * this.a + this.c * this.c);\n  }\n\n  /** The magnitude (always positive) of the world scale Y, calculated using {@link #b} and {@link #d}. */\n  getWorldScaleY() {\n    return Math.sqrt(this.b * this.b + this.d * this.d);\n  }\n\n  /** Computes the applied transform values from the world transform.\n   *\n   * If the world transform is modified (by a constraint, {@link #rotateWorld(float)}, etc) then this method should be called so\n   * the applied transform matches the world transform. The applied transform may be needed by other code (eg to apply other\n   * constraints).\n   *\n   * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after\n   * calling this method is equivalent to the local transform used to compute the world transform, but may not be identical. */\n  updateAppliedTransform() {\n    const parent = this.parent;\n    if (!parent) {\n      this.ax = this.worldX - this.skeleton.x;\n      this.ay = this.worldY - this.skeleton.y;\n      this.arotation = Math.atan2(this.c, this.a) * MathUtils.radDeg;\n      this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);\n      this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);\n      this.ashearX = 0;\n      this.ashearY =\n        Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * MathUtils.radDeg;\n      return;\n    }\n    const pa = parent.a,\n      pb = parent.b,\n      pc = parent.c,\n      pd = parent.d;\n    const pid = 1 / (pa * pd - pb * pc);\n    const dx = this.worldX - parent.worldX,\n      dy = this.worldY - parent.worldY;\n    this.ax = dx * pd * pid - dy * pb * pid;\n    this.ay = dy * pa * pid - dx * pc * pid;\n    const ia = pid * pd;\n    const id = pid * pa;\n    const ib = pid * pb;\n    const ic = pid * pc;\n    const ra = ia * this.a - ib * this.c;\n    const rb = ia * this.b - ib * this.d;\n    const rc = id * this.c - ic * this.a;\n    const rd = id * this.d - ic * this.b;\n    this.ashearX = 0;\n    this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n    if (this.ascaleX > 0.0001) {\n      const det = ra * rd - rb * rc;\n      this.ascaleY = det / this.ascaleX;\n      this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n      this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n    } else {\n      this.ascaleX = 0;\n      this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n      this.ashearY = 0;\n      this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n    }\n  }\n\n  /** Transforms a point from world coordinates to the bone's local coordinates. */\n  worldToLocal(world: Vector2) {\n    const invDet = 1 / (this.a * this.d - this.b * this.c);\n    const x = world.x - this.worldX,\n      y = world.y - this.worldY;\n    world.x = x * this.d * invDet - y * this.b * invDet;\n    world.y = y * this.a * invDet - x * this.c * invDet;\n    return world;\n  }\n\n  /** Transforms a point from the bone's local coordinates to world coordinates. */\n  localToWorld(local: Vector2) {\n    const x = local.x,\n      y = local.y;\n    local.x = x * this.a + y * this.b + this.worldX;\n    local.y = x * this.c + y * this.d + this.worldY;\n    return local;\n  }\n\n  /** Transforms a world rotation to a local rotation. */\n  worldToLocalRotation(worldRotation: number) {\n    const sin = MathUtils.sinDeg(worldRotation),\n      cos = MathUtils.cosDeg(worldRotation);\n    return (\n      Math.atan2(this.a * sin - this.c * cos, this.d * cos - this.b * sin) * MathUtils.radDeg +\n      this.rotation -\n      this.shearX\n    );\n  }\n\n  /** Transforms a local rotation to a world rotation. */\n  localToWorldRotation(localRotation: number) {\n    localRotation -= this.rotation - this.shearX;\n    const sin = MathUtils.sinDeg(localRotation),\n      cos = MathUtils.cosDeg(localRotation);\n    return Math.atan2(cos * this.c + sin * this.d, cos * this.a + sin * this.b) * MathUtils.radDeg;\n  }\n\n  /** Rotates the world transform the specified amount.\n   * <p>\n   * After changes are made to the world transform, {@link #updateAppliedTransform()} should be called and {@link #update()} will\n   * need to be called on any child bones, recursively. */\n  rotateWorld(degrees: number) {\n    const a = this.a,\n      b = this.b,\n      c = this.c,\n      d = this.d;\n    const cos = MathUtils.cosDeg(degrees),\n      sin = MathUtils.sinDeg(degrees);\n    this.a = cos * a - sin * c;\n    this.b = cos * b - sin * d;\n    this.c = sin * a + cos * c;\n    this.d = sin * b + cos * d;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\n/** The base class for all constraint datas. */\nexport abstract class ConstraintData {\n\tconstructor (public name: string, public order: number, public skinRequired: boolean) { }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { EventData } from './EventData';\n\n/** Stores the current pose values for an {@link Event}.\n *\n * See Timeline {@link Timeline#apply()},\n * AnimationStateListener {@link AnimationStateListener#event()}, and\n * [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide. */\nexport class Event {\n  data: EventData;\n  intValue: number = 0;\n  floatValue: number = 0;\n  stringValue: string | null = null;\n  time: number = 0;\n  volume: number = 0;\n  balance: number = 0;\n\n  constructor(time: number, data: EventData) {\n    if (!data) throw new Error('data cannot be null.');\n    this.time = time;\n    this.data = data;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\n/** Stores the setup pose values for an {@link Event}.\n *\n * See [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide. */\nexport class EventData {\n\tname: string;\n\tintValue: number = 0;\n\tfloatValue: number = 0;\n\tstringValue: string | null = null;\n\taudioPath: string | null = null;\n\tvolume: number = 0;\n\tbalance: number = 0;\n\n\tconstructor (name: string) {\n\t\tthis.name = name;\n\t}\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Bone } from './Bone';\nimport { TransformMode } from './BoneData';\nimport { IkConstraintData } from './IkConstraintData';\nimport { Skeleton } from './Skeleton';\nimport { Updatable } from './Updatable';\nimport { MathUtils } from './Utils';\n\n/** Stores the current pose for an IK constraint. An IK constraint adjusts the rotation of 1 or 2 constrained bones so the tip of\n * the last bone is as close to the target bone as possible.\n *\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide. */\nexport class IkConstraint implements Updatable {\n  /** The IK constraint's setup pose data. */\n  data: IkConstraintData;\n\n  /** The bones that will be modified by this IK constraint. */\n  bones: Array<Bone>;\n\n  /** The bone that is the IK target. */\n  target: Bone;\n\n  /** Controls the bend direction of the IK bones, either 1 or -1. */\n  bendDirection = 0;\n\n  /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\n  compress = false;\n\n  /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\n   * and the parent bone has local nonuniform scale, stretch is not applied. */\n  stretch = false;\n\n  /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\n  mix = 1;\n\n  /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\n  softness = 0;\n  active = false;\n\n  constructor(data: IkConstraintData, skeleton: Skeleton) {\n    if (!data) throw new Error('data cannot be null.');\n    if (!skeleton) throw new Error('skeleton cannot be null.');\n    this.data = data;\n    this.mix = data.mix;\n    this.softness = data.softness;\n    this.bendDirection = data.bendDirection;\n    this.compress = data.compress;\n    this.stretch = data.stretch;\n\n    this.bones = new Array<Bone>();\n    for (let i = 0; i < data.bones.length; i++) {\n      const bone = skeleton.findBone(data.bones[i].name);\n      if (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}`);\n      this.bones.push(bone);\n    }\n    const target = skeleton.findBone(data.target.name);\n    if (!target) throw new Error(`Couldn't find bone ${data.target.name}`);\n    this.target = target;\n  }\n\n  isActive() {\n    return this.active;\n  }\n\n  update() {\n    if (this.mix == 0) return;\n    const target = this.target;\n    const bones = this.bones;\n    switch (bones.length) {\n      case 1:\n        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n        break;\n      case 2:\n        this.apply2(\n          bones[0],\n          bones[1],\n          target.worldX,\n          target.worldY,\n          this.bendDirection,\n          this.stretch,\n          this.data.uniform,\n          this.softness,\n          this.mix,\n        );\n        break;\n    }\n  }\n\n  /** Applies 1 bone IK. The target is specified in the world coordinate system. */\n  apply1(\n    bone: Bone,\n    targetX: number,\n    targetY: number,\n    compress: boolean,\n    stretch: boolean,\n    uniform: boolean,\n    alpha: number,\n  ) {\n    const p = bone.parent;\n    if (!p) throw new Error('IK bone must have parent.');\n    let pa = p.a,\n      pb = p.b,\n      pc = p.c,\n      pd = p.d;\n    let rotationIK = -bone.ashearX - bone.arotation,\n      tx = 0,\n      ty = 0;\n\n    switch (bone.data.transformMode) {\n      case TransformMode.OnlyTranslation:\n        tx = (targetX - bone.worldX) * MathUtils.signum(bone.skeleton.scaleX);\n        ty = (targetY - bone.worldY) * MathUtils.signum(bone.skeleton.scaleY);\n        break;\n      case TransformMode.NoRotationOrReflection:\n        const s = Math.abs(pa * pd - pb * pc) / Math.max(0.0001, pa * pa + pc * pc);\n        const sa = pa / bone.skeleton.scaleX;\n        const sc = pc / bone.skeleton.scaleY;\n        pb = -sc * s * bone.skeleton.scaleX;\n        pd = sa * s * bone.skeleton.scaleY;\n        rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\n      // Fall through\n      default:\n        const x = targetX - p.worldX,\n          y = targetY - p.worldY;\n        const d = pa * pd - pb * pc;\n        if (Math.abs(d) <= 0.0001) {\n          tx = 0;\n          ty = 0;\n        } else {\n          tx = (x * pd - y * pb) / d - bone.ax;\n          ty = (y * pa - x * pc) / d - bone.ay;\n        }\n    }\n    rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\n    if (bone.ascaleX < 0) rotationIK += 180;\n    if (rotationIK > 180) rotationIK -= 360;\n    else if (rotationIK < -180) rotationIK += 360;\n    let sx = bone.ascaleX,\n      sy = bone.ascaleY;\n    if (compress || stretch) {\n      switch (bone.data.transformMode) {\n        case TransformMode.NoScale:\n        case TransformMode.NoScaleOrReflection:\n          tx = targetX - bone.worldX;\n          ty = targetY - bone.worldY;\n      }\n      const b = bone.data.length * sx,\n        dd = Math.sqrt(tx * tx + ty * ty);\n      if ((compress && dd < b) || (stretch && dd > b && b > 0.0001)) {\n        const s = (dd / b - 1) * alpha + 1;\n        sx *= s;\n        if (uniform) sy *= s;\n      }\n    }\n    bone.updateWorldTransformWith(\n      bone.ax,\n      bone.ay,\n      bone.arotation + rotationIK * alpha,\n      sx,\n      sy,\n      bone.ashearX,\n      bone.ashearY,\n    );\n  }\n\n  /** Applies 2 bone IK. The target is specified in the world coordinate system.\n   * @param child A direct descendant of the parent bone. */\n  apply2(\n    parent: Bone,\n    child: Bone,\n    targetX: number,\n    targetY: number,\n    bendDir: number,\n    stretch: boolean,\n    uniform: boolean,\n    softness: number,\n    alpha: number,\n  ) {\n    let px = parent.ax,\n      py = parent.ay,\n      psx = parent.ascaleX,\n      psy = parent.ascaleY,\n      sx = psx,\n      sy = psy,\n      csx = child.ascaleX;\n    let os1 = 0,\n      os2 = 0,\n      s2 = 0;\n    if (psx < 0) {\n      psx = -psx;\n      os1 = 180;\n      s2 = -1;\n    } else {\n      os1 = 0;\n      s2 = 1;\n    }\n    if (psy < 0) {\n      psy = -psy;\n      s2 = -s2;\n    }\n    if (csx < 0) {\n      csx = -csx;\n      os2 = 180;\n    } else os2 = 0;\n    let cx = child.ax,\n      cy = 0,\n      cwx = 0,\n      cwy = 0,\n      a = parent.a,\n      b = parent.b,\n      c = parent.c,\n      d = parent.d;\n    const u = Math.abs(psx - psy) <= 0.0001;\n    if (!u || stretch) {\n      cy = 0;\n      cwx = a * cx + parent.worldX;\n      cwy = c * cx + parent.worldY;\n    } else {\n      cy = child.ay;\n      cwx = a * cx + b * cy + parent.worldX;\n      cwy = c * cx + d * cy + parent.worldY;\n    }\n    const pp = parent.parent;\n    if (!pp) throw new Error('IK parent must itself have a parent.');\n    a = pp.a;\n    b = pp.b;\n    c = pp.c;\n    d = pp.d;\n    let id = a * d - b * c,\n      x = cwx - pp.worldX,\n      y = cwy - pp.worldY;\n    id = Math.abs(id) <= 0.0001 ? 0 : 1 / id;\n    const dx = (x * d - y * b) * id - px,\n      dy = (y * a - x * c) * id - py;\n    let l1 = Math.sqrt(dx * dx + dy * dy),\n      l2 = child.data.length * csx,\n      a1,\n      a2;\n    if (l1 < 0.0001) {\n      this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\n      child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n      return;\n    }\n    x = targetX - pp.worldX;\n    y = targetY - pp.worldY;\n    let tx = (x * d - y * b) * id - px,\n      ty = (y * a - x * c) * id - py;\n    let dd = tx * tx + ty * ty;\n    if (softness != 0) {\n      softness *= psx * (csx + 1) * 0.5;\n      const td = Math.sqrt(dd),\n        sd = td - l1 - l2 * psx + softness;\n      if (sd > 0) {\n        let p = Math.min(1, sd / (softness * 2)) - 1;\n        p = (sd - softness * (1 - p * p)) / td;\n        tx -= p * tx;\n        ty -= p * ty;\n        dd = tx * tx + ty * ty;\n      }\n    }\n    outer: if (u) {\n      l2 *= psx;\n      let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n      if (cos < -1) {\n        cos = -1;\n        a2 = Math.PI * bendDir;\n      } else if (cos > 1) {\n        cos = 1;\n        a2 = 0;\n        if (stretch) {\n          a = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n          sx *= a;\n          if (uniform) sy *= a;\n        }\n      } else a2 = Math.acos(cos) * bendDir;\n      a = l1 + l2 * cos;\n      b = l2 * Math.sin(a2);\n      a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n    } else {\n      a = psx * l2;\n      b = psy * l2;\n      const aa = a * a,\n        bb = b * b,\n        ta = Math.atan2(ty, tx);\n      c = bb * l1 * l1 + aa * dd - aa * bb;\n      const c1 = -2 * bb * l1,\n        c2 = bb - aa;\n      d = c1 * c1 - 4 * c2 * c;\n      if (d >= 0) {\n        let q = Math.sqrt(d);\n        if (c1 < 0) q = -q;\n        q = -(c1 + q) * 0.5;\n        const r0 = q / c2,\n          r1 = c / q;\n        const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n        if (r * r <= dd) {\n          y = Math.sqrt(dd - r * r) * bendDir;\n          a1 = ta - Math.atan2(y, r);\n          a2 = Math.atan2(y / psy, (r - l1) / psx);\n          break outer;\n        }\n      }\n      let minAngle = MathUtils.PI,\n        minX = l1 - a,\n        minDist = minX * minX,\n        minY = 0;\n      let maxAngle = 0,\n        maxX = l1 + a,\n        maxDist = maxX * maxX,\n        maxY = 0;\n      c = (-a * l1) / (aa - bb);\n      if (c >= -1 && c <= 1) {\n        c = Math.acos(c);\n        x = a * Math.cos(c) + l1;\n        y = b * Math.sin(c);\n        d = x * x + y * y;\n        if (d < minDist) {\n          minAngle = c;\n          minDist = d;\n          minX = x;\n          minY = y;\n        }\n        if (d > maxDist) {\n          maxAngle = c;\n          maxDist = d;\n          maxX = x;\n          maxY = y;\n        }\n      }\n      if (dd <= (minDist + maxDist) * 0.5) {\n        a1 = ta - Math.atan2(minY * bendDir, minX);\n        a2 = minAngle * bendDir;\n      } else {\n        a1 = ta - Math.atan2(maxY * bendDir, maxX);\n        a2 = maxAngle * bendDir;\n      }\n    }\n    const os = Math.atan2(cy, cx) * s2;\n    let rotation = parent.arotation;\n    a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n    if (a1 > 180) a1 -= 360;\n    else if (a1 < -180)\n      //\n      a1 += 360;\n    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, sy, 0, 0);\n    rotation = child.arotation;\n    a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n    if (a2 > 180) a2 -= 360;\n    else if (a2 < -180)\n      //\n      a2 += 360;\n    child.updateWorldTransformWith(\n      cx,\n      cy,\n      rotation + a2 * alpha,\n      child.ascaleX,\n      child.ascaleY,\n      child.ashearX,\n      child.ashearY,\n    );\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { BoneData } from './BoneData';\nimport { ConstraintData } from './ConstraintData';\n\n/** Stores the setup pose for an {@link IkConstraint}.\n * <p>\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide. */\nexport class IkConstraintData extends ConstraintData {\n  /** The bones that are constrained by this IK constraint. */\n  bones = new Array<BoneData>();\n  /** Controls the bend direction of the IK bones, either 1 or -1. */\n  bendDirection = 1;\n  /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\n  compress = false;\n  /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\n   * and the parent bone has local nonuniform scale, stretch is not applied. */\n  stretch = false;\n  /** When true, only a single bone is being constrained, and {@link #getCompress()} or {@link #getStretch()} is used, the bone\n   * is scaled on both the X and Y axes. */\n  uniform = false;\n  /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\n  mix = 1;\n  /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\n  softness = 0;\n  /** The bone that is the IK target. */\n  private _target: BoneData | null = null;\n\n  constructor(name: string) {\n    super(name, 0, false);\n  }\n\n  public get target() {\n    if (!this._target) throw new Error('BoneData not set.');\n    else return this._target;\n  }\n\n  public set target(boneData: BoneData) {\n    this._target = boneData;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { BoneData } from './BoneData';\nimport { ConstraintData } from './ConstraintData';\nimport { SlotData } from './SlotData';\n\n/** Stores the setup pose for a {@link PathConstraint}.\n *\n * See [path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide. */\nexport class PathConstraintData extends ConstraintData {\n  /** The bones that will be modified by this path constraint. */\n  bones = new Array<BoneData>();\n  /** The mode for positioning the first bone on the path. */\n  positionMode: PositionMode = PositionMode.Fixed;\n  /** The mode for positioning the bones after the first bone on the path. */\n  spacingMode: SpacingMode = SpacingMode.Fixed;\n  /** The mode for adjusting the rotation of the bones. */\n  rotateMode: RotateMode = RotateMode.Chain;\n  /** An offset added to the constrained bone rotation. */\n  offsetRotation: number = 0;\n  /** The position along the path. */\n  position: number = 0;\n  /** The spacing between bones. */\n  spacing: number = 0;\n  mixRotate = 0;\n  mixX = 0;\n  mixY = 0;\n  /** The slot whose path attachment will be used to constrained the bones. */\n  private _target: SlotData | null = null;\n\n  constructor(name: string) {\n    super(name, 0, false);\n  }\n\n  public get target() {\n    if (!this._target) throw new Error('SlotData not set.');\n    else return this._target;\n  }\n\n  public set target(slotData: SlotData) {\n    this._target = slotData;\n  }\n}\n\n/** Controls how the first bone is positioned along the path.\n *\n * See [position](http://esotericsoftware.com/spine-path-constraints#Position) in the Spine User Guide. */\nexport enum PositionMode {\n  Fixed,\n  Percent,\n}\n\n/** Controls how bones after the first bone are positioned along the path.\n *\n * See [spacing](http://esotericsoftware.com/spine-path-constraints#Spacing) in the Spine User Guide. */\nexport enum SpacingMode {\n  Length,\n  Fixed,\n  Percent,\n  Proportional,\n}\n\n/** Controls how bones are rotated, translated, and scaled to match the path.\n *\n * See [rotate mix](http://esotericsoftware.com/spine-path-constraints#Rotate-mix) in the Spine User Guide. */\nexport enum RotateMode {\n  Tangent,\n  Chain,\n  ChainScale,\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { PathAttachment } from './attachments/PathAttachment';\nimport { Bone } from './Bone';\nimport { PathConstraintData, PositionMode, RotateMode, SpacingMode } from './PathConstraintData';\nimport { Skeleton } from './Skeleton';\nimport { Slot } from './Slot';\nimport { Updatable } from './Updatable';\nimport { MathUtils, Utils } from './Utils';\n\n/** Stores the current pose for a path constraint. A path constraint adjusts the rotation, translation, and scale of the\n * constrained bones so they follow a {@link PathAttachment}.\n *\n * See [Path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide. */\nexport class PathConstraint implements Updatable {\n  static NONE = -1;\n  static BEFORE = -2;\n  static AFTER = -3;\n  static epsilon = 0.00001;\n\n  /** The path constraint's setup pose data. */\n  data: PathConstraintData;\n\n  /** The bones that will be modified by this path constraint. */\n  bones: Array<Bone>;\n\n  /** The slot whose path attachment will be used to constrained the bones. */\n  target: Slot;\n\n  /** The position along the path. */\n  position = 0;\n\n  /** The spacing between bones. */\n  spacing = 0;\n\n  mixRotate = 0;\n\n  mixX = 0;\n\n  mixY = 0;\n\n  spaces = new Array<number>();\n  positions = new Array<number>();\n  world = new Array<number>();\n  curves = new Array<number>();\n  lengths = new Array<number>();\n  segments = new Array<number>();\n\n  active = false;\n\n  constructor(data: PathConstraintData, skeleton: Skeleton) {\n    if (!data) throw new Error('data cannot be null.');\n    if (!skeleton) throw new Error('skeleton cannot be null.');\n    this.data = data;\n    this.bones = new Array<Bone>();\n    for (let i = 0, n = data.bones.length; i < n; i++) {\n      const bone = skeleton.findBone(data.bones[i].name);\n      if (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}.`);\n      this.bones.push(bone);\n    }\n    const target = skeleton.findSlot(data.target.name);\n    if (!target) throw new Error(`Couldn't find target bone ${data.target.name}`);\n    this.target = target;\n    this.position = data.position;\n    this.spacing = data.spacing;\n    this.mixRotate = data.mixRotate;\n    this.mixX = data.mixX;\n    this.mixY = data.mixY;\n  }\n\n  isActive() {\n    return this.active;\n  }\n\n  update() {\n    const attachment = this.target.getAttachment();\n    if (!(attachment instanceof PathAttachment)) return;\n\n    const mixRotate = this.mixRotate,\n      mixX = this.mixX,\n      mixY = this.mixY;\n    if (mixRotate == 0 && mixX == 0 && mixY == 0) return;\n\n    const data = this.data;\n    const tangents = data.rotateMode == RotateMode.Tangent,\n      scale = data.rotateMode == RotateMode.ChainScale;\n\n    const bones = this.bones;\n    const boneCount = bones.length,\n      spacesCount = tangents ? boneCount : boneCount + 1;\n    const spaces = Utils.setArraySize(this.spaces, spacesCount),\n      lengths: Array<number> = scale ? (this.lengths = Utils.setArraySize(this.lengths, boneCount)) : [];\n    const spacing = this.spacing;\n\n    switch (data.spacingMode) {\n      case SpacingMode.Percent:\n        if (scale) {\n          for (let i = 0, n = spacesCount - 1; i < n; i++) {\n            const bone = bones[i];\n            const setupLength = bone.data.length;\n            if (setupLength < PathConstraint.epsilon) lengths[i] = 0;\n            else {\n              const x = setupLength * bone.a,\n                y = setupLength * bone.c;\n              lengths[i] = Math.sqrt(x * x + y * y);\n            }\n          }\n        }\n        Utils.arrayFill(spaces, 1, spacesCount, spacing);\n        break;\n      case SpacingMode.Proportional:\n        let sum = 0;\n        for (let i = 0, n = spacesCount - 1; i < n; ) {\n          const bone = bones[i];\n          const setupLength = bone.data.length;\n          if (setupLength < PathConstraint.epsilon) {\n            if (scale) lengths[i] = 0;\n            spaces[++i] = spacing;\n          } else {\n            const x = setupLength * bone.a,\n              y = setupLength * bone.c;\n            const length = Math.sqrt(x * x + y * y);\n            if (scale) lengths[i] = length;\n            spaces[++i] = length;\n            sum += length;\n          }\n        }\n        if (sum > 0) {\n          sum = (spacesCount / sum) * spacing;\n          for (let i = 1; i < spacesCount; i++) spaces[i] *= sum;\n        }\n        break;\n      default:\n        const lengthSpacing = data.spacingMode == SpacingMode.Length;\n        for (let i = 0, n = spacesCount - 1; i < n; ) {\n          const bone = bones[i];\n          const setupLength = bone.data.length;\n          if (setupLength < PathConstraint.epsilon) {\n            if (scale) lengths[i] = 0;\n            spaces[++i] = spacing;\n          } else {\n            const x = setupLength * bone.a,\n              y = setupLength * bone.c;\n            const length = Math.sqrt(x * x + y * y);\n            if (scale) lengths[i] = length;\n            spaces[++i] = ((lengthSpacing ? setupLength + spacing : spacing) * length) / setupLength;\n          }\n        }\n    }\n\n    const positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents);\n    let boneX = positions[0],\n      boneY = positions[1],\n      offsetRotation = data.offsetRotation;\n    let tip = false;\n    if (offsetRotation == 0) tip = data.rotateMode == RotateMode.Chain;\n    else {\n      tip = false;\n      const p = this.target.bone;\n      offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    }\n    for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n      const bone = bones[i];\n      bone.worldX += (boneX - bone.worldX) * mixX;\n      bone.worldY += (boneY - bone.worldY) * mixY;\n      const x = positions[p],\n        y = positions[p + 1],\n        dx = x - boneX,\n        dy = y - boneY;\n      if (scale) {\n        const length = lengths[i];\n        if (length != 0) {\n          const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * mixRotate + 1;\n          bone.a *= s;\n          bone.c *= s;\n        }\n      }\n      boneX = x;\n      boneY = y;\n      if (mixRotate > 0) {\n        let a = bone.a,\n          b = bone.b,\n          c = bone.c,\n          d = bone.d,\n          r = 0,\n          cos = 0,\n          sin = 0;\n        if (tangents) r = positions[p - 1];\n        else if (spaces[i + 1] == 0) r = positions[p + 2];\n        else r = Math.atan2(dy, dx);\n        r -= Math.atan2(c, a);\n        if (tip) {\n          cos = Math.cos(r);\n          sin = Math.sin(r);\n          const length = bone.data.length;\n          boneX += (length * (cos * a - sin * c) - dx) * mixRotate;\n          boneY += (length * (sin * a + cos * c) - dy) * mixRotate;\n        } else {\n          r += offsetRotation;\n        }\n        if (r > MathUtils.PI) r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          //\n          r += MathUtils.PI2;\n        r *= mixRotate;\n        cos = Math.cos(r);\n        sin = Math.sin(r);\n        bone.a = cos * a - sin * c;\n        bone.b = cos * b - sin * d;\n        bone.c = sin * a + cos * c;\n        bone.d = sin * b + cos * d;\n      }\n      bone.updateAppliedTransform();\n    }\n  }\n\n  computeWorldPositions(path: PathAttachment, spacesCount: number, tangents: boolean) {\n    const target = this.target;\n    let position = this.position;\n    let spaces = this.spaces,\n      out = Utils.setArraySize(this.positions, spacesCount * 3 + 2),\n      world: Array<number> = this.world;\n    const closed = path.closed;\n    let verticesLength = path.worldVerticesLength,\n      curveCount = verticesLength / 6,\n      prevCurve = PathConstraint.NONE;\n\n    if (!path.constantSpeed) {\n      const lengths = path.lengths;\n      curveCount -= closed ? 1 : 2;\n      const pathLength = lengths[curveCount];\n      if (this.data.positionMode == PositionMode.Percent) position *= pathLength;\n\n      let multiplier;\n      switch (this.data.spacingMode) {\n        case SpacingMode.Percent:\n          multiplier = pathLength;\n          break;\n        case SpacingMode.Proportional:\n          multiplier = pathLength / spacesCount;\n          break;\n        default:\n          multiplier = 1;\n      }\n      world = Utils.setArraySize(this.world, 8);\n      for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n        const space = spaces[i] * multiplier;\n        position += space;\n        let p = position;\n\n        if (closed) {\n          p %= pathLength;\n          if (p < 0) p += pathLength;\n          curve = 0;\n        } else if (p < 0) {\n          if (prevCurve != PathConstraint.BEFORE) {\n            prevCurve = PathConstraint.BEFORE;\n            path.computeWorldVertices(target, 2, 4, world, 0, 2);\n          }\n          this.addBeforePosition(p, world, 0, out, o);\n          continue;\n        } else if (p > pathLength) {\n          if (prevCurve != PathConstraint.AFTER) {\n            prevCurve = PathConstraint.AFTER;\n            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n          }\n          this.addAfterPosition(p - pathLength, world, 0, out, o);\n          continue;\n        }\n\n        // Determine curve containing position.\n        for (; ; curve++) {\n          const length = lengths[curve];\n          if (p > length) continue;\n          if (curve == 0) p /= length;\n          else {\n            const prev = lengths[curve - 1];\n            p = (p - prev) / (length - prev);\n          }\n          break;\n        }\n        if (curve != prevCurve) {\n          prevCurve = curve;\n          if (closed && curve == curveCount) {\n            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n            path.computeWorldVertices(target, 0, 4, world, 4, 2);\n          } else path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n        }\n        this.addCurvePosition(\n          p,\n          world[0],\n          world[1],\n          world[2],\n          world[3],\n          world[4],\n          world[5],\n          world[6],\n          world[7],\n          out,\n          o,\n          tangents || (i > 0 && space == 0),\n        );\n      }\n      return out;\n    }\n\n    // World vertices.\n    if (closed) {\n      verticesLength += 2;\n      world = Utils.setArraySize(this.world, verticesLength);\n      path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n      path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n      world[verticesLength - 2] = world[0];\n      world[verticesLength - 1] = world[1];\n    } else {\n      curveCount--;\n      verticesLength -= 4;\n      world = Utils.setArraySize(this.world, verticesLength);\n      path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n    }\n\n    // Curve lengths.\n    const curves = Utils.setArraySize(this.curves, curveCount);\n    let pathLength = 0;\n    let x1 = world[0],\n      y1 = world[1],\n      cx1 = 0,\n      cy1 = 0,\n      cx2 = 0,\n      cy2 = 0,\n      x2 = 0,\n      y2 = 0;\n    let tmpx = 0,\n      tmpy = 0,\n      dddfx = 0,\n      dddfy = 0,\n      ddfx = 0,\n      ddfy = 0,\n      dfx = 0,\n      dfy = 0;\n    for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n      cx1 = world[w];\n      cy1 = world[w + 1];\n      cx2 = world[w + 2];\n      cy2 = world[w + 3];\n      x2 = world[w + 4];\n      y2 = world[w + 5];\n      tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n      tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n      ddfx = tmpx * 2 + dddfx;\n      ddfy = tmpy * 2 + dddfy;\n      dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n      dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx;\n      dfy += ddfy;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx;\n      dfy += ddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx + dddfx;\n      dfy += ddfy + dddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      curves[i] = pathLength;\n      x1 = x2;\n      y1 = y2;\n    }\n\n    if (this.data.positionMode == PositionMode.Percent) position *= pathLength;\n\n    let multiplier;\n    switch (this.data.spacingMode) {\n      case SpacingMode.Percent:\n        multiplier = pathLength;\n        break;\n      case SpacingMode.Proportional:\n        multiplier = pathLength / spacesCount;\n        break;\n      default:\n        multiplier = 1;\n    }\n\n    const segments = this.segments;\n    let curveLength = 0;\n    for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n      const space = spaces[i] * multiplier;\n      position += space;\n      let p = position;\n\n      if (closed) {\n        p %= pathLength;\n        if (p < 0) p += pathLength;\n        curve = 0;\n      } else if (p < 0) {\n        this.addBeforePosition(p, world, 0, out, o);\n        continue;\n      } else if (p > pathLength) {\n        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n        continue;\n      }\n\n      // Determine curve containing position.\n      for (; ; curve++) {\n        const length = curves[curve];\n        if (p > length) continue;\n        if (curve == 0) p /= length;\n        else {\n          const prev = curves[curve - 1];\n          p = (p - prev) / (length - prev);\n        }\n        break;\n      }\n\n      // Curve segment lengths.\n      if (curve != prevCurve) {\n        prevCurve = curve;\n        let ii = curve * 6;\n        x1 = world[ii];\n        y1 = world[ii + 1];\n        cx1 = world[ii + 2];\n        cy1 = world[ii + 3];\n        cx2 = world[ii + 4];\n        cy2 = world[ii + 5];\n        x2 = world[ii + 6];\n        y2 = world[ii + 7];\n        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n        ddfx = tmpx * 2 + dddfx;\n        ddfy = tmpy * 2 + dddfy;\n        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[0] = curveLength;\n        for (ii = 1; ii < 8; ii++) {\n          dfx += ddfx;\n          dfy += ddfy;\n          ddfx += dddfx;\n          ddfy += dddfy;\n          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n          segments[ii] = curveLength;\n        }\n        dfx += ddfx;\n        dfy += ddfy;\n        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[8] = curveLength;\n        dfx += ddfx + dddfx;\n        dfy += ddfy + dddfy;\n        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[9] = curveLength;\n        segment = 0;\n      }\n\n      // Weight by segment length.\n      p *= curveLength;\n      for (; ; segment++) {\n        const length = segments[segment];\n        if (p > length) continue;\n        if (segment == 0) p /= length;\n        else {\n          const prev = segments[segment - 1];\n          p = segment + (p - prev) / (length - prev);\n        }\n        break;\n      }\n      this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\n    }\n    return out;\n  }\n\n  addBeforePosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n    const x1 = temp[i],\n      y1 = temp[i + 1],\n      dx = temp[i + 2] - x1,\n      dy = temp[i + 3] - y1,\n      r = Math.atan2(dy, dx);\n    out[o] = x1 + p * Math.cos(r);\n    out[o + 1] = y1 + p * Math.sin(r);\n    out[o + 2] = r;\n  }\n\n  addAfterPosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n    const x1 = temp[i + 2],\n      y1 = temp[i + 3],\n      dx = x1 - temp[i],\n      dy = y1 - temp[i + 1],\n      r = Math.atan2(dy, dx);\n    out[o] = x1 + p * Math.cos(r);\n    out[o + 1] = y1 + p * Math.sin(r);\n    out[o + 2] = r;\n  }\n\n  addCurvePosition(\n    p: number,\n    x1: number,\n    y1: number,\n    cx1: number,\n    cy1: number,\n    cx2: number,\n    cy2: number,\n    x2: number,\n    y2: number,\n    out: Array<number>,\n    o: number,\n    tangents: boolean,\n  ) {\n    if (p == 0 || isNaN(p)) {\n      out[o] = x1;\n      out[o + 1] = y1;\n      out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n      return;\n    }\n    const tt = p * p,\n      ttt = tt * p,\n      u = 1 - p,\n      uu = u * u,\n      uuu = uu * u;\n    const ut = u * p,\n      ut3 = ut * 3,\n      uut3 = u * ut3,\n      utt3 = ut3 * p;\n    const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt,\n      y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n    out[o] = x;\n    out[o + 1] = y;\n    if (tangents) {\n      if (p < 0.001) out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n      else out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n    }\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Attachment, VertexAttachment } from './attachments/Attachment';\nimport { Bone } from './Bone';\nimport { Skeleton } from './Skeleton';\nimport { SlotData } from './SlotData';\nimport { Color } from './Utils';\n\n/** Stores a slot's current pose. Slots organize attachments for {@link Skeleton#drawOrder} purposes and provide a place to store\n * state for an attachment. State cannot be stored in an attachment itself because attachments are stateless and may be shared\n * across multiple skeletons. */\nexport class Slot {\n  /** The slot's setup pose data. */\n  data: SlotData;\n\n  /** The bone this slot belongs to. */\n  bone: Bone;\n\n  /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\n   * color tinting. */\n  color: Color;\n\n  /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\n   * color's alpha is not used. */\n  darkColor: Color | null = null;\n\n  attachment: Attachment | null = null;\n\n  attachmentState: number = 0;\n\n  /** The index of the texture region to display when the slot's attachment has a {@link Sequence}. -1 represents the\n   * {@link Sequence#getSetupIndex()}. */\n  sequenceIndex: number = -1;\n\n  /** Values to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a\n   * weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.\n   *\n   * See {@link VertexAttachment#computeWorldVertices()} and {@link DeformTimeline}. */\n  deform = new Array<number>();\n\n  constructor(data: SlotData, bone: Bone) {\n    if (!data) throw new Error('data cannot be null.');\n    if (!bone) throw new Error('bone cannot be null.');\n    this.data = data;\n    this.bone = bone;\n    this.color = new Color();\n    this.darkColor = !data.darkColor ? null : new Color();\n    this.setToSetupPose();\n  }\n\n  /** The skeleton this slot belongs to. */\n  getSkeleton(): Skeleton {\n    return this.bone.skeleton;\n  }\n\n  /** The current attachment for the slot, or null if the slot has no attachment. */\n  getAttachment(): Attachment | null {\n    return this.attachment;\n  }\n\n  /** Sets the slot's attachment and, if the attachment changed, resets {@link #sequenceIndex} and clears the {@link #deform}.\n   * The deform is not cleared if the old attachment has the same {@link VertexAttachment#getTimelineAttachment()} as the\n   * specified attachment. */\n  setAttachment(attachment: Attachment | null) {\n    if (this.attachment == attachment) return;\n    if (\n      !(attachment instanceof VertexAttachment) ||\n      !(this.attachment instanceof VertexAttachment) ||\n      (<VertexAttachment>attachment).timelineAttachment != (<VertexAttachment>this.attachment).timelineAttachment\n    ) {\n      this.deform.length = 0;\n    }\n    this.attachment = attachment;\n    this.sequenceIndex = -1;\n  }\n\n  /** Sets this slot to the setup pose. */\n  setToSetupPose() {\n    this.color.setFromColor(this.data.color);\n    if (this.darkColor) this.darkColor.setFromColor(this.data.darkColor!);\n    if (!this.data.attachmentName) this.attachment = null;\n    else {\n      this.attachment = null;\n      this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n    }\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Bone } from './Bone';\nimport { Skeleton } from './Skeleton';\nimport { TransformConstraintData } from './TransformConstraintData';\nimport { Updatable } from './Updatable';\nimport { MathUtils, Vector2 } from './Utils';\n\n/** Stores the current pose for a transform constraint. A transform constraint adjusts the world transform of the constrained\n * bones to match that of the target bone.\n *\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide. */\nexport class TransformConstraint implements Updatable {\n  /** The transform constraint's setup pose data. */\n  data: TransformConstraintData;\n\n  /** The bones that will be modified by this transform constraint. */\n  bones: Array<Bone>;\n\n  /** The target bone whose world transform will be copied to the constrained bones. */\n  target: Bone;\n\n  mixRotate = 0;\n  mixX = 0;\n  mixY = 0;\n  mixScaleX = 0;\n  mixScaleY = 0;\n  mixShearY = 0;\n\n  temp = new Vector2();\n  active = false;\n\n  constructor(data: TransformConstraintData, skeleton: Skeleton) {\n    if (!data) throw new Error('data cannot be null.');\n    if (!skeleton) throw new Error('skeleton cannot be null.');\n    this.data = data;\n    this.mixRotate = data.mixRotate;\n    this.mixX = data.mixX;\n    this.mixY = data.mixY;\n    this.mixScaleX = data.mixScaleX;\n    this.mixScaleY = data.mixScaleY;\n    this.mixShearY = data.mixShearY;\n    this.bones = new Array<Bone>();\n    for (let i = 0; i < data.bones.length; i++) {\n      const bone = skeleton.findBone(data.bones[i].name);\n      if (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}.`);\n      this.bones.push(bone);\n    }\n    const target = skeleton.findBone(data.target.name);\n    if (!target) throw new Error(`Couldn't find target bone ${data.target.name}.`);\n    this.target = target;\n  }\n\n  isActive() {\n    return this.active;\n  }\n\n  update() {\n    if (\n      this.mixRotate == 0 &&\n      this.mixX == 0 &&\n      this.mixY == 0 &&\n      this.mixScaleX == 0 &&\n      this.mixScaleY == 0 &&\n      this.mixShearY == 0\n    )\n      return;\n\n    if (this.data.local) {\n      if (this.data.relative) this.applyRelativeLocal();\n      else this.applyAbsoluteLocal();\n    } else {\n      if (this.data.relative) this.applyRelativeWorld();\n      else this.applyAbsoluteWorld();\n    }\n  }\n\n  applyAbsoluteWorld() {\n    const mixRotate = this.mixRotate,\n      mixX = this.mixX,\n      mixY = this.mixY,\n      mixScaleX = this.mixScaleX,\n      mixScaleY = this.mixScaleY,\n      mixShearY = this.mixShearY;\n    const translate = mixX != 0 || mixY != 0;\n\n    const target = this.target;\n    const ta = target.a,\n      tb = target.b,\n      tc = target.c,\n      td = target.d;\n    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    const offsetRotation = this.data.offsetRotation * degRadReflect;\n    const offsetShearY = this.data.offsetShearY * degRadReflect;\n\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n\n      if (mixRotate != 0) {\n        const a = bone.a,\n          b = bone.b,\n          c = bone.c,\n          d = bone.d;\n        let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n        if (r > MathUtils.PI) r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          //\n          r += MathUtils.PI2;\n        r *= mixRotate;\n        const cos = Math.cos(r),\n          sin = Math.sin(r);\n        bone.a = cos * a - sin * c;\n        bone.b = cos * b - sin * d;\n        bone.c = sin * a + cos * c;\n        bone.d = sin * b + cos * d;\n      }\n\n      if (translate) {\n        const temp = this.temp;\n        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n        bone.worldX += (temp.x - bone.worldX) * mixX;\n        bone.worldY += (temp.y - bone.worldY) * mixY;\n      }\n\n      if (mixScaleX != 0) {\n        let s = Math.sqrt(bone.a * bone.a + bone.c * bone.c);\n        if (s != 0) s = (s + (Math.sqrt(ta * ta + tc * tc) - s + this.data.offsetScaleX) * mixScaleX) / s;\n        bone.a *= s;\n        bone.c *= s;\n      }\n      if (mixScaleY != 0) {\n        let s = Math.sqrt(bone.b * bone.b + bone.d * bone.d);\n        if (s != 0) s = (s + (Math.sqrt(tb * tb + td * td) - s + this.data.offsetScaleY) * mixScaleY) / s;\n        bone.b *= s;\n        bone.d *= s;\n      }\n\n      if (mixShearY > 0) {\n        const b = bone.b,\n          d = bone.d;\n        const by = Math.atan2(d, b);\n        let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(bone.c, bone.a));\n        if (r > MathUtils.PI) r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          //\n          r += MathUtils.PI2;\n        r = by + (r + offsetShearY) * mixShearY;\n        const s = Math.sqrt(b * b + d * d);\n        bone.b = Math.cos(r) * s;\n        bone.d = Math.sin(r) * s;\n      }\n\n      bone.updateAppliedTransform();\n    }\n  }\n\n  applyRelativeWorld() {\n    const mixRotate = this.mixRotate,\n      mixX = this.mixX,\n      mixY = this.mixY,\n      mixScaleX = this.mixScaleX,\n      mixScaleY = this.mixScaleY,\n      mixShearY = this.mixShearY;\n    const translate = mixX != 0 || mixY != 0;\n\n    const target = this.target;\n    const ta = target.a,\n      tb = target.b,\n      tc = target.c,\n      td = target.d;\n    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    const offsetRotation = this.data.offsetRotation * degRadReflect,\n      offsetShearY = this.data.offsetShearY * degRadReflect;\n\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n\n      if (mixRotate != 0) {\n        const a = bone.a,\n          b = bone.b,\n          c = bone.c,\n          d = bone.d;\n        let r = Math.atan2(tc, ta) + offsetRotation;\n        if (r > MathUtils.PI) r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          //\n          r += MathUtils.PI2;\n        r *= mixRotate;\n        const cos = Math.cos(r),\n          sin = Math.sin(r);\n        bone.a = cos * a - sin * c;\n        bone.b = cos * b - sin * d;\n        bone.c = sin * a + cos * c;\n        bone.d = sin * b + cos * d;\n      }\n\n      if (translate) {\n        const temp = this.temp;\n        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n        bone.worldX += temp.x * mixX;\n        bone.worldY += temp.y * mixY;\n      }\n\n      if (mixScaleX != 0) {\n        const s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * mixScaleX + 1;\n        bone.a *= s;\n        bone.c *= s;\n      }\n      if (mixScaleY != 0) {\n        const s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * mixScaleY + 1;\n        bone.b *= s;\n        bone.d *= s;\n      }\n\n      if (mixShearY > 0) {\n        let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n        if (r > MathUtils.PI) r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          //\n          r += MathUtils.PI2;\n        const b = bone.b,\n          d = bone.d;\n        r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * mixShearY;\n        const s = Math.sqrt(b * b + d * d);\n        bone.b = Math.cos(r) * s;\n        bone.d = Math.sin(r) * s;\n      }\n\n      bone.updateAppliedTransform();\n    }\n  }\n\n  applyAbsoluteLocal() {\n    const mixRotate = this.mixRotate,\n      mixX = this.mixX,\n      mixY = this.mixY,\n      mixScaleX = this.mixScaleX,\n      mixScaleY = this.mixScaleY,\n      mixShearY = this.mixShearY;\n\n    const target = this.target;\n\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n\n      let rotation = bone.arotation;\n      if (mixRotate != 0) {\n        let r = target.arotation - rotation + this.data.offsetRotation;\n        r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n        rotation += r * mixRotate;\n      }\n\n      let x = bone.ax,\n        y = bone.ay;\n      x += (target.ax - x + this.data.offsetX) * mixX;\n      y += (target.ay - y + this.data.offsetY) * mixY;\n\n      let scaleX = bone.ascaleX,\n        scaleY = bone.ascaleY;\n      if (mixScaleX != 0 && scaleX != 0)\n        scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;\n      if (mixScaleY != 0 && scaleY != 0)\n        scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;\n\n      let shearY = bone.ashearY;\n      if (mixShearY != 0) {\n        let r = target.ashearY - shearY + this.data.offsetShearY;\n        r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n        shearY += r * mixShearY;\n      }\n\n      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n    }\n  }\n\n  applyRelativeLocal() {\n    const mixRotate = this.mixRotate,\n      mixX = this.mixX,\n      mixY = this.mixY,\n      mixScaleX = this.mixScaleX,\n      mixScaleY = this.mixScaleY,\n      mixShearY = this.mixShearY;\n\n    const target = this.target;\n\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n\n      const rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;\n      const x = bone.ax + (target.ax + this.data.offsetX) * mixX;\n      const y = bone.ay + (target.ay + this.data.offsetY) * mixY;\n      const scaleX = bone.ascaleX * ((target.ascaleX - 1 + this.data.offsetScaleX) * mixScaleX + 1);\n      const scaleY = bone.ascaleY * ((target.ascaleY - 1 + this.data.offsetScaleY) * mixScaleY + 1);\n      const shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;\n\n      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n    }\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Attachment } from \"./attachments/Attachment\";\nimport { MeshAttachment } from \"./attachments/MeshAttachment\";\nimport { PathAttachment } from \"./attachments/PathAttachment\";\nimport { RegionAttachment } from \"./attachments/RegionAttachment\";\nimport { Bone } from \"./Bone\";\nimport { IkConstraint } from \"./IkConstraint\";\nimport { PathConstraint } from \"./PathConstraint\";\nimport { SkeletonData } from \"./SkeletonData\";\nimport { Skin } from \"./Skin\";\nimport { Slot } from \"./Slot\";\nimport { TransformConstraint } from \"./TransformConstraint\";\nimport { Updatable } from \"./Updatable\";\nimport { Color, Utils, MathUtils, Vector2, NumberArrayLike } from \"./Utils\";\n\n/** Stores the current pose for a skeleton.\n *\n * See [Instance objects](http://esotericsoftware.com/spine-runtime-architecture#Instance-objects) in the Spine Runtimes Guide. */\nexport class Skeleton {\n\tstatic yDown = false;\n\n\t/** The skeleton's setup pose data. */\n\tdata: SkeletonData;\n\n\t/** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\n\tbones: Array<Bone>;\n\n\t/** The skeleton's slots. */\n\tslots: Array<Slot>;\n\n\t/** The skeleton's slots in the order they should be drawn. The returned array may be modified to change the draw order. */\n\tdrawOrder: Array<Slot>;\n\n\t/** The skeleton's IK constraints. */\n\tikConstraints: Array<IkConstraint>;\n\n\t/** The skeleton's transform constraints. */\n\ttransformConstraints: Array<TransformConstraint>;\n\n\t/** The skeleton's path constraints. */\n\tpathConstraints: Array<PathConstraint>;\n\n\t/** The list of bones and constraints, sorted in the order they should be updated, as computed by {@link #updateCache()}. */\n\t_updateCache = new Array<Updatable>();\n\n\t/** The skeleton's current skin. May be null. */\n\tskin: Skin | null = null;\n\n\t/** The color to tint all the skeleton's attachments. */\n\tcolor: Color;\n\n\t/** Scales the entire skeleton on the X axis. This affects all bones, even if the bone's transform mode disallows scale\n\t  * inheritance. */\n\tscaleX = 1;\n\n\t/** Scales the entire skeleton on the Y axis. This affects all bones, even if the bone's transform mode disallows scale\n\t  * inheritance. */\n\tprivate _scaleY = 1;\n\n\tpublic get scaleY () {\n\t\treturn Skeleton.yDown ? -this._scaleY : this._scaleY;\n\t}\n\n\tpublic set scaleY (scaleY: number) {\n\t\tthis._scaleY = scaleY;\n\t}\n\n\t/** Sets the skeleton X position, which is added to the root bone worldX position. */\n\tx = 0;\n\n\t/** Sets the skeleton Y position, which is added to the root bone worldY position. */\n\ty = 0;\n\n\tconstructor (data: SkeletonData) {\n\t\tif (!data) throw new Error(\"data cannot be null.\");\n\t\tthis.data = data;\n\n\t\tthis.bones = new Array<Bone>();\n\t\tfor (let i = 0; i < data.bones.length; i++) {\n\t\t\tconst boneData = data.bones[i];\n\t\t\tlet bone: Bone;\n\t\t\tif (!boneData.parent)\n\t\t\t\tbone = new Bone(boneData, this, null);\n\t\t\telse {\n\t\t\t\tconst parent = this.bones[boneData.parent.index];\n\t\t\t\tbone = new Bone(boneData, this, parent);\n\t\t\t\tparent.children.push(bone);\n\t\t\t}\n\t\t\tthis.bones.push(bone);\n\t\t}\n\n\t\tthis.slots = new Array<Slot>();\n\t\tthis.drawOrder = new Array<Slot>();\n\t\tfor (let i = 0; i < data.slots.length; i++) {\n\t\t\tconst slotData = data.slots[i];\n\t\t\tconst bone = this.bones[slotData.boneData.index];\n\t\t\tconst slot = new Slot(slotData, bone);\n\t\t\tthis.slots.push(slot);\n\t\t\tthis.drawOrder.push(slot);\n\t\t}\n\n\t\tthis.ikConstraints = new Array<IkConstraint>();\n\t\tfor (let i = 0; i < data.ikConstraints.length; i++) {\n\t\t\tconst ikConstraintData = data.ikConstraints[i];\n\t\t\tthis.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n\t\t}\n\n\t\tthis.transformConstraints = new Array<TransformConstraint>();\n\t\tfor (let i = 0; i < data.transformConstraints.length; i++) {\n\t\t\tconst transformConstraintData = data.transformConstraints[i];\n\t\t\tthis.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n\t\t}\n\n\t\tthis.pathConstraints = new Array<PathConstraint>();\n\t\tfor (let i = 0; i < data.pathConstraints.length; i++) {\n\t\t\tconst pathConstraintData = data.pathConstraints[i];\n\t\t\tthis.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n\t\t}\n\n\t\tthis.color = new Color(1, 1, 1, 1);\n\t\tthis.updateCache();\n\t}\n\n\t/** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,\n\t * constraints, or weighted path attachments are added or removed. */\n\tupdateCache () {\n\t\tconst updateCache = this._updateCache;\n\t\tupdateCache.length = 0;\n\n\t\tconst bones = this.bones;\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\n\t\t\tconst bone = bones[i];\n\t\t\tbone.sorted = bone.data.skinRequired;\n\t\t\tbone.active = !bone.sorted;\n\t\t}\n\n\t\tif (this.skin) {\n\t\t\tconst skinBones = this.skin.bones;\n\t\t\tfor (let i = 0, n = this.skin.bones.length; i < n; i++) {\n\t\t\t\tlet bone: Bone | null = this.bones[skinBones[i].index];\n\t\t\t\tdo {\n\t\t\t\t\tbone.sorted = false;\n\t\t\t\t\tbone.active = true;\n\t\t\t\t\tbone = bone.parent;\n\t\t\t\t} while (bone);\n\t\t\t}\n\t\t}\n\n\t\t// IK first, lowest hierarchy depth first.\n\t\tconst ikConstraints = this.ikConstraints;\n\t\tconst transformConstraints = this.transformConstraints;\n\t\tconst pathConstraints = this.pathConstraints;\n\t\tconst ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\n\t\tconst constraintCount = ikCount + transformCount + pathCount;\n\n\t\touter:\n\t\tfor (let i = 0; i < constraintCount; i++) {\n\t\t\tfor (let ii = 0; ii < ikCount; ii++) {\n\t\t\t\tconst constraint = ikConstraints[ii];\n\t\t\t\tif (constraint.data.order == i) {\n\t\t\t\t\tthis.sortIkConstraint(constraint);\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let ii = 0; ii < transformCount; ii++) {\n\t\t\t\tconst constraint = transformConstraints[ii];\n\t\t\t\tif (constraint.data.order == i) {\n\t\t\t\t\tthis.sortTransformConstraint(constraint);\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let ii = 0; ii < pathCount; ii++) {\n\t\t\t\tconst constraint = pathConstraints[ii];\n\t\t\t\tif (constraint.data.order == i) {\n\t\t\t\t\tthis.sortPathConstraint(constraint);\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0, n = bones.length; i < n; i++)\n\t\t\tthis.sortBone(bones[i]);\n\t}\n\n\tsortIkConstraint (constraint: IkConstraint) {\n\t\tconstraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)))!;\n\t\tif (!constraint.active) return;\n\n\t\tconst target = constraint.target;\n\t\tthis.sortBone(target);\n\n\t\tconst constrained = constraint.bones;\n\t\tconst parent = constrained[0];\n\t\tthis.sortBone(parent);\n\n\t\tif (constrained.length == 1) {\n\t\t\tthis._updateCache.push(constraint);\n\t\t\tthis.sortReset(parent.children);\n\t\t} else {\n\t\t\tconst child = constrained[constrained.length - 1];\n\t\t\tthis.sortBone(child);\n\n\t\t\tthis._updateCache.push(constraint);\n\n\t\t\tthis.sortReset(parent.children);\n\t\t\tchild.sorted = true;\n\t\t}\n\t}\n\n\tsortPathConstraint (constraint: PathConstraint) {\n\t\tconstraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)))!;\n\t\tif (!constraint.active) return;\n\n\t\tconst slot = constraint.target;\n\t\tconst slotIndex = slot.data.index;\n\t\tconst slotBone = slot.bone;\n\t\tif (this.skin) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n\t\tif (this.data.defaultSkin && this.data.defaultSkin != this.skin)\n\t\t\tthis.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n\t\tfor (let i = 0, n = this.data.skins.length; i < n; i++)\n\t\t\tthis.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n\n\t\tconst attachment = slot.getAttachment();\n\t\tif (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n\n\t\tconst constrained = constraint.bones;\n\t\tconst boneCount = constrained.length;\n\t\tfor (let i = 0; i < boneCount; i++)\n\t\t\tthis.sortBone(constrained[i]);\n\n\t\tthis._updateCache.push(constraint);\n\n\t\tfor (let i = 0; i < boneCount; i++)\n\t\t\tthis.sortReset(constrained[i].children);\n\t\tfor (let i = 0; i < boneCount; i++)\n\t\t\tconstrained[i].sorted = true;\n\t}\n\n\tsortTransformConstraint (constraint: TransformConstraint) {\n\t\tconstraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)))!;\n\t\tif (!constraint.active) return;\n\n\t\tthis.sortBone(constraint.target);\n\n\t\tconst constrained = constraint.bones;\n\t\tconst boneCount = constrained.length;\n\t\tif (constraint.data.local) {\n\t\t\tfor (let i = 0; i < boneCount; i++) {\n\t\t\t\tconst child = constrained[i];\n\t\t\t\tthis.sortBone(child.parent!);\n\t\t\t\tthis.sortBone(child);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < boneCount; i++) {\n\t\t\t\tthis.sortBone(constrained[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis._updateCache.push(constraint);\n\n\t\tfor (let i = 0; i < boneCount; i++)\n\t\t\tthis.sortReset(constrained[i].children);\n\t\tfor (let i = 0; i < boneCount; i++)\n\t\t\tconstrained[i].sorted = true;\n\t}\n\n\tsortPathConstraintAttachment (skin: Skin, slotIndex: number, slotBone: Bone) {\n\t\tconst attachments = skin.attachments[slotIndex];\n\t\tif (!attachments) return;\n\t\tfor (const key in attachments) {\n\t\t\tthis.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n\t\t}\n\t}\n\n\tsortPathConstraintAttachmentWith (attachment: Attachment, slotBone: Bone) {\n\t\tif (!(attachment instanceof PathAttachment)) return;\n\t\tconst pathBones = (<PathAttachment>attachment).bones;\n\t\tif (!pathBones)\n\t\t\tthis.sortBone(slotBone);\n\t\telse {\n\t\t\tconst bones = this.bones;\n\t\t\tfor (let i = 0, n = pathBones.length; i < n;) {\n\t\t\t\tlet nn = pathBones[i++];\n\t\t\t\tnn += i;\n\t\t\t\twhile (i < nn)\n\t\t\t\t\tthis.sortBone(bones[pathBones[i++]]);\n\t\t\t}\n\t\t}\n\t}\n\n\tsortBone (bone: Bone) {\n\t\tif (!bone) return;\n\t\tif (bone.sorted) return;\n\t\tconst parent = bone.parent;\n\t\tif (parent) this.sortBone(parent);\n\t\tbone.sorted = true;\n\t\tthis._updateCache.push(bone);\n\t}\n\n\tsortReset (bones: Array<Bone>) {\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\n\t\t\tconst bone = bones[i];\n\t\t\tif (!bone.active) continue;\n\t\t\tif (bone.sorted) this.sortReset(bone.children);\n\t\t\tbone.sorted = false;\n\t\t}\n\t}\n\n\t/** Updates the world transform for each bone and applies all constraints.\n\t *\n\t * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n\t * Runtimes Guide. */\n\tupdateWorldTransform () {\n\t\tconst bones = this.bones;\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\n\t\t\tconst bone = bones[i];\n\t\t\tbone.ax = bone.x;\n\t\t\tbone.ay = bone.y;\n\t\t\tbone.arotation = bone.rotation;\n\t\t\tbone.ascaleX = bone.scaleX;\n\t\t\tbone.ascaleY = bone.scaleY;\n\t\t\tbone.ashearX = bone.shearX;\n\t\t\tbone.ashearY = bone.shearY;\n\t\t}\n\n\t\tconst updateCache = this._updateCache;\n\t\tfor (let i = 0, n = updateCache.length; i < n; i++)\n\t\t\tupdateCache[i].update();\n\t}\n\n\tupdateWorldTransformWith (parent: Bone) {\n\t\t// Apply the parent bone transform to the root bone. The root bone always inherits scale, rotation and reflection.\n\t\tconst rootBone = this.getRootBone();\n\t\tif (!rootBone) throw new Error(\"Root bone must not be null.\");\n\t\tconst pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\n\t\trootBone.worldX = pa * this.x + pb * this.y + parent.worldX;\n\t\trootBone.worldY = pc * this.x + pd * this.y + parent.worldY;\n\n\t\tconst rotationY = rootBone.rotation + 90 + rootBone.shearY;\n\t\tconst la = MathUtils.cosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n\t\tconst lb = MathUtils.cosDeg(rotationY) * rootBone.scaleY;\n\t\tconst lc = MathUtils.sinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n\t\tconst ld = MathUtils.sinDeg(rotationY) * rootBone.scaleY;\n\t\trootBone.a = (pa * la + pb * lc) * this.scaleX;\n\t\trootBone.b = (pa * lb + pb * ld) * this.scaleX;\n\t\trootBone.c = (pc * la + pd * lc) * this.scaleY;\n\t\trootBone.d = (pc * lb + pd * ld) * this.scaleY;\n\n\t\t// Update everything except root bone.\n\t\tconst updateCache = this._updateCache;\n\t\tfor (let i = 0, n = updateCache.length; i < n; i++) {\n\t\t\tconst updatable = updateCache[i];\n\t\t\tif (updatable != rootBone) updatable.update();\n\t\t}\n\t}\n\n\t/** Sets the bones, constraints, and slots to their setup pose values. */\n\tsetToSetupPose () {\n\t\tthis.setBonesToSetupPose();\n\t\tthis.setSlotsToSetupPose();\n\t}\n\n\t/** Sets the bones and constraints to their setup pose values. */\n\tsetBonesToSetupPose () {\n\t\tconst bones = this.bones;\n\t\tfor (let i = 0, n = bones.length; i < n; i++)\n\t\t\tbones[i].setToSetupPose();\n\n\t\tconst ikConstraints = this.ikConstraints;\n\t\tfor (let i = 0, n = ikConstraints.length; i < n; i++) {\n\t\t\tconst constraint = ikConstraints[i];\n\t\t\tconstraint.mix = constraint.data.mix;\n\t\t\tconstraint.softness = constraint.data.softness;\n\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\n\t\t\tconstraint.compress = constraint.data.compress;\n\t\t\tconstraint.stretch = constraint.data.stretch;\n\t\t}\n\n\t\tconst transformConstraints = this.transformConstraints;\n\t\tfor (let i = 0, n = transformConstraints.length; i < n; i++) {\n\t\t\tconst constraint = transformConstraints[i];\n\t\t\tconst data = constraint.data;\n\t\t\tconstraint.mixRotate = data.mixRotate;\n\t\t\tconstraint.mixX = data.mixX;\n\t\t\tconstraint.mixY = data.mixY;\n\t\t\tconstraint.mixScaleX = data.mixScaleX;\n\t\t\tconstraint.mixScaleY = data.mixScaleY;\n\t\t\tconstraint.mixShearY = data.mixShearY;\n\t\t}\n\n\t\tconst pathConstraints = this.pathConstraints;\n\t\tfor (let i = 0, n = pathConstraints.length; i < n; i++) {\n\t\t\tconst constraint = pathConstraints[i];\n\t\t\tconst data = constraint.data;\n\t\t\tconstraint.position = data.position;\n\t\t\tconstraint.spacing = data.spacing;\n\t\t\tconstraint.mixRotate = data.mixRotate;\n\t\t\tconstraint.mixX = data.mixX;\n\t\t\tconstraint.mixY = data.mixY;\n\t\t}\n\t}\n\n\t/** Sets the slots and draw order to their setup pose values. */\n\tsetSlotsToSetupPose () {\n\t\tconst slots = this.slots;\n\t\tUtils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n\t\tfor (let i = 0, n = slots.length; i < n; i++)\n\t\t\tslots[i].setToSetupPose();\n\t}\n\n\t/** @returns May return null. */\n\tgetRootBone () {\n\t\tif (this.bones.length == 0) return null;\n\t\treturn this.bones[0];\n\t}\n\n\t/** @returns May be null. */\n\tfindBone (boneName: string) {\n\t\tif (!boneName) throw new Error(\"boneName cannot be null.\");\n\t\tconst bones = this.bones;\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\n\t\t\tconst bone = bones[i];\n\t\t\tif (bone.data.name == boneName) return bone;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\n\t * repeatedly.\n\t * @returns May be null. */\n\tfindSlot (slotName: string) {\n\t\tif (!slotName) throw new Error(\"slotName cannot be null.\");\n\t\tconst slots = this.slots;\n\t\tfor (let i = 0, n = slots.length; i < n; i++) {\n\t\t\tconst slot = slots[i];\n\t\t\tif (slot.data.name == slotName) return slot;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Sets a skin by name.\n\t *\n\t * See {@link #setSkin()}. */\n\tsetSkinByName (skinName: string) {\n\t\tconst skin = this.data.findSkin(skinName);\n\t\tif (!skin) throw new Error(\"Skin not found: \" + skinName);\n\t\tthis.setSkin(skin);\n\t}\n\n\t/** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the\n\t * skin is changed, {@link #updateCache()} is called.\n\t *\n\t * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n\t * old skin, each slot's setup mode attachment is attached from the new skin.\n\t *\n\t * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling\n\t * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the\n\t * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.\n\t * @param newSkin May be null. */\n\tsetSkin (newSkin: Skin) {\n\t\tif (newSkin == this.skin) return;\n\t\tif (newSkin) {\n\t\t\tif (this.skin)\n\t\t\t\tnewSkin.attachAll(this, this.skin);\n\t\t\telse {\n\t\t\t\tconst slots = this.slots;\n\t\t\t\tfor (let i = 0, n = slots.length; i < n; i++) {\n\t\t\t\t\tconst slot = slots[i];\n\t\t\t\t\tconst name = slot.data.attachmentName;\n\t\t\t\t\tif (name) {\n\t\t\t\t\t\tconst attachment = newSkin.getAttachment(i, name);\n\t\t\t\t\t\tif (attachment) slot.setAttachment(attachment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.skin = newSkin;\n\t\tthis.updateCache();\n\t}\n\n\n\t/** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment\n\t * name.\n\t *\n\t * See {@link #getAttachment()}.\n\t * @returns May be null. */\n\tgetAttachmentByName (slotName: string, attachmentName: string): Attachment | null {\n\t\tconst slot = this.data.findSlot(slotName);\n\t\tif (!slot) throw new Error(`Can't find slot with name ${slotName}`);\n\t\treturn this.getAttachment(slot.index, attachmentName);\n\t}\n\n\t/** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and\n\t * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.\n\t *\n\t * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\n\t * @returns May be null. */\n\tgetAttachment (slotIndex: number, attachmentName: string): Attachment | null {\n\t\tif (!attachmentName) throw new Error(\"attachmentName cannot be null.\");\n\t\tif (this.skin) {\n\t\t\tconst attachment = this.skin.getAttachment(slotIndex, attachmentName);\n\t\t\tif (attachment) return attachment;\n\t\t}\n\t\tif (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n\t\treturn null;\n\t}\n\n\t/** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with\n\t * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.\n\t * @param attachmentName May be null to clear the slot's attachment. */\n\tsetAttachment (slotName: string, attachmentName: string) {\n\t\tif (!slotName) throw new Error(\"slotName cannot be null.\");\n\t\tconst slots = this.slots;\n\t\tfor (let i = 0, n = slots.length; i < n; i++) {\n\t\t\tconst slot = slots[i];\n\t\t\tif (slot.data.name == slotName) {\n\t\t\t\tlet attachment: Attachment | null = null;\n\t\t\t\tif (attachmentName) {\n\t\t\t\t\tattachment = this.getAttachment(i, attachmentName);\n\t\t\t\t\tif (!attachment) throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\n\t\t\t\t}\n\t\t\t\tslot.setAttachment(attachment);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthrow new Error(\"Slot not found: \" + slotName);\n\t}\n\n\n\t/** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\n\t * than to call it repeatedly.\n\t * @return May be null. */\n\tfindIkConstraint (constraintName: string) {\n\t\tif (!constraintName) throw new Error(\"constraintName cannot be null.\");\n\t\tconst ikConstraints = this.ikConstraints;\n\t\tfor (let i = 0, n = ikConstraints.length; i < n; i++) {\n\t\t\tconst ikConstraint = ikConstraints[i];\n\t\t\tif (ikConstraint.data.name == constraintName) return ikConstraint;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\n\t * this method than to call it repeatedly.\n\t * @return May be null. */\n\tfindTransformConstraint (constraintName: string) {\n\t\tif (!constraintName) throw new Error(\"constraintName cannot be null.\");\n\t\tconst transformConstraints = this.transformConstraints;\n\t\tfor (let i = 0, n = transformConstraints.length; i < n; i++) {\n\t\t\tconst constraint = transformConstraints[i];\n\t\t\tif (constraint.data.name == constraintName) return constraint;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\n\t * than to call it repeatedly.\n\t * @return May be null. */\n\tfindPathConstraint (constraintName: string) {\n\t\tif (!constraintName) throw new Error(\"constraintName cannot be null.\");\n\t\tconst pathConstraints = this.pathConstraints;\n\t\tfor (let i = 0, n = pathConstraints.length; i < n; i++) {\n\t\t\tconst constraint = pathConstraints[i];\n\t\t\tif (constraint.data.name == constraintName) return constraint;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose as `{ x: number, y: number, width: number, height: number }`.\n\t * Note that this method will create temporary objects which can add to garbage collection pressure. Use `getBounds()` if garbage collection is a concern. */\n\tgetBoundsRect () {\n\t\tconst offset = new Vector2();\n\t\tconst size = new Vector2();\n\t\tthis.getBounds(offset, size);\n\t\treturn { x: offset.x, y: offset.y, width: size.x, height: size.y };\n\t}\n\n\t/** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n\t * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.\n\t * @param size An output value, the width and height of the AABB.\n\t * @param temp Working memory to temporarily store attachments' computed world vertices. */\n\tgetBounds (offset: Vector2, size: Vector2, temp: Array<number> = new Array<number>(2)) {\n\t\tif (!offset) throw new Error(\"offset cannot be null.\");\n\t\tif (!size) throw new Error(\"size cannot be null.\");\n\t\tconst drawOrder = this.drawOrder;\n\t\tlet minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n\t\tfor (let i = 0, n = drawOrder.length; i < n; i++) {\n\t\t\tconst slot = drawOrder[i];\n\t\t\tif (!slot.bone.active) continue;\n\t\t\tlet verticesLength = 0;\n\t\t\tlet vertices: NumberArrayLike | null = null;\n\t\t\tconst attachment = slot.getAttachment();\n\t\t\tif (attachment instanceof RegionAttachment) {\n\t\t\t\tverticesLength = 8;\n\t\t\t\tvertices = Utils.setArraySize(temp, verticesLength, 0);\n\t\t\t\t(<RegionAttachment>attachment).computeWorldVertices(slot, vertices, 0, 2);\n\t\t\t} else if (attachment instanceof MeshAttachment) {\n\t\t\t\tconst mesh = (<MeshAttachment>attachment);\n\t\t\t\tverticesLength = mesh.worldVerticesLength;\n\t\t\t\tvertices = Utils.setArraySize(temp, verticesLength, 0);\n\t\t\t\tmesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n\t\t\t}\n\t\t\tif (vertices) {\n\t\t\t\tfor (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n\t\t\t\t\tconst x = vertices[ii], y = vertices[ii + 1];\n\t\t\t\t\tminX = Math.min(minX, x);\n\t\t\t\t\tminY = Math.min(minY, y);\n\t\t\t\t\tmaxX = Math.max(maxX, x);\n\t\t\t\t\tmaxY = Math.max(maxY, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toffset.set(minX, minY);\n\t\tsize.set(maxX - minX, maxY - minY);\n\t}\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Animation } from './Animation';\nimport { BoneData } from './BoneData';\nimport { EventData } from './EventData';\nimport { IkConstraintData } from './IkConstraintData';\nimport { PathConstraintData } from './PathConstraintData';\nimport { Skin } from './Skin';\nimport { SlotData } from './SlotData';\nimport { TransformConstraintData } from './TransformConstraintData';\n\n/** Stores the setup pose and all of the stateless data for a skeleton.\n *\n * See [Data objects](http://esotericsoftware.com/spine-runtime-architecture#Data-objects) in the Spine Runtimes\n * Guide. */\nexport class SkeletonData {\n  /** The skeleton's name, which by default is the name of the skeleton data file, if possible. May be null. */\n  name: string | null = null;\n\n  /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\n  bones = new Array<BoneData>(); // Ordered parents first.\n\n  /** The skeleton's slots. */\n  slots = new Array<SlotData>(); // Setup pose draw order.\n  skins = new Array<Skin>();\n\n  /** The skeleton's default skin. By default this skin contains all attachments that were not in a skin in Spine.\n   *\n   * See {@link Skeleton#getAttachmentByName()}.\n   * May be null. */\n  defaultSkin: Skin | null = null;\n\n  /** The skeleton's events. */\n  events = new Array<EventData>();\n\n  /** The skeleton's animations. */\n  animations = new Array<Animation>();\n\n  /** The skeleton's IK constraints. */\n  ikConstraints = new Array<IkConstraintData>();\n\n  /** The skeleton's transform constraints. */\n  transformConstraints = new Array<TransformConstraintData>();\n\n  /** The skeleton's path constraints. */\n  pathConstraints = new Array<PathConstraintData>();\n\n  /** The X coordinate of the skeleton's axis aligned bounding box in the setup pose. */\n  x: number = 0;\n\n  /** The Y coordinate of the skeleton's axis aligned bounding box in the setup pose. */\n  y: number = 0;\n\n  /** The width of the skeleton's axis aligned bounding box in the setup pose. */\n  width: number = 0;\n\n  /** The height of the skeleton's axis aligned bounding box in the setup pose. */\n  height: number = 0;\n\n  /** The Spine version used to export the skeleton data, or null. */\n  version: string | null = null;\n\n  /** The skeleton data hash. This value will change if any of the skeleton data has changed. May be null. */\n  hash: string | null = null;\n\n  // Nonessential\n  /** The dopesheet FPS in Spine. Available only when nonessential data was exported. */\n  fps = 0;\n\n  /** The path to the images directory as defined in Spine. Available only when nonessential data was exported. May be null. */\n  imagesPath: string | null = null;\n\n  /** The path to the audio directory as defined in Spine. Available only when nonessential data was exported. May be null. */\n  audioPath: string | null = null;\n\n  /** Finds a bone by comparing each bone's name. It is more efficient to cache the results of this method than to call it\n   * multiple times.\n   * @returns May be null. */\n  findBone(boneName: string) {\n    if (!boneName) throw new Error('boneName cannot be null.');\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (bone.name == boneName) return bone;\n    }\n    return null;\n  }\n\n  /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\n   * multiple times.\n   * @returns May be null. */\n  findSlot(slotName: string) {\n    if (!slotName) throw new Error('slotName cannot be null.');\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.name == slotName) return slot;\n    }\n    return null;\n  }\n\n  /** Finds a skin by comparing each skin's name. It is more efficient to cache the results of this method than to call it\n   * multiple times.\n   * @returns May be null. */\n  findSkin(skinName: string) {\n    if (!skinName) throw new Error('skinName cannot be null.');\n    const skins = this.skins;\n    for (let i = 0, n = skins.length; i < n; i++) {\n      const skin = skins[i];\n      if (skin.name == skinName) return skin;\n    }\n    return null;\n  }\n\n  /** Finds an event by comparing each events's name. It is more efficient to cache the results of this method than to call it\n   * multiple times.\n   * @returns May be null. */\n  findEvent(eventDataName: string) {\n    if (!eventDataName) throw new Error('eventDataName cannot be null.');\n    const events = this.events;\n    for (let i = 0, n = events.length; i < n; i++) {\n      const event = events[i];\n      if (event.name == eventDataName) return event;\n    }\n    return null;\n  }\n\n  /** Finds an animation by comparing each animation's name. It is more efficient to cache the results of this method than to\n   * call it multiple times.\n   * @returns May be null. */\n  findAnimation(animationName: string) {\n    if (!animationName) throw new Error('animationName cannot be null.');\n    const animations = this.animations;\n    for (let i = 0, n = animations.length; i < n; i++) {\n      const animation = animations[i];\n      if (animation.name == animationName) return animation;\n    }\n    return null;\n  }\n\n  /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\n   * than to call it multiple times.\n   * @return May be null. */\n  findIkConstraint(constraintName: string) {\n    if (!constraintName) throw new Error('constraintName cannot be null.');\n    const ikConstraints = this.ikConstraints;\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      const constraint = ikConstraints[i];\n      if (constraint.name == constraintName) return constraint;\n    }\n    return null;\n  }\n\n  /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\n   * this method than to call it multiple times.\n   * @return May be null. */\n  findTransformConstraint(constraintName: string) {\n    if (!constraintName) throw new Error('constraintName cannot be null.');\n    const transformConstraints = this.transformConstraints;\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      const constraint = transformConstraints[i];\n      if (constraint.name == constraintName) return constraint;\n    }\n    return null;\n  }\n\n  /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\n   * than to call it multiple times.\n   * @return May be null. */\n  findPathConstraint(constraintName: string) {\n    if (!constraintName) throw new Error('constraintName cannot be null.');\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      const constraint = pathConstraints[i];\n      if (constraint.name == constraintName) return constraint;\n    }\n    return null;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Attachment } from './attachments/Attachment';\nimport { MeshAttachment } from './attachments/MeshAttachment';\nimport { BoneData } from './BoneData';\nimport { ConstraintData } from './ConstraintData';\nimport { Skeleton } from './Skeleton';\nimport { StringMap } from './Utils';\n\n/** Stores an entry in the skin consisting of the slot index, name, and attachment **/\nexport class SkinEntry {\n  constructor(\n    public slotIndex: number = 0,\n    public name: string,\n    public attachment: Attachment,\n  ) {}\n}\n\n/** Stores attachments by slot index and attachment name.\n *\n * See SkeletonData {@link SkeletonData#defaultSkin}, Skeleton {@link Skeleton#skin}, and\n * [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide. */\nexport class Skin {\n  /** The skin's name, which is unique across all skins in the skeleton. */\n  name: string;\n\n  attachments = new Array<StringMap<Attachment>>();\n  bones = Array<BoneData>();\n  constraints = new Array<ConstraintData>();\n\n  constructor(name: string) {\n    if (!name) throw new Error('name cannot be null.');\n    this.name = name;\n  }\n\n  /** Adds an attachment to the skin for the specified slot index and name. */\n  setAttachment(slotIndex: number, name: string, attachment: Attachment) {\n    if (!attachment) throw new Error('attachment cannot be null.');\n    const attachments = this.attachments;\n    if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n    if (!attachments[slotIndex]) attachments[slotIndex] = {};\n    attachments[slotIndex][name] = attachment;\n  }\n\n  /** Adds all attachments, bones, and constraints from the specified skin to this skin. */\n  addSkin(skin: Skin) {\n    for (let i = 0; i < skin.bones.length; i++) {\n      const bone = skin.bones[i];\n      let contained = false;\n      for (let ii = 0; ii < this.bones.length; ii++) {\n        if (this.bones[ii] == bone) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained) this.bones.push(bone);\n    }\n\n    for (let i = 0; i < skin.constraints.length; i++) {\n      const constraint = skin.constraints[i];\n      let contained = false;\n      for (let ii = 0; ii < this.constraints.length; ii++) {\n        if (this.constraints[ii] == constraint) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained) this.constraints.push(constraint);\n    }\n\n    const attachments = skin.getAttachments();\n    for (let i = 0; i < attachments.length; i++) {\n      const attachment = attachments[i];\n      this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n    }\n  }\n\n  /** Adds all bones and constraints and copies of all attachments from the specified skin to this skin. Mesh attachments are not\n   * copied, instead a new linked mesh is created. The attachment copies can be modified without affecting the originals. */\n  copySkin(skin: Skin) {\n    for (let i = 0; i < skin.bones.length; i++) {\n      const bone = skin.bones[i];\n      let contained = false;\n      for (let ii = 0; ii < this.bones.length; ii++) {\n        if (this.bones[ii] == bone) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained) this.bones.push(bone);\n    }\n\n    for (let i = 0; i < skin.constraints.length; i++) {\n      const constraint = skin.constraints[i];\n      let contained = false;\n      for (let ii = 0; ii < this.constraints.length; ii++) {\n        if (this.constraints[ii] == constraint) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained) this.constraints.push(constraint);\n    }\n\n    const attachments = skin.getAttachments();\n    for (let i = 0; i < attachments.length; i++) {\n      const attachment = attachments[i];\n      if (!attachment.attachment) continue;\n      if (attachment.attachment instanceof MeshAttachment) {\n        attachment.attachment = attachment.attachment.newLinkedMesh();\n        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n      } else {\n        attachment.attachment = attachment.attachment.copy();\n        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n      }\n    }\n  }\n\n  /** Returns the attachment for the specified slot index and name, or null. */\n  getAttachment(slotIndex: number, name: string): Attachment | null {\n    const dictionary = this.attachments[slotIndex];\n    return dictionary ? dictionary[name] : null;\n  }\n\n  /** Removes the attachment in the skin for the specified slot index and name, if any. */\n  removeAttachment(slotIndex: number, name: string) {\n    const dictionary = this.attachments[slotIndex];\n    if (dictionary) delete dictionary[name];\n  }\n\n  /** Returns all attachments in this skin. */\n  getAttachments(): Array<SkinEntry> {\n    const entries = new Array<SkinEntry>();\n    for (let i = 0; i < this.attachments.length; i++) {\n      const slotAttachments = this.attachments[i];\n      if (slotAttachments) {\n        for (const name in slotAttachments) {\n          const attachment = slotAttachments[name];\n          if (attachment) entries.push(new SkinEntry(i, name, attachment));\n        }\n      }\n    }\n    return entries;\n  }\n\n  /** Returns all attachments in this skin for the specified slot index. */\n  getAttachmentsForSlot(slotIndex: number, attachments: Array<SkinEntry>) {\n    const slotAttachments = this.attachments[slotIndex];\n    if (slotAttachments) {\n      for (const name in slotAttachments) {\n        const attachment = slotAttachments[name];\n        if (attachment) attachments.push(new SkinEntry(slotIndex, name, attachment));\n      }\n    }\n  }\n\n  /** Clears all attachments, bones, and constraints. */\n  clear() {\n    this.attachments.length = 0;\n    this.bones.length = 0;\n    this.constraints.length = 0;\n  }\n\n  /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n  attachAll(skeleton: Skeleton, oldSkin: Skin) {\n    let slotIndex = 0;\n    for (let i = 0; i < skeleton.slots.length; i++) {\n      const slot = skeleton.slots[i];\n      const slotAttachment = slot.getAttachment();\n      if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n        const dictionary = oldSkin.attachments[slotIndex];\n        for (const key in dictionary) {\n          const skinAttachment: Attachment = dictionary[key];\n          if (slotAttachment == skinAttachment) {\n            const attachment = this.getAttachment(slotIndex, key);\n            if (attachment) slot.setAttachment(attachment);\n            break;\n          }\n        }\n      }\n      slotIndex++;\n    }\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { BoneData } from './BoneData';\nimport { Color } from './Utils';\n\n/** Stores the setup pose for a {@link Slot}. */\nexport class SlotData {\n  /** The index of the slot in {@link Skeleton#getSlots()}. */\n  index: number = 0;\n\n  /** The name of the slot, which is unique across all slots in the skeleton. */\n  name: string;\n\n  /** The bone this slot belongs to. */\n  boneData: BoneData;\n\n  /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\n   * color tinting. */\n  color = new Color(1, 1, 1, 1);\n\n  /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\n   * color's alpha is not used. */\n  darkColor: Color | null = null;\n\n  /** The name of the attachment that is visible for this slot in the setup pose, or null if no attachment is visible. */\n  attachmentName: string | null = null;\n\n  /** The blend mode for drawing the slot's attachment. */\n  blendMode: BlendMode = BlendMode.Normal;\n\n  constructor(index: number, name: string, boneData: BoneData) {\n    if (index < 0) throw new Error('index must be >= 0.');\n    if (!name) throw new Error('name cannot be null.');\n    if (!boneData) throw new Error('boneData cannot be null.');\n    this.index = index;\n    this.name = name;\n    this.boneData = boneData;\n  }\n}\n\n/** Determines how images are blended with existing pixels when drawn. */\nexport enum BlendMode {\n  Normal,\n  Additive,\n  Multiply,\n  Screen,\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { BoneData } from './BoneData';\nimport { ConstraintData } from './ConstraintData';\n\n/** Stores the setup pose for a {@link TransformConstraint}.\n *\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide. */\nexport class TransformConstraintData extends ConstraintData {\n  /** The bones that will be modified by this transform constraint. */\n  bones = new Array<BoneData>();\n  mixRotate = 0;\n  mixX = 0;\n  mixY = 0;\n  mixScaleX = 0;\n  mixScaleY = 0;\n  mixShearY = 0;\n  /** An offset added to the constrained bone rotation. */\n  offsetRotation = 0;\n  /** An offset added to the constrained bone X translation. */\n  offsetX = 0;\n  /** An offset added to the constrained bone Y translation. */\n  offsetY = 0;\n  /** An offset added to the constrained bone scaleX. */\n  offsetScaleX = 0;\n  /** An offset added to the constrained bone scaleY. */\n  offsetScaleY = 0;\n  /** An offset added to the constrained bone shearY. */\n  offsetShearY = 0;\n  relative = false;\n  local = false;\n  /** The target bone whose world transform will be copied to the constrained bones. */\n  private _target: BoneData | null = null;\n\n  constructor(name: string) {\n    super(name, 0, false);\n  }\n\n  public get target() {\n    if (!this._target) throw new Error('BoneData not set.');\n    else return this._target;\n  }\n\n  public set target(boneData: BoneData) {\n    this._target = boneData;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport {\n\tAlphaTimeline,\n\tAnimation,\n\tAttachmentTimeline,\n\tCurveTimeline,\n\tCurveTimeline1,\n\tCurveTimeline2,\n\tDeformTimeline,\n\tDrawOrderTimeline,\n\tEventTimeline,\n\tIkConstraintTimeline,\n\tPathConstraintMixTimeline,\n\tPathConstraintPositionTimeline,\n\tPathConstraintSpacingTimeline,\n\tRGB2Timeline,\n\tRGBA2Timeline,\n\tRGBATimeline,\n\tRGBTimeline,\n\tRotateTimeline,\n\tScaleTimeline,\n\tScaleXTimeline,\n\tScaleYTimeline,\n\tSequenceTimeline,\n\tShearTimeline,\n\tShearXTimeline,\n\tShearYTimeline,\n\tTimeline,\n\tTransformConstraintTimeline,\n\tTranslateTimeline,\n\tTranslateXTimeline,\n\tTranslateYTimeline,\n} from './Animation';\nimport { Attachment, VertexAttachment } from './attachments/Attachment';\nimport { AttachmentLoader } from './attachments/AttachmentLoader';\nimport { HasTextureRegion } from './attachments/HasTextureRegion';\nimport { MeshAttachment } from './attachments/MeshAttachment';\nimport { Sequence, SequenceModeValues } from './attachments/Sequence';\nimport { BoneData } from './BoneData';\nimport { Event } from './Event';\nimport { EventData } from './EventData';\nimport { IkConstraintData } from './IkConstraintData';\nimport { PathConstraintData, PositionMode, SpacingMode } from './PathConstraintData';\nimport { SkeletonData } from './SkeletonData';\nimport { Skin } from './Skin';\nimport { SlotData } from './SlotData';\nimport { TransformConstraintData } from './TransformConstraintData';\nimport { Color, Utils } from './Utils';\n\n/** Loads skeleton data in the Spine binary format.\n *\n * See [Spine binary format](http://esotericsoftware.com/spine-binary-format) and\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\n * Runtimes Guide. */\nexport class SkeletonBinary {\n  /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\n   * runtime than were used in Spine.\n   *\n   * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n  scale = 1;\n\n  attachmentLoader: AttachmentLoader;\n  private linkedMeshes = new Array<LinkedMesh>();\n\n  constructor(attachmentLoader: AttachmentLoader) {\n    this.attachmentLoader = attachmentLoader;\n  }\n\n  readSkeletonData(binary: Uint8Array): SkeletonData {\n    const scale = this.scale;\n\n    const skeletonData = new SkeletonData();\n    skeletonData.name = ''; // BOZO\n\n    const input = new BinaryInput(binary);\n\n    const lowHash = input.readInt32();\n    const highHash = input.readInt32();\n    skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);\n    skeletonData.version = input.readString();\n    skeletonData.x = input.readFloat();\n    skeletonData.y = input.readFloat();\n    skeletonData.width = input.readFloat();\n    skeletonData.height = input.readFloat();\n\n    const nonessential = input.readBoolean();\n    if (nonessential) {\n      skeletonData.fps = input.readFloat();\n\n      skeletonData.imagesPath = input.readString();\n      skeletonData.audioPath = input.readString();\n    }\n\n    let n = 0;\n    // Strings.\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const str = input.readString();\n      if (!str) throw new Error('String in string table must not be null.');\n      input.strings.push(str);\n    }\n\n    // Bones.\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const name = input.readString();\n      if (!name) throw new Error('Bone name must not be null.');\n      const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\n      const data = new BoneData(i, name, parent);\n      data.rotation = input.readFloat();\n      data.x = input.readFloat() * scale;\n      data.y = input.readFloat() * scale;\n      data.scaleX = input.readFloat();\n      data.scaleY = input.readFloat();\n      data.shearX = input.readFloat();\n      data.shearY = input.readFloat();\n      data.length = input.readFloat() * scale;\n      data.transformMode = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      if (nonessential) Color.rgba8888ToColor(data.color, input.readInt32());\n      skeletonData.bones.push(data);\n    }\n\n    // Slots.\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const slotName = input.readString();\n      if (!slotName) throw new Error('Slot name must not be null.');\n      const boneData = skeletonData.bones[input.readInt(true)];\n      const data = new SlotData(i, slotName, boneData);\n      Color.rgba8888ToColor(data.color, input.readInt32());\n\n      const darkColor = input.readInt32();\n      if (darkColor != -1) Color.rgb888ToColor((data.darkColor = new Color()), darkColor);\n\n      data.attachmentName = input.readStringRef();\n      data.blendMode = input.readInt(true);\n      skeletonData.slots.push(data);\n    }\n\n    // IK constraints.\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const name = input.readString();\n      if (!name) throw new Error('IK constraint data name must not be null.');\n      const data = new IkConstraintData(name);\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.bones[input.readInt(true)];\n      data.mix = input.readFloat();\n      data.softness = input.readFloat() * scale;\n      data.bendDirection = input.readByte();\n      data.compress = input.readBoolean();\n      data.stretch = input.readBoolean();\n      data.uniform = input.readBoolean();\n      skeletonData.ikConstraints.push(data);\n    }\n\n    // Transform constraints.\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const name = input.readString();\n      if (!name) throw new Error('Transform constraint data name must not be null.');\n      const data = new TransformConstraintData(name);\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.bones[input.readInt(true)];\n      data.local = input.readBoolean();\n      data.relative = input.readBoolean();\n      data.offsetRotation = input.readFloat();\n      data.offsetX = input.readFloat() * scale;\n      data.offsetY = input.readFloat() * scale;\n      data.offsetScaleX = input.readFloat();\n      data.offsetScaleY = input.readFloat();\n      data.offsetShearY = input.readFloat();\n      data.mixRotate = input.readFloat();\n      data.mixX = input.readFloat();\n      data.mixY = input.readFloat();\n      data.mixScaleX = input.readFloat();\n      data.mixScaleY = input.readFloat();\n      data.mixShearY = input.readFloat();\n      skeletonData.transformConstraints.push(data);\n    }\n\n    // Path constraints.\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const name = input.readString();\n      if (!name) throw new Error('Path constraint data name must not be null.');\n      const data = new PathConstraintData(name);\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.slots[input.readInt(true)];\n      data.positionMode = input.readInt(true);\n      data.spacingMode = input.readInt(true);\n      data.rotateMode = input.readInt(true);\n      data.offsetRotation = input.readFloat();\n      data.position = input.readFloat();\n      if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n      data.spacing = input.readFloat();\n      if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n      data.mixRotate = input.readFloat();\n      data.mixX = input.readFloat();\n      data.mixY = input.readFloat();\n      skeletonData.pathConstraints.push(data);\n    }\n\n    // Default skin.\n    const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\n    if (defaultSkin) {\n      skeletonData.defaultSkin = defaultSkin;\n      skeletonData.skins.push(defaultSkin);\n    }\n\n    // Skins.\n    {\n      let i = skeletonData.skins.length;\n      Utils.setArraySize(skeletonData.skins, (n = i + input.readInt(true)));\n      for (; i < n; i++) {\n        const skin = this.readSkin(input, skeletonData, false, nonessential);\n        if (!skin) throw new Error('readSkin() should not have returned null.');\n        skeletonData.skins[i] = skin;\n      }\n    }\n\n    // Linked meshes.\n    n = this.linkedMeshes.length;\n    for (let i = 0; i < n; i++) {\n      const linkedMesh = this.linkedMeshes[i];\n      const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n      if (!skin) throw new Error('Not skin found for linked mesh.');\n      if (!linkedMesh.parent) throw new Error('Linked mesh parent must not be null');\n      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n      if (!parent) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n      linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? (parent as VertexAttachment) : linkedMesh.mesh;\n      linkedMesh.mesh.setParentMesh(parent as MeshAttachment);\n      if (linkedMesh.mesh.region != null) linkedMesh.mesh.updateRegion();\n    }\n    this.linkedMeshes.length = 0;\n\n    // Events.\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const eventName = input.readStringRef();\n      if (!eventName) throw new Error();\n      const data = new EventData(eventName);\n      data.intValue = input.readInt(false);\n      data.floatValue = input.readFloat();\n      data.stringValue = input.readString();\n      data.audioPath = input.readString();\n      if (data.audioPath) {\n        data.volume = input.readFloat();\n        data.balance = input.readFloat();\n      }\n      skeletonData.events.push(data);\n    }\n\n    // Animations.\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const animationName = input.readString();\n      if (!animationName) throw new Error('Animatio name must not be null.');\n      skeletonData.animations.push(this.readAnimation(input, animationName, skeletonData));\n    }\n    return skeletonData;\n  }\n\n  private readSkin(\n    input: BinaryInput,\n    skeletonData: SkeletonData,\n    defaultSkin: boolean,\n    nonessential: boolean,\n  ): Skin | null {\n    let skin = null;\n    let slotCount = 0;\n\n    if (defaultSkin) {\n      slotCount = input.readInt(true);\n      if (slotCount == 0) return null;\n      skin = new Skin('default');\n    } else {\n      const skinName = input.readStringRef();\n      if (!skinName) throw new Error('Skin name must not be null.');\n      skin = new Skin(skinName);\n      skin.bones.length = input.readInt(true);\n      for (let i = 0, n = skin.bones.length; i < n; i++) skin.bones[i] = skeletonData.bones[input.readInt(true)];\n\n      for (let i = 0, n = input.readInt(true); i < n; i++)\n        skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\n      for (let i = 0, n = input.readInt(true); i < n; i++)\n        skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\n      for (let i = 0, n = input.readInt(true); i < n; i++)\n        skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\n\n      slotCount = input.readInt(true);\n    }\n\n    for (let i = 0; i < slotCount; i++) {\n      const slotIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const name = input.readStringRef();\n        if (!name) throw new Error('Attachment name must not be null');\n        const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\n        if (attachment) skin.setAttachment(slotIndex, name, attachment);\n      }\n    }\n    return skin;\n  }\n\n  private readAttachment(\n    input: BinaryInput,\n    skeletonData: SkeletonData,\n    skin: Skin,\n    slotIndex: number,\n    attachmentName: string,\n    nonessential: boolean,\n  ): Attachment | null {\n    const scale = this.scale;\n\n    let name = input.readStringRef();\n    if (!name) name = attachmentName;\n\n    switch (input.readByte()) {\n      case AttachmentType.Region: {\n        let path = input.readStringRef();\n        const rotation = input.readFloat();\n        const x = input.readFloat();\n        const y = input.readFloat();\n        const scaleX = input.readFloat();\n        const scaleY = input.readFloat();\n        const width = input.readFloat();\n        const height = input.readFloat();\n        const color = input.readInt32();\n        const sequence = this.readSequence(input);\n\n        if (!path) path = name;\n        const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);\n        if (!region) return null;\n        region.path = path;\n        region.x = x * scale;\n        region.y = y * scale;\n        region.scaleX = scaleX;\n        region.scaleY = scaleY;\n        region.rotation = rotation;\n        region.width = width * scale;\n        region.height = height * scale;\n        Color.rgba8888ToColor(region.color, color);\n        region.sequence = sequence;\n        if (sequence == null) region.updateRegion();\n        return region;\n      }\n      case AttachmentType.BoundingBox: {\n        const vertexCount = input.readInt(true);\n        const vertices = this.readVertices(input, vertexCount);\n        const color = nonessential ? input.readInt32() : 0;\n\n        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n        if (!box) return null;\n        box.worldVerticesLength = vertexCount << 1;\n        box.vertices = vertices.vertices!;\n        box.bones = vertices.bones;\n        if (nonessential) Color.rgba8888ToColor(box.color, color);\n        return box;\n      }\n      case AttachmentType.Mesh: {\n        let path = input.readStringRef();\n        const color = input.readInt32();\n        const vertexCount = input.readInt(true);\n        const uvs = this.readFloatArray(input, vertexCount << 1, 1);\n        const triangles = this.readShortArray(input);\n        const vertices = this.readVertices(input, vertexCount);\n        const hullLength = input.readInt(true);\n        const sequence = this.readSequence(input);\n        let edges: number[] = [];\n        let width = 0,\n          height = 0;\n        if (nonessential) {\n          edges = this.readShortArray(input);\n          width = input.readFloat();\n          height = input.readFloat();\n        }\n\n        if (!path) path = name;\n        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n        if (!mesh) return null;\n        mesh.path = path;\n        Color.rgba8888ToColor(mesh.color, color);\n        mesh.bones = vertices.bones;\n        mesh.vertices = vertices.vertices!;\n        mesh.worldVerticesLength = vertexCount << 1;\n        mesh.triangles = triangles;\n        mesh.regionUVs = uvs;\n        if (sequence == null) mesh.updateRegion();\n        mesh.hullLength = hullLength << 1;\n        mesh.sequence = sequence;\n        if (nonessential) {\n          mesh.edges = edges;\n          mesh.width = width * scale;\n          mesh.height = height * scale;\n        }\n        return mesh;\n      }\n      case AttachmentType.LinkedMesh: {\n        let path = input.readStringRef();\n        const color = input.readInt32();\n        const skinName = input.readStringRef();\n        const parent = input.readStringRef();\n        const inheritTimelines = input.readBoolean();\n        const sequence = this.readSequence(input);\n        let width = 0,\n          height = 0;\n        if (nonessential) {\n          width = input.readFloat();\n          height = input.readFloat();\n        }\n\n        if (!path) path = name;\n        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n        if (!mesh) return null;\n        mesh.path = path;\n        Color.rgba8888ToColor(mesh.color, color);\n        mesh.sequence = sequence;\n        if (nonessential) {\n          mesh.width = width * scale;\n          mesh.height = height * scale;\n        }\n        this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritTimelines));\n        return mesh;\n      }\n      case AttachmentType.Path: {\n        const closed = input.readBoolean();\n        const constantSpeed = input.readBoolean();\n        const vertexCount = input.readInt(true);\n        const vertices = this.readVertices(input, vertexCount);\n        const lengths = Utils.newArray(vertexCount / 3, 0);\n        for (let i = 0, n = lengths.length; i < n; i++) lengths[i] = input.readFloat() * scale;\n        const color = nonessential ? input.readInt32() : 0;\n\n        const path = this.attachmentLoader.newPathAttachment(skin, name);\n        if (!path) return null;\n        path.closed = closed;\n        path.constantSpeed = constantSpeed;\n        path.worldVerticesLength = vertexCount << 1;\n        path.vertices = vertices.vertices!;\n        path.bones = vertices.bones;\n        path.lengths = lengths;\n        if (nonessential) Color.rgba8888ToColor(path.color, color);\n        return path;\n      }\n      case AttachmentType.Point: {\n        const rotation = input.readFloat();\n        const x = input.readFloat();\n        const y = input.readFloat();\n        const color = nonessential ? input.readInt32() : 0;\n\n        const point = this.attachmentLoader.newPointAttachment(skin, name);\n        if (!point) return null;\n        point.x = x * scale;\n        point.y = y * scale;\n        point.rotation = rotation;\n        if (nonessential) Color.rgba8888ToColor(point.color, color);\n        return point;\n      }\n      case AttachmentType.Clipping: {\n        const endSlotIndex = input.readInt(true);\n        const vertexCount = input.readInt(true);\n        const vertices = this.readVertices(input, vertexCount);\n        const color = nonessential ? input.readInt32() : 0;\n\n        const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n        if (!clip) return null;\n        clip.endSlot = skeletonData.slots[endSlotIndex];\n        clip.worldVerticesLength = vertexCount << 1;\n        clip.vertices = vertices.vertices!;\n        clip.bones = vertices.bones;\n        if (nonessential) Color.rgba8888ToColor(clip.color, color);\n        return clip;\n      }\n    }\n    return null;\n  }\n\n  private readSequence(input: BinaryInput) {\n    if (!input.readBoolean()) return null;\n    const sequence = new Sequence(input.readInt(true));\n    sequence.start = input.readInt(true);\n    sequence.digits = input.readInt(true);\n    sequence.setupIndex = input.readInt(true);\n    return sequence;\n  }\n\n  private readVertices(input: BinaryInput, vertexCount: number): Vertices {\n    const scale = this.scale;\n    const verticesLength = vertexCount << 1;\n    const vertices = new Vertices();\n    if (!input.readBoolean()) {\n      vertices.vertices = this.readFloatArray(input, verticesLength, scale);\n      return vertices;\n    }\n    const weights = new Array<number>();\n    const bonesArray = new Array<number>();\n    for (let i = 0; i < vertexCount; i++) {\n      const boneCount = input.readInt(true);\n      bonesArray.push(boneCount);\n      for (let ii = 0; ii < boneCount; ii++) {\n        bonesArray.push(input.readInt(true));\n        weights.push(input.readFloat() * scale);\n        weights.push(input.readFloat() * scale);\n        weights.push(input.readFloat());\n      }\n    }\n    vertices.vertices = Utils.toFloatArray(weights);\n    vertices.bones = bonesArray;\n    return vertices;\n  }\n\n  private readFloatArray(input: BinaryInput, n: number, scale: number): number[] {\n    const array = new Array<number>(n);\n    if (scale == 1) {\n      for (let i = 0; i < n; i++) array[i] = input.readFloat();\n    } else {\n      for (let i = 0; i < n; i++) array[i] = input.readFloat() * scale;\n    }\n    return array;\n  }\n\n  private readShortArray(input: BinaryInput): number[] {\n    const n = input.readInt(true);\n    const array = new Array<number>(n);\n    for (let i = 0; i < n; i++) array[i] = input.readShort();\n    return array;\n  }\n\n  private readAnimation(input: BinaryInput, name: string, skeletonData: SkeletonData): Animation {\n    input.readInt(true); // Number of timelines.\n    const timelines = new Array<Timeline>();\n    const scale = this.scale;\n    const tempColor1 = new Color();\n    const tempColor2 = new Color();\n\n    // Slot timelines.\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const slotIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const timelineType = input.readByte();\n        const frameCount = input.readInt(true);\n        const frameLast = frameCount - 1;\n        switch (timelineType) {\n          case SLOT_ATTACHMENT: {\n            const timeline = new AttachmentTimeline(frameCount, slotIndex);\n            for (let frame = 0; frame < frameCount; frame++)\n              timeline.setFrame(frame, input.readFloat(), input.readStringRef());\n            timelines.push(timeline);\n            break;\n          }\n          case SLOT_RGBA: {\n            const bezierCount = input.readInt(true);\n            const timeline = new RGBATimeline(frameCount, bezierCount, slotIndex);\n\n            let time = input.readFloat();\n            let r = input.readUnsignedByte() / 255.0;\n            let g = input.readUnsignedByte() / 255.0;\n            let b = input.readUnsignedByte() / 255.0;\n            let a = input.readUnsignedByte() / 255.0;\n\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, r, g, b, a);\n              if (frame == frameLast) break;\n\n              const time2 = input.readFloat();\n              const r2 = input.readUnsignedByte() / 255.0;\n              const g2 = input.readUnsignedByte() / 255.0;\n              const b2 = input.readUnsignedByte() / 255.0;\n              const a2 = input.readUnsignedByte() / 255.0;\n\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n                  setBezier(input, timeline, bezier++, frame, 3, time, time2, a, a2, 1);\n              }\n              time = time2;\n              r = r2;\n              g = g2;\n              b = b2;\n              a = a2;\n            }\n            timelines.push(timeline);\n            break;\n          }\n          case SLOT_RGB: {\n            const bezierCount = input.readInt(true);\n            const timeline = new RGBTimeline(frameCount, bezierCount, slotIndex);\n\n            let time = input.readFloat();\n            let r = input.readUnsignedByte() / 255.0;\n            let g = input.readUnsignedByte() / 255.0;\n            let b = input.readUnsignedByte() / 255.0;\n\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, r, g, b);\n              if (frame == frameLast) break;\n\n              const time2 = input.readFloat();\n              const r2 = input.readUnsignedByte() / 255.0;\n              const g2 = input.readUnsignedByte() / 255.0;\n              const b2 = input.readUnsignedByte() / 255.0;\n\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n              }\n              time = time2;\n              r = r2;\n              g = g2;\n              b = b2;\n            }\n            timelines.push(timeline);\n            break;\n          }\n          case SLOT_RGBA2: {\n            const bezierCount = input.readInt(true);\n            const timeline = new RGBA2Timeline(frameCount, bezierCount, slotIndex);\n\n            let time = input.readFloat();\n            let r = input.readUnsignedByte() / 255.0;\n            let g = input.readUnsignedByte() / 255.0;\n            let b = input.readUnsignedByte() / 255.0;\n            let a = input.readUnsignedByte() / 255.0;\n            let r2 = input.readUnsignedByte() / 255.0;\n            let g2 = input.readUnsignedByte() / 255.0;\n            let b2 = input.readUnsignedByte() / 255.0;\n\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, r, g, b, a, r2, g2, b2);\n              if (frame == frameLast) break;\n              const time2 = input.readFloat();\n              const nr = input.readUnsignedByte() / 255.0;\n              const ng = input.readUnsignedByte() / 255.0;\n              const nb = input.readUnsignedByte() / 255.0;\n              const na = input.readUnsignedByte() / 255.0;\n              const nr2 = input.readUnsignedByte() / 255.0;\n              const ng2 = input.readUnsignedByte() / 255.0;\n              const nb2 = input.readUnsignedByte() / 255.0;\n\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n                  setBezier(input, timeline, bezier++, frame, 3, time, time2, a, na, 1);\n                  setBezier(input, timeline, bezier++, frame, 4, time, time2, r2, nr2, 1);\n                  setBezier(input, timeline, bezier++, frame, 5, time, time2, g2, ng2, 1);\n                  setBezier(input, timeline, bezier++, frame, 6, time, time2, b2, nb2, 1);\n              }\n              time = time2;\n              r = nr;\n              g = ng;\n              b = nb;\n              a = na;\n              r2 = nr2;\n              g2 = ng2;\n              b2 = nb2;\n            }\n            timelines.push(timeline);\n            break;\n          }\n          case SLOT_RGB2: {\n            const bezierCount = input.readInt(true);\n            const timeline = new RGB2Timeline(frameCount, bezierCount, slotIndex);\n\n            let time = input.readFloat();\n            let r = input.readUnsignedByte() / 255.0;\n            let g = input.readUnsignedByte() / 255.0;\n            let b = input.readUnsignedByte() / 255.0;\n            let r2 = input.readUnsignedByte() / 255.0;\n            let g2 = input.readUnsignedByte() / 255.0;\n            let b2 = input.readUnsignedByte() / 255.0;\n\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, r, g, b, r2, g2, b2);\n              if (frame == frameLast) break;\n              const time2 = input.readFloat();\n              const nr = input.readUnsignedByte() / 255.0;\n              const ng = input.readUnsignedByte() / 255.0;\n              const nb = input.readUnsignedByte() / 255.0;\n              const nr2 = input.readUnsignedByte() / 255.0;\n              const ng2 = input.readUnsignedByte() / 255.0;\n              const nb2 = input.readUnsignedByte() / 255.0;\n\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n                  setBezier(input, timeline, bezier++, frame, 3, time, time2, r2, nr2, 1);\n                  setBezier(input, timeline, bezier++, frame, 4, time, time2, g2, ng2, 1);\n                  setBezier(input, timeline, bezier++, frame, 5, time, time2, b2, nb2, 1);\n              }\n              time = time2;\n              r = nr;\n              g = ng;\n              b = nb;\n              r2 = nr2;\n              g2 = ng2;\n              b2 = nb2;\n            }\n            timelines.push(timeline);\n            break;\n          }\n          case SLOT_ALPHA: {\n            const timeline = new AlphaTimeline(frameCount, input.readInt(true), slotIndex);\n            let time = input.readFloat(),\n              a = input.readUnsignedByte() / 255;\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, a);\n              if (frame == frameLast) break;\n              const time2 = input.readFloat();\n              const a2 = input.readUnsignedByte() / 255;\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, a, a2, 1);\n              }\n              time = time2;\n              a = a2;\n            }\n            timelines.push(timeline);\n          }\n        }\n      }\n    }\n\n    // Bone timelines.\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const boneIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const type = input.readByte(),\n          frameCount = input.readInt(true),\n          bezierCount = input.readInt(true);\n        switch (type) {\n          case BONE_ROTATE:\n            timelines.push(readTimeline1(input, new RotateTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_TRANSLATE:\n            timelines.push(readTimeline2(input, new TranslateTimeline(frameCount, bezierCount, boneIndex), scale));\n            break;\n          case BONE_TRANSLATEX:\n            timelines.push(readTimeline1(input, new TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));\n            break;\n          case BONE_TRANSLATEY:\n            timelines.push(readTimeline1(input, new TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));\n            break;\n          case BONE_SCALE:\n            timelines.push(readTimeline2(input, new ScaleTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SCALEX:\n            timelines.push(readTimeline1(input, new ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SCALEY:\n            timelines.push(readTimeline1(input, new ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SHEAR:\n            timelines.push(readTimeline2(input, new ShearTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SHEARX:\n            timelines.push(readTimeline1(input, new ShearXTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SHEARY:\n            timelines.push(readTimeline1(input, new ShearYTimeline(frameCount, bezierCount, boneIndex), 1));\n        }\n      }\n    }\n\n    // IK constraint timelines.\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true),\n        frameCount = input.readInt(true),\n        frameLast = frameCount - 1;\n      const timeline = new IkConstraintTimeline(frameCount, input.readInt(true), index);\n      let time = input.readFloat(),\n        mix = input.readFloat(),\n        softness = input.readFloat() * scale;\n      for (let frame = 0, bezier = 0; ; frame++) {\n        timeline.setFrame(frame, time, mix, softness, input.readByte(), input.readBoolean(), input.readBoolean());\n        if (frame == frameLast) break;\n        const time2 = input.readFloat(),\n          mix2 = input.readFloat(),\n          softness2 = input.readFloat() * scale;\n        switch (input.readByte()) {\n          case CURVE_STEPPED:\n            timeline.setStepped(frame);\n            break;\n          case CURVE_BEZIER:\n            setBezier(input, timeline, bezier++, frame, 0, time, time2, mix, mix2, 1);\n            setBezier(input, timeline, bezier++, frame, 1, time, time2, softness, softness2, scale);\n        }\n        time = time2;\n        mix = mix2;\n        softness = softness2;\n      }\n      timelines.push(timeline);\n    }\n\n    // Transform constraint timelines.\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true),\n        frameCount = input.readInt(true),\n        frameLast = frameCount - 1;\n      const timeline = new TransformConstraintTimeline(frameCount, input.readInt(true), index);\n      let time = input.readFloat(),\n        mixRotate = input.readFloat(),\n        mixX = input.readFloat(),\n        mixY = input.readFloat(),\n        mixScaleX = input.readFloat(),\n        mixScaleY = input.readFloat(),\n        mixShearY = input.readFloat();\n      for (let frame = 0, bezier = 0; ; frame++) {\n        timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n        if (frame == frameLast) break;\n        const time2 = input.readFloat(),\n          mixRotate2 = input.readFloat(),\n          mixX2 = input.readFloat(),\n          mixY2 = input.readFloat(),\n          mixScaleX2 = input.readFloat(),\n          mixScaleY2 = input.readFloat(),\n          mixShearY2 = input.readFloat();\n        switch (input.readByte()) {\n          case CURVE_STEPPED:\n            timeline.setStepped(frame);\n            break;\n          case CURVE_BEZIER:\n            setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n            setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n            setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n            setBezier(input, timeline, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n            setBezier(input, timeline, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n            setBezier(input, timeline, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n        }\n        time = time2;\n        mixRotate = mixRotate2;\n        mixX = mixX2;\n        mixY = mixY2;\n        mixScaleX = mixScaleX2;\n        mixScaleY = mixScaleY2;\n        mixShearY = mixShearY2;\n      }\n      timelines.push(timeline);\n    }\n\n    // Path constraint timelines.\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true);\n      const data = skeletonData.pathConstraints[index];\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        switch (input.readByte()) {\n          case PATH_POSITION:\n            timelines.push(\n              readTimeline1(\n                input,\n                new PathConstraintPositionTimeline(input.readInt(true), input.readInt(true), index),\n                data.positionMode == PositionMode.Fixed ? scale : 1,\n              ),\n            );\n            break;\n          case PATH_SPACING:\n            timelines.push(\n              readTimeline1(\n                input,\n                new PathConstraintSpacingTimeline(input.readInt(true), input.readInt(true), index),\n                data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed ? scale : 1,\n              ),\n            );\n            break;\n          case PATH_MIX:\n            const timeline = new PathConstraintMixTimeline(input.readInt(true), input.readInt(true), index);\n            let time = input.readFloat(),\n              mixRotate = input.readFloat(),\n              mixX = input.readFloat(),\n              mixY = input.readFloat();\n            for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n              timeline.setFrame(frame, time, mixRotate, mixX, mixY);\n              if (frame == frameLast) break;\n              const time2 = input.readFloat(),\n                mixRotate2 = input.readFloat(),\n                mixX2 = input.readFloat(),\n                mixY2 = input.readFloat();\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                  setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n                  setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n              }\n              time = time2;\n              mixRotate = mixRotate2;\n              mixX = mixX2;\n              mixY = mixY2;\n            }\n            timelines.push(timeline);\n        }\n      }\n    }\n\n    // Deform timelines.\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const skin = skeletonData.skins[input.readInt(true)];\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const slotIndex = input.readInt(true);\n        for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\n          const attachmentName = input.readStringRef();\n          if (!attachmentName) throw new Error('attachmentName must not be null.');\n          const attachment = skin.getAttachment(slotIndex, attachmentName);\n          const timelineType = input.readByte();\n          const frameCount = input.readInt(true);\n          const frameLast = frameCount - 1;\n\n          switch (timelineType) {\n            case ATTACHMENT_DEFORM: {\n              const vertexAttachment = attachment as VertexAttachment;\n              const weighted = vertexAttachment.bones;\n              const vertices = vertexAttachment.vertices;\n              const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\n\n              const bezierCount = input.readInt(true);\n              const timeline = new DeformTimeline(frameCount, bezierCount, slotIndex, vertexAttachment);\n\n              let time = input.readFloat();\n              for (let frame = 0, bezier = 0; ; frame++) {\n                let deform;\n                let end = input.readInt(true);\n                if (end == 0) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                else {\n                  deform = Utils.newFloatArray(deformLength);\n                  const start = input.readInt(true);\n                  end += start;\n                  if (scale == 1) {\n                    for (let v = start; v < end; v++) deform[v] = input.readFloat();\n                  } else {\n                    for (let v = start; v < end; v++) deform[v] = input.readFloat() * scale;\n                  }\n                  if (!weighted) {\n                    for (let v = 0, vn = deform.length; v < vn; v++) deform[v] += vertices[v];\n                  }\n                }\n\n                timeline.setFrame(frame, time, deform);\n                if (frame == frameLast) break;\n                const time2 = input.readFloat();\n                switch (input.readByte()) {\n                  case CURVE_STEPPED:\n                    timeline.setStepped(frame);\n                    break;\n                  case CURVE_BEZIER:\n                    setBezier(input, timeline, bezier++, frame, 0, time, time2, 0, 1, 1);\n                }\n                time = time2;\n              }\n              timelines.push(timeline);\n              break;\n            }\n            case ATTACHMENT_SEQUENCE: {\n              const timeline = new SequenceTimeline(frameCount, slotIndex, attachment as unknown as HasTextureRegion);\n              for (let frame = 0; frame < frameCount; frame++) {\n                const time = input.readFloat();\n                const modeAndIndex = input.readInt32();\n                timeline.setFrame(\n                  frame,\n                  time,\n                  SequenceModeValues[modeAndIndex & 0xf],\n                  modeAndIndex >> 4,\n                  input.readFloat(),\n                );\n              }\n              timelines.push(timeline);\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Draw order timeline.\n    const drawOrderCount = input.readInt(true);\n    if (drawOrderCount > 0) {\n      const timeline = new DrawOrderTimeline(drawOrderCount);\n      const slotCount = skeletonData.slots.length;\n      for (let i = 0; i < drawOrderCount; i++) {\n        const time = input.readFloat();\n        const offsetCount = input.readInt(true);\n        const drawOrder = Utils.newArray(slotCount, 0);\n        for (let ii = slotCount - 1; ii >= 0; ii--) drawOrder[ii] = -1;\n        const unchanged = Utils.newArray(slotCount - offsetCount, 0);\n        let originalIndex = 0,\n          unchangedIndex = 0;\n        for (let ii = 0; ii < offsetCount; ii++) {\n          const slotIndex = input.readInt(true);\n          // Collect unchanged items.\n          while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\n          // Set changed items.\n          drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\n        }\n        // Collect remaining unchanged items.\n        while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\n        // Fill in unchanged items.\n        for (let ii = slotCount - 1; ii >= 0; ii--)\n          if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n        timeline.setFrame(i, time, drawOrder);\n      }\n      timelines.push(timeline);\n    }\n\n    // Event timeline.\n    const eventCount = input.readInt(true);\n    if (eventCount > 0) {\n      const timeline = new EventTimeline(eventCount);\n      for (let i = 0; i < eventCount; i++) {\n        const time = input.readFloat();\n        const eventData = skeletonData.events[input.readInt(true)];\n        const event = new Event(time, eventData);\n        event.intValue = input.readInt(false);\n        event.floatValue = input.readFloat();\n        event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\n        if (event.data.audioPath) {\n          event.volume = input.readFloat();\n          event.balance = input.readFloat();\n        }\n        timeline.setFrame(i, event);\n      }\n      timelines.push(timeline);\n    }\n\n    let duration = 0;\n    for (let i = 0, n = timelines.length; i < n; i++) duration = Math.max(duration, timelines[i].getDuration());\n    return new Animation(name, timelines, duration);\n  }\n}\n\nexport class BinaryInput {\n  constructor(\n    data: Uint8Array,\n    public strings = new Array<string>(),\n    private index: number = 0,\n    private buffer = new DataView(data.buffer),\n  ) {}\n\n  readByte(): number {\n    return this.buffer.getInt8(this.index++);\n  }\n\n  readUnsignedByte(): number {\n    return this.buffer.getUint8(this.index++);\n  }\n\n  readShort(): number {\n    const value = this.buffer.getInt16(this.index);\n    this.index += 2;\n    return value;\n  }\n\n  readInt32(): number {\n    const value = this.buffer.getInt32(this.index);\n    this.index += 4;\n    return value;\n  }\n\n  readInt(optimizePositive: boolean) {\n    let b = this.readByte();\n    let result = b & 0x7f;\n    if ((b & 0x80) != 0) {\n      b = this.readByte();\n      result |= (b & 0x7f) << 7;\n      if ((b & 0x80) != 0) {\n        b = this.readByte();\n        result |= (b & 0x7f) << 14;\n        if ((b & 0x80) != 0) {\n          b = this.readByte();\n          result |= (b & 0x7f) << 21;\n          if ((b & 0x80) != 0) {\n            b = this.readByte();\n            result |= (b & 0x7f) << 28;\n          }\n        }\n      }\n    }\n    return optimizePositive ? result : (result >>> 1) ^ -(result & 1);\n  }\n\n  readStringRef(): string | null {\n    const index = this.readInt(true);\n    return index == 0 ? null : this.strings[index - 1];\n  }\n\n  readString(): string | null {\n    let byteCount = this.readInt(true);\n    switch (byteCount) {\n      case 0:\n        return null;\n      case 1:\n        return '';\n    }\n    byteCount--;\n    let chars = '';\n    const charCount = 0;\n    for (let i = 0; i < byteCount; ) {\n      const b = this.readUnsignedByte();\n      switch (b >> 4) {\n        case 12:\n        case 13:\n          chars += String.fromCharCode(((b & 0x1f) << 6) | (this.readByte() & 0x3f));\n          i += 2;\n          break;\n        case 14:\n          chars += String.fromCharCode(((b & 0x0f) << 12) | ((this.readByte() & 0x3f) << 6) | (this.readByte() & 0x3f));\n          i += 3;\n          break;\n        default:\n          chars += String.fromCharCode(b);\n          i++;\n      }\n    }\n    return chars;\n  }\n\n  readFloat(): number {\n    const value = this.buffer.getFloat32(this.index);\n    this.index += 4;\n    return value;\n  }\n\n  readBoolean(): boolean {\n    return this.readByte() != 0;\n  }\n}\n\nclass LinkedMesh {\n  parent: string | null;\n  skin: string | null;\n  slotIndex: number;\n  mesh: MeshAttachment;\n  inheritTimeline: boolean;\n\n  constructor(\n    mesh: MeshAttachment,\n    skin: string | null,\n    slotIndex: number,\n    parent: string | null,\n    inheritDeform: boolean,\n  ) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n    this.inheritTimeline = inheritDeform;\n  }\n}\n\nclass Vertices {\n  constructor(\n    public bones: Array<number> | null = null,\n    public vertices: Array<number> | Float32Array | null = null,\n  ) {}\n}\n\nenum AttachmentType {\n  Region,\n  BoundingBox,\n  Mesh,\n  LinkedMesh,\n  Path,\n  Point,\n  Clipping,\n}\n\nfunction readTimeline1(input: BinaryInput, timeline: CurveTimeline1, scale: number): CurveTimeline1 {\n  let time = input.readFloat(),\n    value = input.readFloat() * scale;\n  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n    timeline.setFrame(frame, time, value);\n    if (frame == frameLast) break;\n    const time2 = input.readFloat(),\n      value2 = input.readFloat() * scale;\n    switch (input.readByte()) {\n      case CURVE_STEPPED:\n        timeline.setStepped(frame);\n        break;\n      case CURVE_BEZIER:\n        setBezier(input, timeline, bezier++, frame, 0, time, time2, value, value2, scale);\n    }\n    time = time2;\n    value = value2;\n  }\n  return timeline;\n}\n\nfunction readTimeline2(input: BinaryInput, timeline: CurveTimeline2, scale: number): CurveTimeline2 {\n  let time = input.readFloat(),\n    value1 = input.readFloat() * scale,\n    value2 = input.readFloat() * scale;\n  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n    timeline.setFrame(frame, time, value1, value2);\n    if (frame == frameLast) break;\n    const time2 = input.readFloat(),\n      nvalue1 = input.readFloat() * scale,\n      nvalue2 = input.readFloat() * scale;\n    switch (input.readByte()) {\n      case CURVE_STEPPED:\n        timeline.setStepped(frame);\n        break;\n      case CURVE_BEZIER:\n        setBezier(input, timeline, bezier++, frame, 0, time, time2, value1, nvalue1, scale);\n        setBezier(input, timeline, bezier++, frame, 1, time, time2, value2, nvalue2, scale);\n    }\n    time = time2;\n    value1 = nvalue1;\n    value2 = nvalue2;\n  }\n  return timeline;\n}\n\nfunction setBezier(\n  input: BinaryInput,\n  timeline: CurveTimeline,\n  bezier: number,\n  frame: number,\n  value: number,\n  time1: number,\n  time2: number,\n  value1: number,\n  value2: number,\n  scale: number,\n) {\n  timeline.setBezier(\n    bezier,\n    frame,\n    value,\n    time1,\n    value1,\n    input.readFloat(),\n    input.readFloat() * scale,\n    input.readFloat(),\n    input.readFloat() * scale,\n    time2,\n    value2,\n  );\n}\n\nconst BONE_ROTATE = 0;\nconst BONE_TRANSLATE = 1;\nconst BONE_TRANSLATEX = 2;\nconst BONE_TRANSLATEY = 3;\nconst BONE_SCALE = 4;\nconst BONE_SCALEX = 5;\nconst BONE_SCALEY = 6;\nconst BONE_SHEAR = 7;\nconst BONE_SHEARX = 8;\nconst BONE_SHEARY = 9;\n\nconst SLOT_ATTACHMENT = 0;\nconst SLOT_RGBA = 1;\nconst SLOT_RGB = 2;\nconst SLOT_RGBA2 = 3;\nconst SLOT_RGB2 = 4;\nconst SLOT_ALPHA = 5;\n\nconst ATTACHMENT_DEFORM = 0;\nconst ATTACHMENT_SEQUENCE = 1;\n\nconst PATH_POSITION = 0;\nconst PATH_SPACING = 1;\nconst PATH_MIX = 2;\n\nconst CURVE_LINEAR = 0;\nconst CURVE_STEPPED = 1;\nconst CURVE_BEZIER = 2;\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { BoundingBoxAttachment } from './attachments/BoundingBoxAttachment';\nimport { Skeleton } from './Skeleton';\nimport { NumberArrayLike, Pool, Utils } from './Utils';\n\n/** Collects each visible {@link BoundingBoxAttachment} and computes the world vertices for its polygon. The polygon vertices are\n * provided along with convenience methods for doing hit detection. */\nexport class SkeletonBounds {\n  /** The left edge of the axis aligned bounding box. */\n  minX = 0;\n\n  /** The bottom edge of the axis aligned bounding box. */\n  minY = 0;\n\n  /** The right edge of the axis aligned bounding box. */\n  maxX = 0;\n\n  /** The top edge of the axis aligned bounding box. */\n  maxY = 0;\n\n  /** The visible bounding boxes. */\n  boundingBoxes = new Array<BoundingBoxAttachment>();\n\n  /** The world vertices for the bounding box polygons. */\n  polygons = new Array<NumberArrayLike>();\n\n  private polygonPool = new Pool<NumberArrayLike>(() => {\n    return Utils.newFloatArray(16);\n  });\n\n  /** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding\n   * box's polygon.\n   * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the\n   *           SkeletonBounds AABB methods will always return true. */\n  update(skeleton: Skeleton, updateAabb: boolean) {\n    if (!skeleton) throw new Error('skeleton cannot be null.');\n    const boundingBoxes = this.boundingBoxes;\n    const polygons = this.polygons;\n    const polygonPool = this.polygonPool;\n    const slots = skeleton.slots;\n    const slotCount = slots.length;\n\n    boundingBoxes.length = 0;\n    polygonPool.freeAll(polygons);\n    polygons.length = 0;\n\n    for (let i = 0; i < slotCount; i++) {\n      const slot = slots[i];\n      if (!slot.bone.active) continue;\n      const attachment = slot.getAttachment();\n      if (attachment instanceof BoundingBoxAttachment) {\n        const boundingBox = attachment as BoundingBoxAttachment;\n        boundingBoxes.push(boundingBox);\n\n        let polygon = polygonPool.obtain();\n        if (polygon.length != boundingBox.worldVerticesLength) {\n          polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\n        }\n        polygons.push(polygon);\n        boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\n      }\n    }\n\n    if (updateAabb) {\n      this.aabbCompute();\n    } else {\n      this.minX = Number.POSITIVE_INFINITY;\n      this.minY = Number.POSITIVE_INFINITY;\n      this.maxX = Number.NEGATIVE_INFINITY;\n      this.maxY = Number.NEGATIVE_INFINITY;\n    }\n  }\n\n  aabbCompute() {\n    let minX = Number.POSITIVE_INFINITY,\n      minY = Number.POSITIVE_INFINITY,\n      maxX = Number.NEGATIVE_INFINITY,\n      maxY = Number.NEGATIVE_INFINITY;\n    const polygons = this.polygons;\n    for (let i = 0, n = polygons.length; i < n; i++) {\n      const polygon = polygons[i];\n      const vertices = polygon;\n      for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n        const x = vertices[ii];\n        const y = vertices[ii + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n      }\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n\n  /** Returns true if the axis aligned bounding box contains the point. */\n  aabbContainsPoint(x: number, y: number) {\n    return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n  }\n\n  /** Returns true if the axis aligned bounding box intersects the line segment. */\n  aabbIntersectsSegment(x1: number, y1: number, x2: number, y2: number) {\n    const minX = this.minX;\n    const minY = this.minY;\n    const maxX = this.maxX;\n    const maxY = this.maxY;\n    if (\n      (x1 <= minX && x2 <= minX) ||\n      (y1 <= minY && y2 <= minY) ||\n      (x1 >= maxX && x2 >= maxX) ||\n      (y1 >= maxY && y2 >= maxY)\n    )\n      return false;\n    const m = (y2 - y1) / (x2 - x1);\n    let y = m * (minX - x1) + y1;\n    if (y > minY && y < maxY) return true;\n    y = m * (maxX - x1) + y1;\n    if (y > minY && y < maxY) return true;\n    let x = (minY - y1) / m + x1;\n    if (x > minX && x < maxX) return true;\n    x = (maxY - y1) / m + x1;\n    if (x > minX && x < maxX) return true;\n    return false;\n  }\n\n  /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\n  aabbIntersectsSkeleton(bounds: SkeletonBounds) {\n    return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n  }\n\n  /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\n   * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\n  containsPoint(x: number, y: number): BoundingBoxAttachment | null {\n    const polygons = this.polygons;\n    for (let i = 0, n = polygons.length; i < n; i++)\n      if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\n    return null;\n  }\n\n  /** Returns true if the polygon contains the point. */\n  containsPointPolygon(polygon: NumberArrayLike, x: number, y: number) {\n    const vertices = polygon;\n    const nn = polygon.length;\n\n    let prevIndex = nn - 2;\n    let inside = false;\n    for (let ii = 0; ii < nn; ii += 2) {\n      const vertexY = vertices[ii + 1];\n      const prevY = vertices[prevIndex + 1];\n      if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\n        const vertexX = vertices[ii];\n        if (vertexX + ((y - vertexY) / (prevY - vertexY)) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\n      }\n      prevIndex = ii;\n    }\n    return inside;\n  }\n\n  /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\n   * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns\n   * true. */\n  intersectsSegment(x1: number, y1: number, x2: number, y2: number) {\n    const polygons = this.polygons;\n    for (let i = 0, n = polygons.length; i < n; i++)\n      if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\n    return null;\n  }\n\n  /** Returns true if the polygon contains any part of the line segment. */\n  intersectsSegmentPolygon(polygon: NumberArrayLike, x1: number, y1: number, x2: number, y2: number) {\n    const vertices = polygon;\n    const nn = polygon.length;\n\n    const width12 = x1 - x2,\n      height12 = y1 - y2;\n    const det1 = x1 * y2 - y1 * x2;\n    let x3 = vertices[nn - 2],\n      y3 = vertices[nn - 1];\n    for (let ii = 0; ii < nn; ii += 2) {\n      const x4 = vertices[ii],\n        y4 = vertices[ii + 1];\n      const det2 = x3 * y4 - y3 * x4;\n      const width34 = x3 - x4,\n        height34 = y3 - y4;\n      const det3 = width12 * height34 - height12 * width34;\n      const x = (det1 * width34 - width12 * det2) / det3;\n      if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\n        const y = (det1 * height34 - height12 * det2) / det3;\n        if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1)))\n          return true;\n      }\n      x3 = x4;\n      y3 = y4;\n    }\n    return false;\n  }\n\n  /** Returns the polygon for the specified bounding box, or null. */\n  getPolygon(boundingBox: BoundingBoxAttachment) {\n    if (!boundingBox) throw new Error('boundingBox cannot be null.');\n    const index = this.boundingBoxes.indexOf(boundingBox);\n    return index == -1 ? null : this.polygons[index];\n  }\n\n  /** The width of the axis aligned bounding box. */\n  getWidth() {\n    return this.maxX - this.minX;\n  }\n\n  /** The height of the axis aligned bounding box. */\n  getHeight() {\n    return this.maxY - this.minY;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { NumberArrayLike, Pool } from './Utils';\n\nexport class Triangulator {\n  private convexPolygons = new Array<Array<number>>();\n  private convexPolygonsIndices = new Array<Array<number>>();\n\n  private indicesArray = new Array<number>();\n  private isConcaveArray = new Array<boolean>();\n  private triangles = new Array<number>();\n\n  private polygonPool = new Pool<Array<number>>(() => {\n    return new Array<number>();\n  });\n\n  private polygonIndicesPool = new Pool<Array<number>>(() => {\n    return new Array<number>();\n  });\n\n  private static isConcave(\n    index: number,\n    vertexCount: number,\n    vertices: NumberArrayLike,\n    indices: NumberArrayLike,\n  ): boolean {\n    const previous = indices[(vertexCount + index - 1) % vertexCount] << 1;\n    const current = indices[index] << 1;\n    const next = indices[(index + 1) % vertexCount] << 1;\n    return !this.positiveArea(\n      vertices[previous],\n      vertices[previous + 1],\n      vertices[current],\n      vertices[current + 1],\n      vertices[next],\n      vertices[next + 1],\n    );\n  }\n\n  private static positiveArea(p1x: number, p1y: number, p2x: number, p2y: number, p3x: number, p3y: number): boolean {\n    return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;\n  }\n\n  private static winding(p1x: number, p1y: number, p2x: number, p2y: number, p3x: number, p3y: number): number {\n    const px = p2x - p1x,\n      py = p2y - p1y;\n    return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;\n  }\n\n  public triangulate(verticesArray: NumberArrayLike): Array<number> {\n    const vertices = verticesArray;\n    let vertexCount = verticesArray.length >> 1;\n\n    const indices = this.indicesArray;\n    indices.length = 0;\n    for (let i = 0; i < vertexCount; i++) indices[i] = i;\n\n    const isConcave = this.isConcaveArray;\n    isConcave.length = 0;\n    for (let i = 0, n = vertexCount; i < n; ++i)\n      isConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);\n\n    const triangles = this.triangles;\n    triangles.length = 0;\n\n    while (vertexCount > 3) {\n      // Find ear tip.\n      let previous = vertexCount - 1,\n        i = 0,\n        next = 1;\n      while (true) {\n        outer: if (!isConcave[i]) {\n          const p1 = indices[previous] << 1,\n            p2 = indices[i] << 1,\n            p3 = indices[next] << 1;\n          const p1x = vertices[p1],\n            p1y = vertices[p1 + 1];\n          const p2x = vertices[p2],\n            p2y = vertices[p2 + 1];\n          const p3x = vertices[p3],\n            p3y = vertices[p3 + 1];\n          for (let ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {\n            if (!isConcave[ii]) continue;\n            const v = indices[ii] << 1;\n            const vx = vertices[v],\n              vy = vertices[v + 1];\n            if (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {\n              if (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {\n                if (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy)) break outer;\n              }\n            }\n          }\n          break;\n        }\n\n        if (next == 0) {\n          do {\n            if (!isConcave[i]) break;\n            i--;\n          } while (i > 0);\n          break;\n        }\n\n        previous = i;\n        i = next;\n        next = (next + 1) % vertexCount;\n      }\n\n      // Cut ear tip.\n      triangles.push(indices[(vertexCount + i - 1) % vertexCount]);\n      triangles.push(indices[i]);\n      triangles.push(indices[(i + 1) % vertexCount]);\n      indices.splice(i, 1);\n      isConcave.splice(i, 1);\n      vertexCount--;\n\n      const previousIndex = (vertexCount + i - 1) % vertexCount;\n      const nextIndex = i == vertexCount ? 0 : i;\n      isConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);\n      isConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);\n    }\n\n    if (vertexCount == 3) {\n      triangles.push(indices[2]);\n      triangles.push(indices[0]);\n      triangles.push(indices[1]);\n    }\n\n    return triangles;\n  }\n\n  decompose(verticesArray: Array<number>, triangles: Array<number>): Array<Array<number>> {\n    const vertices = verticesArray;\n    const convexPolygons = this.convexPolygons;\n    this.polygonPool.freeAll(convexPolygons);\n    convexPolygons.length = 0;\n\n    const convexPolygonsIndices = this.convexPolygonsIndices;\n    this.polygonIndicesPool.freeAll(convexPolygonsIndices);\n    convexPolygonsIndices.length = 0;\n\n    let polygonIndices = this.polygonIndicesPool.obtain();\n    polygonIndices.length = 0;\n\n    let polygon = this.polygonPool.obtain();\n    polygon.length = 0;\n\n    // Merge subsequent triangles if they form a triangle fan.\n    let fanBaseIndex = -1,\n      lastWinding = 0;\n    for (let i = 0, n = triangles.length; i < n; i += 3) {\n      const t1 = triangles[i] << 1,\n        t2 = triangles[i + 1] << 1,\n        t3 = triangles[i + 2] << 1;\n      const x1 = vertices[t1],\n        y1 = vertices[t1 + 1];\n      const x2 = vertices[t2],\n        y2 = vertices[t2 + 1];\n      const x3 = vertices[t3],\n        y3 = vertices[t3 + 1];\n\n      // If the base of the last triangle is the same as this triangle, check if they form a convex polygon (triangle fan).\n      let merged = false;\n      if (fanBaseIndex == t1) {\n        const o = polygon.length - 4;\n        const winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);\n        const winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);\n        if (winding1 == lastWinding && winding2 == lastWinding) {\n          polygon.push(x3);\n          polygon.push(y3);\n          polygonIndices.push(t3);\n          merged = true;\n        }\n      }\n\n      // Otherwise make this triangle the new base.\n      if (!merged) {\n        if (polygon.length > 0) {\n          convexPolygons.push(polygon);\n          convexPolygonsIndices.push(polygonIndices);\n        } else {\n          this.polygonPool.free(polygon);\n          this.polygonIndicesPool.free(polygonIndices);\n        }\n        polygon = this.polygonPool.obtain();\n        polygon.length = 0;\n        polygon.push(x1);\n        polygon.push(y1);\n        polygon.push(x2);\n        polygon.push(y2);\n        polygon.push(x3);\n        polygon.push(y3);\n        polygonIndices = this.polygonIndicesPool.obtain();\n        polygonIndices.length = 0;\n        polygonIndices.push(t1);\n        polygonIndices.push(t2);\n        polygonIndices.push(t3);\n        lastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);\n        fanBaseIndex = t1;\n      }\n    }\n\n    if (polygon.length > 0) {\n      convexPolygons.push(polygon);\n      convexPolygonsIndices.push(polygonIndices);\n    }\n\n    // Go through the list of polygons and try to merge the remaining triangles with the found triangle fans.\n    for (let i = 0, n = convexPolygons.length; i < n; i++) {\n      polygonIndices = convexPolygonsIndices[i];\n      if (polygonIndices.length == 0) continue;\n      const firstIndex = polygonIndices[0];\n      const lastIndex = polygonIndices[polygonIndices.length - 1];\n\n      polygon = convexPolygons[i];\n      const o = polygon.length - 4;\n      let prevPrevX = polygon[o],\n        prevPrevY = polygon[o + 1];\n      let prevX = polygon[o + 2],\n        prevY = polygon[o + 3];\n      const firstX = polygon[0],\n        firstY = polygon[1];\n      const secondX = polygon[2],\n        secondY = polygon[3];\n      const winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);\n\n      for (let ii = 0; ii < n; ii++) {\n        if (ii == i) continue;\n        const otherIndices = convexPolygonsIndices[ii];\n        if (otherIndices.length != 3) continue;\n        const otherFirstIndex = otherIndices[0];\n        const otherSecondIndex = otherIndices[1];\n        const otherLastIndex = otherIndices[2];\n\n        const otherPoly = convexPolygons[ii];\n        const x3 = otherPoly[otherPoly.length - 2],\n          y3 = otherPoly[otherPoly.length - 1];\n\n        if (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex) continue;\n        const winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);\n        const winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);\n        if (winding1 == winding && winding2 == winding) {\n          otherPoly.length = 0;\n          otherIndices.length = 0;\n          polygon.push(x3);\n          polygon.push(y3);\n          polygonIndices.push(otherLastIndex);\n          prevPrevX = prevX;\n          prevPrevY = prevY;\n          prevX = x3;\n          prevY = y3;\n          ii = 0;\n        }\n      }\n    }\n\n    // Remove empty polygons that resulted from the merge step above.\n    for (let i = convexPolygons.length - 1; i >= 0; i--) {\n      polygon = convexPolygons[i];\n      if (polygon.length == 0) {\n        convexPolygons.splice(i, 1);\n        this.polygonPool.free(polygon);\n        polygonIndices = convexPolygonsIndices[i];\n        convexPolygonsIndices.splice(i, 1);\n        this.polygonIndicesPool.free(polygonIndices);\n      }\n    }\n\n    return convexPolygons;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { ClippingAttachment } from './attachments/ClippingAttachment';\nimport { Slot } from './Slot';\nimport { Triangulator } from './Triangulator';\nimport { Color, NumberArrayLike, Utils } from './Utils';\n\nexport class SkeletonClipping {\n  clippedVertices = new Array<number>();\n  clippedTriangles = new Array<number>();\n  private triangulator = new Triangulator();\n  private clippingPolygon = new Array<number>();\n  private clipOutput = new Array<number>();\n  private scratch = new Array<number>();\n\n  private clipAttachment: ClippingAttachment | null = null;\n  private clippingPolygons: Array<Array<number>> | null = null;\n\n  public static makeClockwise(polygon: NumberArrayLike) {\n    const vertices = polygon;\n    const verticeslength = polygon.length;\n\n    let area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1],\n      p1x = 0,\n      p1y = 0,\n      p2x = 0,\n      p2y = 0;\n    for (let i = 0, n = verticeslength - 3; i < n; i += 2) {\n      p1x = vertices[i];\n      p1y = vertices[i + 1];\n      p2x = vertices[i + 2];\n      p2y = vertices[i + 3];\n      area += p1x * p2y - p2x * p1y;\n    }\n    if (area < 0) return;\n\n    for (let i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {\n      const x = vertices[i],\n        y = vertices[i + 1];\n      const other = lastX - i;\n      vertices[i] = vertices[other];\n      vertices[i + 1] = vertices[other + 1];\n      vertices[other] = x;\n      vertices[other + 1] = y;\n    }\n  }\n\n  clipStart(slot: Slot, clip: ClippingAttachment): number {\n    if (this.clipAttachment) return 0;\n    this.clipAttachment = clip;\n\n    const n = clip.worldVerticesLength;\n    const vertices = Utils.setArraySize(this.clippingPolygon, n);\n    clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n    const clippingPolygon = this.clippingPolygon;\n    SkeletonClipping.makeClockwise(clippingPolygon);\n    const clippingPolygons = (this.clippingPolygons = this.triangulator.decompose(\n      clippingPolygon,\n      this.triangulator.triangulate(clippingPolygon),\n    ));\n    for (let i = 0, n = clippingPolygons.length; i < n; i++) {\n      const polygon = clippingPolygons[i];\n      SkeletonClipping.makeClockwise(polygon);\n      polygon.push(polygon[0]);\n      polygon.push(polygon[1]);\n    }\n\n    return clippingPolygons.length;\n  }\n\n  clipEndWithSlot(slot: Slot) {\n    if (this.clipAttachment && this.clipAttachment.endSlot == slot.data) this.clipEnd();\n  }\n\n  clipEnd() {\n    if (!this.clipAttachment) return;\n    this.clipAttachment = null;\n    this.clippingPolygons = null;\n    this.clippedVertices.length = 0;\n    this.clippedTriangles.length = 0;\n    this.clippingPolygon.length = 0;\n  }\n\n  isClipping(): boolean {\n    return this.clipAttachment != null;\n  }\n\n  clipTriangles(\n    vertices: NumberArrayLike,\n    verticesLength: number,\n    triangles: NumberArrayLike,\n    trianglesLength: number,\n    uvs: NumberArrayLike,\n    light: Color,\n    dark: Color,\n    twoColor: boolean,\n  ) {\n    const clipOutput = this.clipOutput,\n      clippedVertices = this.clippedVertices;\n    const clippedTriangles = this.clippedTriangles;\n    const polygons = this.clippingPolygons!;\n    const polygonsCount = polygons.length;\n    const vertexSize = twoColor ? 12 : 8;\n\n    let index = 0;\n    clippedVertices.length = 0;\n    clippedTriangles.length = 0;\n    outer: for (let i = 0; i < trianglesLength; i += 3) {\n      let vertexOffset = triangles[i] << 1;\n      const x1 = vertices[vertexOffset],\n        y1 = vertices[vertexOffset + 1];\n      const u1 = uvs[vertexOffset],\n        v1 = uvs[vertexOffset + 1];\n\n      vertexOffset = triangles[i + 1] << 1;\n      const x2 = vertices[vertexOffset],\n        y2 = vertices[vertexOffset + 1];\n      const u2 = uvs[vertexOffset],\n        v2 = uvs[vertexOffset + 1];\n\n      vertexOffset = triangles[i + 2] << 1;\n      const x3 = vertices[vertexOffset],\n        y3 = vertices[vertexOffset + 1];\n      const u3 = uvs[vertexOffset],\n        v3 = uvs[vertexOffset + 1];\n\n      for (let p = 0; p < polygonsCount; p++) {\n        let s = clippedVertices.length;\n        if (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\n          const clipOutputLength = clipOutput.length;\n          if (clipOutputLength == 0) continue;\n          const d0 = y2 - y3,\n            d1 = x3 - x2,\n            d2 = x1 - x3,\n            d4 = y3 - y1;\n          const d = 1 / (d0 * d2 + d1 * (y1 - y3));\n\n          let clipOutputCount = clipOutputLength >> 1;\n          const clipOutputItems = this.clipOutput;\n          const clippedVerticesItems = Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);\n          for (let ii = 0; ii < clipOutputLength; ii += 2) {\n            const x = clipOutputItems[ii],\n              y = clipOutputItems[ii + 1];\n            clippedVerticesItems[s] = x;\n            clippedVerticesItems[s + 1] = y;\n            clippedVerticesItems[s + 2] = light.r;\n            clippedVerticesItems[s + 3] = light.g;\n            clippedVerticesItems[s + 4] = light.b;\n            clippedVerticesItems[s + 5] = light.a;\n            const c0 = x - x3,\n              c1 = y - y3;\n            const a = (d0 * c0 + d1 * c1) * d;\n            const b = (d4 * c0 + d2 * c1) * d;\n            const c = 1 - a - b;\n            clippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;\n            clippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;\n            if (twoColor) {\n              clippedVerticesItems[s + 8] = dark.r;\n              clippedVerticesItems[s + 9] = dark.g;\n              clippedVerticesItems[s + 10] = dark.b;\n              clippedVerticesItems[s + 11] = dark.a;\n            }\n            s += vertexSize;\n          }\n\n          s = clippedTriangles.length;\n          const clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\n          clipOutputCount--;\n          for (let ii = 1; ii < clipOutputCount; ii++) {\n            clippedTrianglesItems[s] = index;\n            clippedTrianglesItems[s + 1] = index + ii;\n            clippedTrianglesItems[s + 2] = index + ii + 1;\n            s += 3;\n          }\n          index += clipOutputCount + 1;\n        } else {\n          const clippedVerticesItems = Utils.setArraySize(clippedVertices, s + 3 * vertexSize);\n          clippedVerticesItems[s] = x1;\n          clippedVerticesItems[s + 1] = y1;\n          clippedVerticesItems[s + 2] = light.r;\n          clippedVerticesItems[s + 3] = light.g;\n          clippedVerticesItems[s + 4] = light.b;\n          clippedVerticesItems[s + 5] = light.a;\n          if (!twoColor) {\n            clippedVerticesItems[s + 6] = u1;\n            clippedVerticesItems[s + 7] = v1;\n\n            clippedVerticesItems[s + 8] = x2;\n            clippedVerticesItems[s + 9] = y2;\n            clippedVerticesItems[s + 10] = light.r;\n            clippedVerticesItems[s + 11] = light.g;\n            clippedVerticesItems[s + 12] = light.b;\n            clippedVerticesItems[s + 13] = light.a;\n            clippedVerticesItems[s + 14] = u2;\n            clippedVerticesItems[s + 15] = v2;\n\n            clippedVerticesItems[s + 16] = x3;\n            clippedVerticesItems[s + 17] = y3;\n            clippedVerticesItems[s + 18] = light.r;\n            clippedVerticesItems[s + 19] = light.g;\n            clippedVerticesItems[s + 20] = light.b;\n            clippedVerticesItems[s + 21] = light.a;\n            clippedVerticesItems[s + 22] = u3;\n            clippedVerticesItems[s + 23] = v3;\n          } else {\n            clippedVerticesItems[s + 6] = u1;\n            clippedVerticesItems[s + 7] = v1;\n            clippedVerticesItems[s + 8] = dark.r;\n            clippedVerticesItems[s + 9] = dark.g;\n            clippedVerticesItems[s + 10] = dark.b;\n            clippedVerticesItems[s + 11] = dark.a;\n\n            clippedVerticesItems[s + 12] = x2;\n            clippedVerticesItems[s + 13] = y2;\n            clippedVerticesItems[s + 14] = light.r;\n            clippedVerticesItems[s + 15] = light.g;\n            clippedVerticesItems[s + 16] = light.b;\n            clippedVerticesItems[s + 17] = light.a;\n            clippedVerticesItems[s + 18] = u2;\n            clippedVerticesItems[s + 19] = v2;\n            clippedVerticesItems[s + 20] = dark.r;\n            clippedVerticesItems[s + 21] = dark.g;\n            clippedVerticesItems[s + 22] = dark.b;\n            clippedVerticesItems[s + 23] = dark.a;\n\n            clippedVerticesItems[s + 24] = x3;\n            clippedVerticesItems[s + 25] = y3;\n            clippedVerticesItems[s + 26] = light.r;\n            clippedVerticesItems[s + 27] = light.g;\n            clippedVerticesItems[s + 28] = light.b;\n            clippedVerticesItems[s + 29] = light.a;\n            clippedVerticesItems[s + 30] = u3;\n            clippedVerticesItems[s + 31] = v3;\n            clippedVerticesItems[s + 32] = dark.r;\n            clippedVerticesItems[s + 33] = dark.g;\n            clippedVerticesItems[s + 34] = dark.b;\n            clippedVerticesItems[s + 35] = dark.a;\n          }\n\n          s = clippedTriangles.length;\n          const clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s + 3);\n          clippedTrianglesItems[s] = index;\n          clippedTrianglesItems[s + 1] = index + 1;\n          clippedTrianglesItems[s + 2] = index + 2;\n          index += 3;\n          continue outer;\n        }\n      }\n    }\n  }\n\n  /** Clips the input triangle against the convex, clockwise clipping area. If the triangle lies entirely within the clipping\n   * area, false is returned. The clipping area must duplicate the first vertex at the end of the vertices list. */\n  clip(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    x3: number,\n    y3: number,\n    clippingArea: Array<number>,\n    output: Array<number>,\n  ) {\n    const originalOutput = output;\n    let clipped = false;\n\n    // Avoid copy at the end.\n    let input: Array<number>;\n    if (clippingArea.length % 4 >= 2) {\n      input = output;\n      output = this.scratch;\n    } else input = this.scratch;\n\n    input.length = 0;\n    input.push(x1);\n    input.push(y1);\n    input.push(x2);\n    input.push(y2);\n    input.push(x3);\n    input.push(y3);\n    input.push(x1);\n    input.push(y1);\n    output.length = 0;\n\n    const clippingVertices = clippingArea;\n    const clippingVerticesLast = clippingArea.length - 4;\n    for (let i = 0; ; i += 2) {\n      const edgeX = clippingVertices[i],\n        edgeY = clippingVertices[i + 1];\n      const edgeX2 = clippingVertices[i + 2],\n        edgeY2 = clippingVertices[i + 3];\n      const deltaX = edgeX - edgeX2,\n        deltaY = edgeY - edgeY2;\n\n      const inputVertices = input;\n      const inputVerticesLength = input.length - 2,\n        outputStart = output.length;\n      for (let ii = 0; ii < inputVerticesLength; ii += 2) {\n        const inputX = inputVertices[ii],\n          inputY = inputVertices[ii + 1];\n        const inputX2 = inputVertices[ii + 2],\n          inputY2 = inputVertices[ii + 3];\n        const side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;\n        if (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {\n          if (side2) {\n            // v1 inside, v2 inside\n            output.push(inputX2);\n            output.push(inputY2);\n            continue;\n          }\n          // v1 inside, v2 outside\n          const c0 = inputY2 - inputY,\n            c2 = inputX2 - inputX;\n          const s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);\n          if (Math.abs(s) > 0.000001) {\n            const ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;\n            output.push(edgeX + (edgeX2 - edgeX) * ua);\n            output.push(edgeY + (edgeY2 - edgeY) * ua);\n          } else {\n            output.push(edgeX);\n            output.push(edgeY);\n          }\n        } else if (side2) {\n          // v1 outside, v2 inside\n          const c0 = inputY2 - inputY,\n            c2 = inputX2 - inputX;\n          const s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);\n          if (Math.abs(s) > 0.000001) {\n            const ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;\n            output.push(edgeX + (edgeX2 - edgeX) * ua);\n            output.push(edgeY + (edgeY2 - edgeY) * ua);\n          } else {\n            output.push(edgeX);\n            output.push(edgeY);\n          }\n          output.push(inputX2);\n          output.push(inputY2);\n        }\n        clipped = true;\n      }\n\n      if (outputStart == output.length) {\n        // All edges outside.\n        originalOutput.length = 0;\n        return true;\n      }\n\n      output.push(output[0]);\n      output.push(output[1]);\n\n      if (i == clippingVerticesLast) break;\n      const temp = output;\n      output = input;\n      output.length = 0;\n      input = temp;\n    }\n\n    if (originalOutput != output) {\n      originalOutput.length = 0;\n      for (let i = 0, n = output.length - 2; i < n; i++) originalOutput[i] = output[i];\n    } else originalOutput.length = originalOutput.length - 2;\n\n    return clipped;\n  }\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport {\n  AlphaTimeline,\n  Animation,\n  AttachmentTimeline,\n  CurveTimeline,\n  CurveTimeline1,\n  CurveTimeline2,\n  DeformTimeline,\n  DrawOrderTimeline,\n  EventTimeline,\n  IkConstraintTimeline,\n  PathConstraintMixTimeline,\n  PathConstraintPositionTimeline,\n  PathConstraintSpacingTimeline,\n  RGB2Timeline,\n  RGBA2Timeline,\n  RGBATimeline,\n  RGBTimeline,\n  RotateTimeline,\n  ScaleTimeline,\n  ScaleXTimeline,\n  ScaleYTimeline,\n  SequenceTimeline,\n  ShearTimeline,\n  ShearXTimeline,\n  ShearYTimeline,\n  Timeline,\n  TransformConstraintTimeline,\n  TranslateTimeline,\n  TranslateXTimeline,\n  TranslateYTimeline,\n} from './Animation';\nimport { Attachment, VertexAttachment } from './attachments/Attachment';\nimport { AttachmentLoader } from './attachments/AttachmentLoader';\nimport { HasTextureRegion } from './attachments/HasTextureRegion';\nimport { MeshAttachment } from './attachments/MeshAttachment';\nimport { Sequence, SequenceMode } from './attachments/Sequence';\nimport { BoneData, TransformMode } from './BoneData';\nimport { Event } from './Event';\nimport { EventData } from './EventData';\nimport { IkConstraintData } from './IkConstraintData';\nimport { PathConstraintData, PositionMode, RotateMode, SpacingMode } from './PathConstraintData';\nimport { SkeletonData } from './SkeletonData';\nimport { Skin } from './Skin';\nimport { BlendMode, SlotData } from './SlotData';\nimport { TransformConstraintData } from './TransformConstraintData';\nimport { Color, NumberArrayLike, Utils } from './Utils';\n\n/** Loads skeleton data in the Spine JSON format.\n *\n * See [Spine JSON format](http://esotericsoftware.com/spine-json-format) and\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\n * Runtimes Guide. */\nexport class SkeletonJson {\n  attachmentLoader: AttachmentLoader;\n\n  /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\n   * runtime than were used in Spine.\n   *\n   * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n  scale = 1;\n  private linkedMeshes = new Array<LinkedMesh>();\n\n  constructor(attachmentLoader: AttachmentLoader) {\n    this.attachmentLoader = attachmentLoader;\n  }\n\n  readSkeletonData(json: string | any): SkeletonData {\n    const scale = this.scale;\n    const skeletonData = new SkeletonData();\n    const root = typeof json === 'string' ? JSON.parse(json) : json;\n\n    // Skeleton\n    const skeletonMap = root.skeleton;\n    if (skeletonMap) {\n      skeletonData.hash = skeletonMap.hash;\n      skeletonData.version = skeletonMap.spine;\n      skeletonData.x = skeletonMap.x;\n      skeletonData.y = skeletonMap.y;\n      skeletonData.width = skeletonMap.width;\n      skeletonData.height = skeletonMap.height;\n      skeletonData.fps = skeletonMap.fps;\n      skeletonData.imagesPath = skeletonMap.images;\n    }\n\n    // Bones\n    if (root.bones) {\n      for (let i = 0; i < root.bones.length; i++) {\n        const boneMap = root.bones[i];\n\n        let parent: BoneData | null = null;\n        const parentName: string = getValue(boneMap, 'parent', null);\n        if (parentName) parent = skeletonData.findBone(parentName);\n        const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n        data.length = getValue(boneMap, 'length', 0) * scale;\n        data.x = getValue(boneMap, 'x', 0) * scale;\n        data.y = getValue(boneMap, 'y', 0) * scale;\n        data.rotation = getValue(boneMap, 'rotation', 0);\n        data.scaleX = getValue(boneMap, 'scaleX', 1);\n        data.scaleY = getValue(boneMap, 'scaleY', 1);\n        data.shearX = getValue(boneMap, 'shearX', 0);\n        data.shearY = getValue(boneMap, 'shearY', 0);\n        data.transformMode = Utils.enumValue(TransformMode, getValue(boneMap, 'transform', 'Normal'));\n        data.skinRequired = getValue(boneMap, 'skin', false);\n\n        const color = getValue(boneMap, 'color', null);\n        if (color) data.color.setFromString(color);\n\n        skeletonData.bones.push(data);\n      }\n    }\n\n    // Slots.\n    if (root.slots) {\n      for (let i = 0; i < root.slots.length; i++) {\n        const slotMap = root.slots[i];\n        const boneData = skeletonData.findBone(slotMap.bone);\n        if (!boneData) throw new Error(`Couldn't find bone ${slotMap.bone} for slot ${slotMap.name}`);\n        const data = new SlotData(skeletonData.slots.length, slotMap.name, boneData);\n\n        const color: string = getValue(slotMap, 'color', null);\n        if (color) data.color.setFromString(color);\n\n        const dark: string = getValue(slotMap, 'dark', null);\n        if (dark) data.darkColor = Color.fromString(dark);\n\n        data.attachmentName = getValue(slotMap, 'attachment', null);\n        data.blendMode = Utils.enumValue(BlendMode, getValue(slotMap, 'blend', 'normal'));\n        skeletonData.slots.push(data);\n      }\n    }\n\n    // IK constraints\n    if (root.ik) {\n      for (let i = 0; i < root.ik.length; i++) {\n        const constraintMap = root.ik[i];\n        const data = new IkConstraintData(constraintMap.name);\n        data.order = getValue(constraintMap, 'order', 0);\n        data.skinRequired = getValue(constraintMap, 'skin', false);\n\n        for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n          const bone = skeletonData.findBone(constraintMap.bones[ii]);\n          if (!bone)\n            throw new Error(`Couldn't find bone ${constraintMap.bones[ii]} for IK constraint ${constraintMap.name}.`);\n          data.bones.push(bone);\n        }\n\n        const target = skeletonData.findBone(constraintMap.target);\n        if (!target)\n          throw new Error(`Couldn't find target bone ${constraintMap.target} for IK constraint ${constraintMap.name}.`);\n        data.target = target;\n\n        data.mix = getValue(constraintMap, 'mix', 1);\n        data.softness = getValue(constraintMap, 'softness', 0) * scale;\n        data.bendDirection = getValue(constraintMap, 'bendPositive', true) ? 1 : -1;\n        data.compress = getValue(constraintMap, 'compress', false);\n        data.stretch = getValue(constraintMap, 'stretch', false);\n        data.uniform = getValue(constraintMap, 'uniform', false);\n\n        skeletonData.ikConstraints.push(data);\n      }\n    }\n\n    // Transform constraints.\n    if (root.transform) {\n      for (let i = 0; i < root.transform.length; i++) {\n        const constraintMap = root.transform[i];\n        const data = new TransformConstraintData(constraintMap.name);\n        data.order = getValue(constraintMap, 'order', 0);\n        data.skinRequired = getValue(constraintMap, 'skin', false);\n\n        for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n          const boneName = constraintMap.bones[ii];\n          const bone = skeletonData.findBone(boneName);\n          if (!bone) throw new Error(`Couldn't find bone ${boneName} for transform constraint ${constraintMap.name}.`);\n          data.bones.push(bone);\n        }\n\n        const targetName: string = constraintMap.target;\n        const target = skeletonData.findBone(targetName);\n        if (!target)\n          throw new Error(`Couldn't find target bone ${targetName} for transform constraint ${constraintMap.name}.`);\n        data.target = target;\n\n        data.local = getValue(constraintMap, 'local', false);\n        data.relative = getValue(constraintMap, 'relative', false);\n        data.offsetRotation = getValue(constraintMap, 'rotation', 0);\n        data.offsetX = getValue(constraintMap, 'x', 0) * scale;\n        data.offsetY = getValue(constraintMap, 'y', 0) * scale;\n        data.offsetScaleX = getValue(constraintMap, 'scaleX', 0);\n        data.offsetScaleY = getValue(constraintMap, 'scaleY', 0);\n        data.offsetShearY = getValue(constraintMap, 'shearY', 0);\n\n        data.mixRotate = getValue(constraintMap, 'mixRotate', 1);\n        data.mixX = getValue(constraintMap, 'mixX', 1);\n        data.mixY = getValue(constraintMap, 'mixY', data.mixX);\n        data.mixScaleX = getValue(constraintMap, 'mixScaleX', 1);\n        data.mixScaleY = getValue(constraintMap, 'mixScaleY', data.mixScaleX);\n        data.mixShearY = getValue(constraintMap, 'mixShearY', 1);\n\n        skeletonData.transformConstraints.push(data);\n      }\n    }\n\n    // Path constraints.\n    if (root.path) {\n      for (let i = 0; i < root.path.length; i++) {\n        const constraintMap = root.path[i];\n        const data = new PathConstraintData(constraintMap.name);\n        data.order = getValue(constraintMap, 'order', 0);\n        data.skinRequired = getValue(constraintMap, 'skin', false);\n\n        for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n          const boneName = constraintMap.bones[ii];\n          const bone = skeletonData.findBone(boneName);\n          if (!bone) throw new Error(`Couldn't find bone ${boneName} for path constraint ${constraintMap.name}.`);\n          data.bones.push(bone);\n        }\n\n        const targetName: string = constraintMap.target;\n        const target = skeletonData.findSlot(targetName);\n        if (!target)\n          throw new Error(`Couldn't find target slot ${targetName} for path constraint ${constraintMap.name}.`);\n        data.target = target;\n\n        data.positionMode = Utils.enumValue(PositionMode, getValue(constraintMap, 'positionMode', 'Percent'));\n        data.spacingMode = Utils.enumValue(SpacingMode, getValue(constraintMap, 'spacingMode', 'Length'));\n        data.rotateMode = Utils.enumValue(RotateMode, getValue(constraintMap, 'rotateMode', 'Tangent'));\n        data.offsetRotation = getValue(constraintMap, 'rotation', 0);\n        data.position = getValue(constraintMap, 'position', 0);\n        if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n        data.spacing = getValue(constraintMap, 'spacing', 0);\n        if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n        data.mixRotate = getValue(constraintMap, 'mixRotate', 1);\n        data.mixX = getValue(constraintMap, 'mixX', 1);\n        data.mixY = getValue(constraintMap, 'mixY', data.mixX);\n\n        skeletonData.pathConstraints.push(data);\n      }\n    }\n\n    // Skins.\n    if (root.skins) {\n      for (let i = 0; i < root.skins.length; i++) {\n        const skinMap = root.skins[i];\n        const skin = new Skin(skinMap.name);\n\n        if (skinMap.bones) {\n          for (let ii = 0; ii < skinMap.bones.length; ii++) {\n            const boneName = skinMap.bones[ii];\n            const bone = skeletonData.findBone(boneName);\n            if (!bone) throw new Error(`Couldn't find bone ${boneName} for skin ${skinMap.name}.`);\n            skin.bones.push(bone);\n          }\n        }\n\n        if (skinMap.ik) {\n          for (let ii = 0; ii < skinMap.ik.length; ii++) {\n            const constraintName = skinMap.ik[ii];\n            const constraint = skeletonData.findIkConstraint(constraintName);\n            if (!constraint) throw new Error(`Couldn't find IK constraint ${constraintName} for skin ${skinMap.name}.`);\n            skin.constraints.push(constraint);\n          }\n        }\n\n        if (skinMap.transform) {\n          for (let ii = 0; ii < skinMap.transform.length; ii++) {\n            const constraintName = skinMap.transform[ii];\n            const constraint = skeletonData.findTransformConstraint(constraintName);\n            if (!constraint)\n              throw new Error(`Couldn't find transform constraint ${constraintName} for skin ${skinMap.name}.`);\n            skin.constraints.push(constraint);\n          }\n        }\n\n        if (skinMap.path) {\n          for (let ii = 0; ii < skinMap.path.length; ii++) {\n            const constraintName = skinMap.path[ii];\n            const constraint = skeletonData.findPathConstraint(constraintName);\n            if (!constraint)\n              throw new Error(`Couldn't find path constraint ${constraintName} for skin ${skinMap.name}.`);\n            skin.constraints.push(constraint);\n          }\n        }\n        for (const slotName in skinMap.attachments) {\n          const slot = skeletonData.findSlot(slotName);\n          if (!slot) throw new Error(`Couldn't find slot ${slotName} for skin ${skinMap.name}.`);\n          const slotMap = skinMap.attachments[slotName];\n          for (const entryName in slotMap) {\n            const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\n            if (attachment) skin.setAttachment(slot.index, entryName, attachment);\n          }\n        }\n        skeletonData.skins.push(skin);\n        if (skin.name == 'default') skeletonData.defaultSkin = skin;\n      }\n    }\n\n    // Linked meshes.\n    for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n      const linkedMesh = this.linkedMeshes[i];\n      const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n      if (!skin) throw new Error(`Skin not found: ${linkedMesh.skin}`);\n      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n      if (!parent) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n      linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline\n        ? <VertexAttachment>parent\n        : <VertexAttachment>linkedMesh.mesh;\n      linkedMesh.mesh.setParentMesh(<MeshAttachment>parent);\n      if (linkedMesh.mesh.region != null) linkedMesh.mesh.updateRegion();\n    }\n    this.linkedMeshes.length = 0;\n\n    // Events.\n    if (root.events) {\n      for (const eventName in root.events) {\n        const eventMap = root.events[eventName];\n        const data = new EventData(eventName);\n        data.intValue = getValue(eventMap, 'int', 0);\n        data.floatValue = getValue(eventMap, 'float', 0);\n        data.stringValue = getValue(eventMap, 'string', '');\n        data.audioPath = getValue(eventMap, 'audio', null);\n        if (data.audioPath) {\n          data.volume = getValue(eventMap, 'volume', 1);\n          data.balance = getValue(eventMap, 'balance', 0);\n        }\n        skeletonData.events.push(data);\n      }\n    }\n\n    // Animations.\n    if (root.animations) {\n      for (const animationName in root.animations) {\n        const animationMap = root.animations[animationName];\n        this.readAnimation(animationMap, animationName, skeletonData);\n      }\n    }\n\n    return skeletonData;\n  }\n\n  readAttachment(map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment | null {\n    const scale = this.scale;\n    name = getValue(map, 'name', name);\n\n    switch (getValue(map, 'type', 'region')) {\n      case 'region': {\n        const path = getValue(map, 'path', name);\n        const sequence = this.readSequence(getValue(map, 'sequence', null));\n        const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);\n        if (!region) return null;\n        region.path = path;\n        region.x = getValue(map, 'x', 0) * scale;\n        region.y = getValue(map, 'y', 0) * scale;\n        region.scaleX = getValue(map, 'scaleX', 1);\n        region.scaleY = getValue(map, 'scaleY', 1);\n        region.rotation = getValue(map, 'rotation', 0);\n        region.width = map.width * scale;\n        region.height = map.height * scale;\n        region.sequence = sequence;\n\n        const color: string = getValue(map, 'color', null);\n        if (color) region.color.setFromString(color);\n\n        if (region.region != null) region.updateRegion();\n        return region;\n      }\n      case 'boundingbox': {\n        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n        if (!box) return null;\n        this.readVertices(map, box, map.vertexCount << 1);\n        const color: string = getValue(map, 'color', null);\n        if (color) box.color.setFromString(color);\n        return box;\n      }\n      case 'mesh':\n      case 'linkedmesh': {\n        const path = getValue(map, 'path', name);\n        const sequence = this.readSequence(getValue(map, 'sequence', null));\n        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n        if (!mesh) return null;\n        mesh.path = path;\n\n        const color = getValue(map, 'color', null);\n        if (color) mesh.color.setFromString(color);\n\n        mesh.width = getValue(map, 'width', 0) * scale;\n        mesh.height = getValue(map, 'height', 0) * scale;\n        mesh.sequence = sequence;\n\n        const parent: string = getValue(map, 'parent', null);\n        if (parent) {\n          this.linkedMeshes.push(\n            new LinkedMesh(\n              mesh,\n              <string>getValue(map, 'skin', null),\n              slotIndex,\n              parent,\n              getValue(map, 'timelines', true),\n            ),\n          );\n          return mesh;\n        }\n\n        const uvs: Array<number> = map.uvs;\n        this.readVertices(map, mesh, uvs.length);\n        mesh.triangles = map.triangles;\n        mesh.regionUVs = uvs;\n        if (mesh.region != null) mesh.updateRegion();\n\n        mesh.edges = getValue(map, 'edges', null);\n        mesh.hullLength = getValue(map, 'hull', 0) * 2;\n        return mesh;\n      }\n      case 'path': {\n        const path = this.attachmentLoader.newPathAttachment(skin, name);\n        if (!path) return null;\n        path.closed = getValue(map, 'closed', false);\n        path.constantSpeed = getValue(map, 'constantSpeed', true);\n\n        const vertexCount = map.vertexCount;\n        this.readVertices(map, path, vertexCount << 1);\n\n        const lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\n        for (let i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;\n        path.lengths = lengths;\n\n        const color: string = getValue(map, 'color', null);\n        if (color) path.color.setFromString(color);\n        return path;\n      }\n      case 'point': {\n        const point = this.attachmentLoader.newPointAttachment(skin, name);\n        if (!point) return null;\n        point.x = getValue(map, 'x', 0) * scale;\n        point.y = getValue(map, 'y', 0) * scale;\n        point.rotation = getValue(map, 'rotation', 0);\n\n        const color = getValue(map, 'color', null);\n        if (color) point.color.setFromString(color);\n        return point;\n      }\n      case 'clipping': {\n        const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n        if (!clip) return null;\n\n        const end = getValue(map, 'end', null);\n        if (end) clip.endSlot = skeletonData.findSlot(end);\n\n        const vertexCount = map.vertexCount;\n        this.readVertices(map, clip, vertexCount << 1);\n\n        const color: string = getValue(map, 'color', null);\n        if (color) clip.color.setFromString(color);\n        return clip;\n      }\n    }\n    return null;\n  }\n\n  readSequence(map: any) {\n    if (map == null) return null;\n    const sequence = new Sequence(getValue(map, 'count', 0));\n    sequence.start = getValue(map, 'start', 1);\n    sequence.digits = getValue(map, 'digits', 0);\n    sequence.setupIndex = getValue(map, 'setup', 0);\n    return sequence;\n  }\n\n  readVertices(map: any, attachment: VertexAttachment, verticesLength: number) {\n    const scale = this.scale;\n    attachment.worldVerticesLength = verticesLength;\n    const vertices: Array<number> = map.vertices;\n    if (verticesLength == vertices.length) {\n      const scaledVertices = Utils.toFloatArray(vertices);\n      if (scale != 1) {\n        for (let i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;\n      }\n      attachment.vertices = scaledVertices;\n      return;\n    }\n    const weights = new Array<number>();\n    const bones = new Array<number>();\n    for (let i = 0, n = vertices.length; i < n; ) {\n      const boneCount = vertices[i++];\n      bones.push(boneCount);\n      for (let nn = i + boneCount * 4; i < nn; i += 4) {\n        bones.push(vertices[i]);\n        weights.push(vertices[i + 1] * scale);\n        weights.push(vertices[i + 2] * scale);\n        weights.push(vertices[i + 3]);\n      }\n    }\n    attachment.bones = bones;\n    attachment.vertices = Utils.toFloatArray(weights);\n  }\n\n  readAnimation(map: any, name: string, skeletonData: SkeletonData) {\n    const scale = this.scale;\n    const timelines = new Array<Timeline>();\n\n    // Slot timelines.\n    if (map.slots) {\n      for (const slotName in map.slots) {\n        const slotMap = map.slots[slotName];\n        const slot = skeletonData.findSlot(slotName);\n        if (!slot) throw new Error('Slot not found: ' + slotName);\n        const slotIndex = slot.index;\n        for (const timelineName in slotMap) {\n          const timelineMap = slotMap[timelineName];\n          if (!timelineMap) continue;\n          const frames = timelineMap.length;\n          if (timelineName == 'attachment') {\n            const timeline = new AttachmentTimeline(frames, slotIndex);\n            for (let frame = 0; frame < frames; frame++) {\n              const keyMap = timelineMap[frame];\n              timeline.setFrame(frame, getValue(keyMap, 'time', 0), getValue(keyMap, 'name', null));\n            }\n            timelines.push(timeline);\n          } else if (timelineName == 'rgba') {\n            const timeline = new RGBATimeline(frames, frames << 2, slotIndex);\n            let keyMap = timelineMap[0];\n            let time = getValue(keyMap, 'time', 0);\n            let color = Color.fromString(keyMap.color);\n\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, color.r, color.g, color.b, color.a);\n              const nextMap = timelineMap[frame + 1];\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n              const time2 = getValue(nextMap, 'time', 0);\n              const newColor = Color.fromString(nextMap.color);\n              const curve = keyMap.curve;\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n              }\n              time = time2;\n              color = newColor;\n              keyMap = nextMap;\n            }\n\n            timelines.push(timeline);\n          } else if (timelineName == 'rgb') {\n            const timeline = new RGBTimeline(frames, frames * 3, slotIndex);\n            let keyMap = timelineMap[0];\n            let time = getValue(keyMap, 'time', 0);\n            let color = Color.fromString(keyMap.color);\n\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, color.r, color.g, color.b);\n              const nextMap = timelineMap[frame + 1];\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n              const time2 = getValue(nextMap, 'time', 0);\n              const newColor = Color.fromString(nextMap.color);\n              const curve = keyMap.curve;\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n              }\n              time = time2;\n              color = newColor;\n              keyMap = nextMap;\n            }\n\n            timelines.push(timeline);\n          } else if (timelineName == 'alpha') {\n            timelines.push(readTimeline1(timelineMap, new AlphaTimeline(frames, frames, slotIndex), 0, 1));\n          } else if (timelineName == 'rgba2') {\n            const timeline = new RGBA2Timeline(frames, frames * 7, slotIndex);\n\n            let keyMap = timelineMap[0];\n            let time = getValue(keyMap, 'time', 0);\n            let color = Color.fromString(keyMap.light);\n            let color2 = Color.fromString(keyMap.dark);\n\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);\n              const nextMap = timelineMap[frame + 1];\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n              const time2 = getValue(nextMap, 'time', 0);\n              const newColor = Color.fromString(nextMap.light);\n              const newColor2 = Color.fromString(nextMap.dark);\n              const curve = keyMap.curve;\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);\n              }\n              time = time2;\n              color = newColor;\n              color2 = newColor2;\n              keyMap = nextMap;\n            }\n\n            timelines.push(timeline);\n          } else if (timelineName == 'rgb2') {\n            const timeline = new RGB2Timeline(frames, frames * 6, slotIndex);\n\n            let keyMap = timelineMap[0];\n            let time = getValue(keyMap, 'time', 0);\n            let color = Color.fromString(keyMap.light);\n            let color2 = Color.fromString(keyMap.dark);\n\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);\n              const nextMap = timelineMap[frame + 1];\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n              const time2 = getValue(nextMap, 'time', 0);\n              const newColor = Color.fromString(nextMap.light);\n              const newColor2 = Color.fromString(nextMap.dark);\n              const curve = keyMap.curve;\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);\n              }\n              time = time2;\n              color = newColor;\n              color2 = newColor2;\n              keyMap = nextMap;\n            }\n\n            timelines.push(timeline);\n          }\n        }\n      }\n    }\n\n    // Bone timelines.\n    if (map.bones) {\n      for (const boneName in map.bones) {\n        const boneMap = map.bones[boneName];\n        const bone = skeletonData.findBone(boneName);\n        if (!bone) throw new Error('Bone not found: ' + boneName);\n        const boneIndex = bone.index;\n        for (const timelineName in boneMap) {\n          const timelineMap = boneMap[timelineName];\n          const frames = timelineMap.length;\n          if (frames == 0) continue;\n\n          if (timelineName === 'rotate') {\n            timelines.push(readTimeline1(timelineMap, new RotateTimeline(frames, frames, boneIndex), 0, 1));\n          } else if (timelineName === 'translate') {\n            const timeline = new TranslateTimeline(frames, frames << 1, boneIndex);\n            timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 0, scale));\n          } else if (timelineName === 'translatex') {\n            const timeline = new TranslateXTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\n          } else if (timelineName === 'translatey') {\n            const timeline = new TranslateYTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\n          } else if (timelineName === 'scale') {\n            const timeline = new ScaleTimeline(frames, frames << 1, boneIndex);\n            timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 1, 1));\n          } else if (timelineName === 'scalex') {\n            const timeline = new ScaleXTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\n          } else if (timelineName === 'scaley') {\n            const timeline = new ScaleYTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\n          } else if (timelineName === 'shear') {\n            const timeline = new ShearTimeline(frames, frames << 1, boneIndex);\n            timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 0, 1));\n          } else if (timelineName === 'shearx') {\n            const timeline = new ShearXTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\n          } else if (timelineName === 'sheary') {\n            const timeline = new ShearYTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\n          }\n        }\n      }\n    }\n\n    // IK constraint timelines.\n    if (map.ik) {\n      for (const constraintName in map.ik) {\n        const constraintMap = map.ik[constraintName];\n        let keyMap = constraintMap[0];\n        if (!keyMap) continue;\n\n        const constraint = skeletonData.findIkConstraint(constraintName);\n        if (!constraint) throw new Error('IK Constraint not found: ' + constraintName);\n        const constraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n        const timeline = new IkConstraintTimeline(constraintMap.length, constraintMap.length << 1, constraintIndex);\n\n        let time = getValue(keyMap, 'time', 0);\n        let mix = getValue(keyMap, 'mix', 1);\n        let softness = getValue(keyMap, 'softness', 0) * scale;\n\n        for (let frame = 0, bezier = 0; ; frame++) {\n          timeline.setFrame(\n            frame,\n            time,\n            mix,\n            softness,\n            getValue(keyMap, 'bendPositive', true) ? 1 : -1,\n            getValue(keyMap, 'compress', false),\n            getValue(keyMap, 'stretch', false),\n          );\n          const nextMap = constraintMap[frame + 1];\n          if (!nextMap) {\n            timeline.shrink(bezier);\n            break;\n          }\n\n          const time2 = getValue(nextMap, 'time', 0);\n          const mix2 = getValue(nextMap, 'mix', 1);\n          const softness2 = getValue(nextMap, 'softness', 0) * scale;\n          const curve = keyMap.curve;\n          if (curve) {\n            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mix, mix2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, softness, softness2, scale);\n          }\n\n          time = time2;\n          mix = mix2;\n          softness = softness2;\n          keyMap = nextMap;\n        }\n        timelines.push(timeline);\n      }\n    }\n\n    // Transform constraint timelines.\n    if (map.transform) {\n      for (const constraintName in map.transform) {\n        const timelineMap = map.transform[constraintName];\n        let keyMap = timelineMap[0];\n        if (!keyMap) continue;\n\n        const constraint = skeletonData.findTransformConstraint(constraintName);\n        if (!constraint) throw new Error('Transform constraint not found: ' + constraintName);\n        const constraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n        const timeline = new TransformConstraintTimeline(timelineMap.length, timelineMap.length * 6, constraintIndex);\n\n        let time = getValue(keyMap, 'time', 0);\n        let mixRotate = getValue(keyMap, 'mixRotate', 1);\n        let mixX = getValue(keyMap, 'mixX', 1);\n        let mixY = getValue(keyMap, 'mixY', mixX);\n        let mixScaleX = getValue(keyMap, 'mixScaleX', 1);\n        let mixScaleY = getValue(keyMap, 'mixScaleY', mixScaleX);\n        const mixShearY = getValue(keyMap, 'mixShearY', 1);\n\n        for (let frame = 0, bezier = 0; ; frame++) {\n          timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n          const nextMap = timelineMap[frame + 1];\n          if (!nextMap) {\n            timeline.shrink(bezier);\n            break;\n          }\n\n          const time2 = getValue(nextMap, 'time', 0);\n          const mixRotate2 = getValue(nextMap, 'mixRotate', 1);\n          const mixX2 = getValue(nextMap, 'mixX', 1);\n          const mixY2 = getValue(nextMap, 'mixY', mixX2);\n          const mixScaleX2 = getValue(nextMap, 'mixScaleX', 1);\n          const mixScaleY2 = getValue(nextMap, 'mixScaleY', mixScaleX2);\n          const mixShearY2 = getValue(nextMap, 'mixShearY', 1);\n          const curve = keyMap.curve;\n          if (curve) {\n            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n          }\n\n          time = time2;\n          mixRotate = mixRotate2;\n          mixX = mixX2;\n          mixY = mixY2;\n          mixScaleX = mixScaleX2;\n          mixScaleY = mixScaleY2;\n          mixScaleX = mixScaleX2;\n          keyMap = nextMap;\n        }\n        timelines.push(timeline);\n      }\n    }\n\n    // Path constraint timelines.\n    if (map.path) {\n      for (const constraintName in map.path) {\n        const constraintMap = map.path[constraintName];\n        const constraint = skeletonData.findPathConstraint(constraintName);\n        if (!constraint) throw new Error('Path constraint not found: ' + constraintName);\n        const constraintIndex = skeletonData.pathConstraints.indexOf(constraint);\n        for (const timelineName in constraintMap) {\n          const timelineMap = constraintMap[timelineName];\n          let keyMap = timelineMap[0];\n          if (!keyMap) continue;\n\n          const frames = timelineMap.length;\n          if (timelineName === 'position') {\n            const timeline = new PathConstraintPositionTimeline(frames, frames, constraintIndex);\n            timelines.push(\n              readTimeline1(timelineMap, timeline, 0, constraint.positionMode == PositionMode.Fixed ? scale : 1),\n            );\n          } else if (timelineName === 'spacing') {\n            const timeline = new PathConstraintSpacingTimeline(frames, frames, constraintIndex);\n            timelines.push(\n              readTimeline1(\n                timelineMap,\n                timeline,\n                0,\n                constraint.spacingMode == SpacingMode.Length || constraint.spacingMode == SpacingMode.Fixed ? scale : 1,\n              ),\n            );\n          } else if (timelineName === 'mix') {\n            const timeline = new PathConstraintMixTimeline(frames, frames * 3, constraintIndex);\n            let time = getValue(keyMap, 'time', 0);\n            let mixRotate = getValue(keyMap, 'mixRotate', 1);\n            let mixX = getValue(keyMap, 'mixX', 1);\n            let mixY = getValue(keyMap, 'mixY', mixX);\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, mixRotate, mixX, mixY);\n              const nextMap = timelineMap[frame + 1];\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n              const time2 = getValue(nextMap, 'time', 0);\n              const mixRotate2 = getValue(nextMap, 'mixRotate', 1);\n              const mixX2 = getValue(nextMap, 'mixX', 1);\n              const mixY2 = getValue(nextMap, 'mixY', mixX2);\n              const curve = keyMap.curve;\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n              }\n              time = time2;\n              mixRotate = mixRotate2;\n              mixX = mixX2;\n              mixY = mixY2;\n              keyMap = nextMap;\n            }\n            timelines.push(timeline);\n          }\n        }\n      }\n    }\n\n    // Attachment timelines.\n    if (map.attachments) {\n      for (const attachmentsName in map.attachments) {\n        const attachmentsMap = map.attachments[attachmentsName];\n        const skin = skeletonData.findSkin(attachmentsName);\n        if (!skin) throw new Error('Skin not found: ' + attachmentsName);\n        for (const slotMapName in attachmentsMap) {\n          const slotMap = attachmentsMap[slotMapName];\n          const slot = skeletonData.findSlot(slotMapName);\n          if (!slot) throw new Error('Slot not found: ' + slotMapName);\n          const slotIndex = slot.index;\n          for (const attachmentMapName in slotMap) {\n            const attachmentMap = slotMap[attachmentMapName];\n            const attachment = <VertexAttachment>skin.getAttachment(slotIndex, attachmentMapName);\n\n            for (const timelineMapName in attachmentMap) {\n              const timelineMap = attachmentMap[timelineMapName];\n              let keyMap = timelineMap[0];\n              if (!keyMap) continue;\n\n              if (timelineMapName == 'deform') {\n                const weighted = attachment.bones;\n                const vertices = attachment.vertices;\n                const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\n\n                const timeline = new DeformTimeline(timelineMap.length, timelineMap.length, slotIndex, attachment);\n                let time = getValue(keyMap, 'time', 0);\n                for (let frame = 0, bezier = 0; ; frame++) {\n                  let deform: NumberArrayLike;\n                  const verticesValue: Array<number> = getValue(keyMap, 'vertices', null);\n                  if (!verticesValue) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                  else {\n                    deform = Utils.newFloatArray(deformLength);\n                    const start = <number>getValue(keyMap, 'offset', 0);\n                    Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                    if (scale != 1) {\n                      for (let i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;\n                    }\n                    if (!weighted) {\n                      for (let i = 0; i < deformLength; i++) deform[i] += vertices[i];\n                    }\n                  }\n\n                  timeline.setFrame(frame, time, deform);\n                  const nextMap = timelineMap[frame + 1];\n                  if (!nextMap) {\n                    timeline.shrink(bezier);\n                    break;\n                  }\n                  const time2 = getValue(nextMap, 'time', 0);\n                  const curve = keyMap.curve;\n                  if (curve) bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, 0, 1, 1);\n                  time = time2;\n                  keyMap = nextMap;\n                }\n                timelines.push(timeline);\n              } else if (timelineMapName == 'sequence') {\n                const timeline = new SequenceTimeline(\n                  timelineMap.length,\n                  slotIndex,\n                  attachment as unknown as HasTextureRegion,\n                );\n                let lastDelay = 0;\n                for (let frame = 0; frame < timelineMap.length; frame++) {\n                  const delay = getValue(keyMap, 'delay', lastDelay);\n                  const time = getValue(keyMap, 'time', 0);\n                  const mode = SequenceMode[getValue(keyMap, 'mode', 'hold')] as unknown as number;\n                  const index = getValue(keyMap, 'index', 0);\n                  timeline.setFrame(frame, time, mode, index, delay);\n                  lastDelay = delay;\n                  keyMap = timelineMap[frame + 1];\n                }\n                timelines.push(timeline);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Draw order timelines.\n    if (map.drawOrder) {\n      const timeline = new DrawOrderTimeline(map.drawOrder.length);\n      const slotCount = skeletonData.slots.length;\n      let frame = 0;\n      for (let i = 0; i < map.drawOrder.length; i++, frame++) {\n        const drawOrderMap = map.drawOrder[i];\n        let drawOrder: Array<number> | null = null;\n        const offsets = getValue(drawOrderMap, 'offsets', null);\n        if (offsets) {\n          drawOrder = Utils.newArray<number>(slotCount, -1);\n          const unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\n          let originalIndex = 0,\n            unchangedIndex = 0;\n          for (let ii = 0; ii < offsets.length; ii++) {\n            const offsetMap = offsets[ii];\n            const slot = skeletonData.findSlot(offsetMap.slot);\n            if (!slot) throw new Error('Slot not found: ' + slot);\n            const slotIndex = slot.index;\n            // Collect unchanged items.\n            while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\n            // Set changed items.\n            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n          }\n          // Collect remaining unchanged items.\n          while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\n          // Fill in unchanged items.\n          for (let ii = slotCount - 1; ii >= 0; ii--)\n            if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n        }\n        timeline.setFrame(frame, getValue(drawOrderMap, 'time', 0), drawOrder);\n      }\n      timelines.push(timeline);\n    }\n\n    // Event timelines.\n    if (map.events) {\n      const timeline = new EventTimeline(map.events.length);\n      let frame = 0;\n      for (let i = 0; i < map.events.length; i++, frame++) {\n        const eventMap = map.events[i];\n        const eventData = skeletonData.findEvent(eventMap.name);\n        if (!eventData) throw new Error('Event not found: ' + eventMap.name);\n        const event = new Event(Utils.toSinglePrecision(getValue(eventMap, 'time', 0)), eventData);\n        event.intValue = getValue(eventMap, 'int', eventData.intValue);\n        event.floatValue = getValue(eventMap, 'float', eventData.floatValue);\n        event.stringValue = getValue(eventMap, 'string', eventData.stringValue);\n        if (event.data.audioPath) {\n          event.volume = getValue(eventMap, 'volume', 1);\n          event.balance = getValue(eventMap, 'balance', 0);\n        }\n        timeline.setFrame(frame, event);\n      }\n      timelines.push(timeline);\n    }\n\n    let duration = 0;\n    for (let i = 0, n = timelines.length; i < n; i++) duration = Math.max(duration, timelines[i].getDuration());\n    skeletonData.animations.push(new Animation(name, timelines, duration));\n  }\n}\n\nclass LinkedMesh {\n  parent: string;\n  skin: string;\n  slotIndex: number;\n  mesh: MeshAttachment;\n  inheritTimeline: boolean;\n\n  constructor(mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n    this.inheritTimeline = inheritDeform;\n  }\n}\n\nfunction readTimeline1(keys: any[], timeline: CurveTimeline1, defaultValue: number, scale: number) {\n  let keyMap = keys[0];\n  let time = getValue(keyMap, 'time', 0);\n  let value = getValue(keyMap, 'value', defaultValue) * scale;\n  let bezier = 0;\n  for (let frame = 0; ; frame++) {\n    timeline.setFrame(frame, time, value);\n    const nextMap = keys[frame + 1];\n    if (!nextMap) {\n      timeline.shrink(bezier);\n      return timeline;\n    }\n    const time2 = getValue(nextMap, 'time', 0);\n    const value2 = getValue(nextMap, 'value', defaultValue) * scale;\n    if (keyMap.curve) bezier = readCurve(keyMap.curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);\n    time = time2;\n    value = value2;\n    keyMap = nextMap;\n  }\n}\n\nfunction readTimeline2(\n  keys: any[],\n  timeline: CurveTimeline2,\n  name1: string,\n  name2: string,\n  defaultValue: number,\n  scale: number,\n) {\n  let keyMap = keys[0];\n  let time = getValue(keyMap, 'time', 0);\n  let value1 = getValue(keyMap, name1, defaultValue) * scale;\n  let value2 = getValue(keyMap, name2, defaultValue) * scale;\n  let bezier = 0;\n  for (let frame = 0; ; frame++) {\n    timeline.setFrame(frame, time, value1, value2);\n    const nextMap = keys[frame + 1];\n    if (!nextMap) {\n      timeline.shrink(bezier);\n      return timeline;\n    }\n    const time2 = getValue(nextMap, 'time', 0);\n    const nvalue1 = getValue(nextMap, name1, defaultValue) * scale;\n    const nvalue2 = getValue(nextMap, name2, defaultValue) * scale;\n    const curve = keyMap.curve;\n    if (curve) {\n      bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);\n      bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);\n    }\n    time = time2;\n    value1 = nvalue1;\n    value2 = nvalue2;\n    keyMap = nextMap;\n  }\n}\n\nfunction readCurve(\n  curve: any,\n  timeline: CurveTimeline,\n  bezier: number,\n  frame: number,\n  value: number,\n  time1: number,\n  time2: number,\n  value1: number,\n  value2: number,\n  scale: number,\n) {\n  if (curve == 'stepped') {\n    timeline.setStepped(frame);\n    return bezier;\n  }\n  const i = value << 2;\n  const cx1 = curve[i];\n  const cy1 = curve[i + 1] * scale;\n  const cx2 = curve[i + 2];\n  const cy2 = curve[i + 3] * scale;\n  timeline.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);\n  return bezier + 1;\n}\n\nfunction getValue(map: any, property: string, defaultValue: any) {\n  return map[property] !== undefined ? map[property] : defaultValue;\n}\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\n(() => {\n\tif (typeof Math.fround === \"undefined\") {\n\t\tMath.fround = (function (array) {\n\t\t\treturn function (x: number) {\n\t\t\t\treturn array[0] = x, array[0];\n\t\t\t};\n\t\t})(new Float32Array(1));\n\t}\n})();\n\nexport { }\n","/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport type { BLEND_MODES, SCALE_MODE, TextureSource, WRAP_MODE } from 'pixi.js';\nimport { Texture as PixiTexture } from 'pixi.js';\nimport { BlendMode, Texture, TextureFilter, TextureWrap } from '../spine-core';\n\nexport class SpineTexture extends Texture {\n  private static readonly textureMap: Map<TextureSource, SpineTexture> = new Map<TextureSource, SpineTexture>();\n  public readonly texture: PixiTexture;\n\n  private constructor(image: TextureSource) {\n    // Todo: maybe add error handling if you feed a video texture to spine?\n    super(image.resource);\n    this.texture = PixiTexture.from(image);\n  }\n\n  public static from(texture: TextureSource): SpineTexture {\n    if (SpineTexture.textureMap.has(texture)) {\n      return SpineTexture.textureMap.get(texture) as SpineTexture;\n    }\n\n    return new SpineTexture(texture);\n  }\n\n  public static toPixiBlending(blend: BlendMode): BLEND_MODES {\n    switch (blend) {\n      case BlendMode.Normal:\n        return 'normal';\n\n      case BlendMode.Additive:\n        return 'add';\n\n      case BlendMode.Multiply:\n        return 'multiply';\n\n      case BlendMode.Screen:\n        return 'screen';\n\n      default:\n        throw new Error(`Unknown blendMode: ${String(blend)}`);\n    }\n  }\n\n  private static toPixiMipMap(filter: TextureFilter): boolean {\n    switch (filter) {\n      case TextureFilter.Nearest:\n      case TextureFilter.Linear:\n        return false;\n\n      case TextureFilter.MipMapNearestLinear:\n      case TextureFilter.MipMapNearestNearest:\n      case TextureFilter.MipMapLinearLinear: // TextureFilter.MipMapLinearLinear == TextureFilter.MipMap\n      case TextureFilter.MipMapLinearNearest:\n        return true;\n\n      default:\n        throw new Error(`Unknown texture filter: ${String(filter)}`);\n    }\n  }\n\n  private static toPixiTextureFilter(filter: TextureFilter): SCALE_MODE {\n    switch (filter) {\n      case TextureFilter.Nearest:\n      case TextureFilter.MipMapNearestLinear:\n      case TextureFilter.MipMapNearestNearest:\n        return 'nearest';\n\n      case TextureFilter.Linear:\n      case TextureFilter.MipMapLinearLinear: // TextureFilter.MipMapLinearLinear == TextureFilter.MipMap\n      case TextureFilter.MipMapLinearNearest:\n        return 'linear';\n\n      default:\n        throw new Error(`Unknown texture filter: ${String(filter)}`);\n    }\n  }\n\n  private static toPixiTextureWrap(wrap: TextureWrap): WRAP_MODE {\n    switch (wrap) {\n      case TextureWrap.ClampToEdge:\n        return 'clamp-to-edge';\n\n      case TextureWrap.MirroredRepeat:\n        return 'mirror-repeat';\n\n      case TextureWrap.Repeat:\n        return 'repeat';\n\n      default:\n        throw new Error(`Unknown texture wrap: ${String(wrap)}`);\n    }\n  }\n\n  public setFilters(minFilter: TextureFilter, magFilter: TextureFilter): void {\n    const style = this.texture.source.style;\n\n    style.minFilter = SpineTexture.toPixiTextureFilter(minFilter);\n    style.magFilter = SpineTexture.toPixiTextureFilter(magFilter);\n    this.texture.source.autoGenerateMipmaps = SpineTexture.toPixiMipMap(minFilter);\n    this.texture.source.updateMipmaps();\n  }\n\n  public setWraps(uWrap: TextureWrap, vWrap: TextureWrap): void {\n    const style = this.texture.source.style;\n\n    style.addressModeU = SpineTexture.toPixiTextureWrap(uWrap);\n    style.addressModeV = SpineTexture.toPixiTextureWrap(vWrap);\n  }\n\n  public dispose(): void {\n    // I am not entirely sure about this...\n    this.texture.destroy();\n  }\n}\n","/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport {\n  AssetExtension,\n  checkExtension,\n  DOMAdapter,\n  ExtensionType,\n  Loader,\n  LoaderParserPriority,\n  path,\n  ResolvedAsset,\n  Texture,\n  TextureSource,\n} from 'pixi.js';\nimport { SpineTexture } from '../SpineTexture';\nimport { TextureAtlas } from '../../spine-core';\n\ntype RawAtlas = string;\n\nexport const spineTextureAtlasLoader: AssetExtension<RawAtlas | TextureAtlas, ISpineAtlasMetadata> = {\n  extension: ExtensionType.Asset,\n\n  loader: {\n    extension: {\n      type: ExtensionType.LoadParser,\n      priority: LoaderParserPriority.Normal,\n      name: 'spineTextureAtlasLoader',\n    },\n\n    test(url: string): boolean {\n      return checkExtension(url, '.atlas');\n    },\n\n    async load(url: string): Promise<RawAtlas> {\n      const response = await DOMAdapter.get().fetch(url);\n\n      const txt = await response.text();\n\n      return txt;\n    },\n\n    testParse(asset: unknown, options: ResolvedAsset): Promise<boolean> {\n      const isExtensionRight = checkExtension(options.src as string, '.atlas');\n      const isString = typeof asset === 'string';\n\n      return Promise.resolve(isExtensionRight && isString);\n    },\n\n    unload(atlas: TextureAtlas) {\n      atlas.dispose();\n    },\n\n    async parse(asset: RawAtlas, options: ResolvedAsset, loader: Loader): Promise<TextureAtlas> {\n      const metadata: ISpineAtlasMetadata = options.data || {};\n      let basePath = path.dirname(options.src as string);\n\n      if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1) {\n        basePath += '/';\n      }\n\n      // Retval is going to be a texture atlas. However we need to wait for it's callback to resolve this promise.\n      const retval = new TextureAtlas(asset);\n\n      // If the user gave me only one texture, that one is assumed to be the \"first\" texture in the atlas\n      if (metadata.images instanceof TextureSource || typeof metadata.images === 'string') {\n        const pixiTexture = metadata.images;\n\n        metadata.images = {} as Record<string, TextureSource | string>;\n        metadata.images[retval.pages[0].name] = pixiTexture;\n      }\n\n      // we will wait for all promises for the textures at the same time at the end.\n      const textureLoadingPromises: Promise<any>[] = [];\n\n      // fill the pages\n      for (const page of retval.pages) {\n        const pageName = page.name;\n        const providedPage = metadata?.images ? metadata.images[pageName] : undefined;\n\n        if (providedPage instanceof TextureSource) {\n          page.setTexture(SpineTexture.from(providedPage));\n        } else {\n          // eslint-disable-next-line max-len\n          const url: string = providedPage ?? path.normalize([...basePath.split(path.sep), pageName].join(path.sep));\n\n          const pixiPromise = loader\n            .load<Texture>({\n              src: url,\n              data: metadata.imageMetadata,\n            })\n            .then((texture) => {\n              page.setTexture(SpineTexture.from(texture.source));\n            });\n\n          textureLoadingPromises.push(pixiPromise);\n        }\n      }\n\n      await Promise.all(textureLoadingPromises);\n\n      return retval;\n    },\n  },\n} as AssetExtension<RawAtlas | TextureAtlas, ISpineAtlasMetadata>;\n\n// extensions.add(spineTextureAtlasLoader);\n\nexport interface ISpineAtlasMetadata {\n  // If you are downloading an .atlas file, this metadata will go to the Texture loader\n  imageMetadata?: any;\n  // If you already have atlas pages loaded as pixi textures\n  // and want to use that to create the atlas, you can pass them here\n  images?: TextureSource | string | Record<string, TextureSource | string>;\n}\n","/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport {\n  type AssetExtension,\n  checkExtension,\n  DOMAdapter,\n  ExtensionType,\n  LoaderParserPriority,\n  ResolvedAsset,\n} from 'pixi.js';\n\ntype SkeletonJsonAsset = any;\ntype SkeletonBinaryAsset = Uint8Array;\n\nfunction isJson(resource: any): resource is SkeletonJsonAsset {\n\treturn Object.prototype.hasOwnProperty.call(resource, 'bones');\n}\n\nfunction isBuffer(resource: any): resource is SkeletonBinaryAsset {\n\treturn resource instanceof Uint8Array;\n}\n\nexport const spineLoaderExtension: AssetExtension<SkeletonJsonAsset | SkeletonBinaryAsset> = {\n\textension: ExtensionType.Asset,\n\t\n\tloader: {\n\t\textension: {\n\t\t\ttype: ExtensionType.LoadParser,\n\t\t\tpriority: LoaderParserPriority.Normal,\n\t\t\tname: 'spineSkeletonLoader',\n\t\t},\n\t\t\n\t\ttest(url) {\n\t\t\treturn checkExtension(url, '.skel');\n\t\t},\n\t\t\n\t\tasync load(url: string): Promise<SkeletonBinaryAsset> {\n\t\t\tconst response = await DOMAdapter.get().fetch(url);\n\t\t\t\n\t\t\tconst buffer = new Uint8Array(await response.arrayBuffer());\n\t\t\t\n\t\t\treturn buffer;\n\t\t},\n\t\ttestParse(asset: unknown, options: ResolvedAsset): Promise<boolean> {\n\t\t\tconst isJsonSpineModel = checkExtension(options.src!, '.json') && isJson(asset);\n\t\t\tconst isBinarySpineModel = checkExtension(options.src!, '.skel') && isBuffer(asset);\n\t\t\t\n\t\t\treturn Promise.resolve(isJsonSpineModel || isBinarySpineModel);\n\t\t},\n\t},\n} as AssetExtension<SkeletonJsonAsset | SkeletonBinaryAsset>;\n\n// extensions.add(spineLoaderExtension);\n","/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Spine } from './Spine';\n\nimport type { Batch, BatchableObject, Batcher, IndexBufferArray, Texture } from 'pixi.js';\nimport type { SkeletonClipping, Slot } from '../spine-core';\n\nexport class BatchableClippedSpineSlot implements BatchableObject {\n  indexStart: number;\n  textureId: number;\n  texture: Texture;\n  location: number;\n  batcher: Batcher;\n  batch: Batch;\n  renderable: Spine;\n\n  slot: Slot;\n  indexSize: number;\n  vertexSize: number;\n  clippedVertices: number[] = [];\n  clippedTriangles: number[] = [];\n\n  roundPixels: 0 | 1;\n\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n\n  reset() {\n    this.renderable = null as any;\n    this.texture = null as any;\n    this.batcher = null as any;\n    this.batch = null as any;\n  }\n\n  setClipper(clipper: SkeletonClipping) {\n    // copy clipped verts and triangles\n    copyArray(clipper.clippedVertices, this.clippedVertices);\n    copyArray(clipper.clippedTriangles, this.clippedTriangles);\n\n    this.vertexSize = clipper.clippedVertices.length / 8;\n    this.indexSize = clipper.clippedTriangles.length;\n  }\n\n  packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number) {\n    const indices = this.clippedTriangles;\n\n    for (let i = 0; i < indices.length; i++) {\n      indexBuffer[index++] = indices[i] + indicesOffset;\n    }\n  }\n\n  packAttributes(float32View: Float32Array, uint32View: Uint32Array, index: number, textureId: number) {\n    const clippedVertices = this.clippedVertices;\n    const vertexSize = this.vertexSize;\n\n    const abgr = this.renderable.groupColor;\n\n    const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xffff);\n\n    for (let i = 0; i < vertexSize; i++) {\n      const localIndex = i * 8;\n\n      // position\n      float32View[index++] = clippedVertices[localIndex];\n      float32View[index++] = clippedVertices[localIndex + 1] * -1;\n\n      // uv\n      float32View[index++] = clippedVertices[localIndex + 6];\n      float32View[index++] = clippedVertices[localIndex + 7];\n      // color\n      uint32View[index++] = abgr;\n\n      // texture id\n      float32View[index++] = textureIdAndRound;\n    }\n  }\n}\n\nfunction copyArray(a: number[], b: number[]) {\n  for (let i = 0; i < a.length; i++) {\n    b[i] = a[i];\n  }\n}\n","/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Spine } from './Spine';\nimport { MeshAttachment, RegionAttachment, Slot } from '../spine-core';\n\nimport type { Batch, BatchableObject, Batcher, IndexBufferArray, Texture } from 'pixi.js';\n\nconst QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\n\nexport class BatchableSpineSlot implements BatchableObject {\n  indexStart: number;\n  textureId: number;\n  texture: Texture;\n  location: number;\n  batcher: Batcher;\n  batch: Batch;\n  renderable: Spine;\n\n  slot: Slot;\n  indexSize: number;\n  vertexSize: number;\n\n  roundPixels: 0 | 1;\n\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n\n  reset() {\n    this.renderable = null as any;\n    this.texture = null as any;\n    this.batcher = null as any;\n    this.batch = null as any;\n  }\n\n  setSlot(slot: Slot) {\n    this.slot = slot;\n\n    const attachment = slot.getAttachment();\n\n    if (attachment instanceof RegionAttachment) {\n      this.vertexSize = 4;\n      this.indexSize = 6;\n    } else if (attachment instanceof MeshAttachment) {\n      this.vertexSize = attachment.worldVerticesLength / 2;\n      this.indexSize = attachment.triangles.length;\n    }\n  }\n\n  packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number) {\n    const indices = (this.slot.getAttachment() as MeshAttachment).triangles ?? QUAD_TRIANGLES;\n\n    for (let i = 0; i < indices.length; i++) {\n      indexBuffer[index++] = indices[i] + indicesOffset;\n    }\n  }\n\n  packAttributes(float32View: Float32Array, uint32View: Uint32Array, index: number, textureId: number) {\n    const slot = this.slot;\n    const attachment = slot.getAttachment() as MeshAttachment | RegionAttachment;\n\n    if (attachment instanceof MeshAttachment) {\n      attachment.computeWorldVertices(slot, 0, attachment.worldVerticesLength, float32View, index, 6);\n    } else if (attachment instanceof RegionAttachment) {\n      attachment.computeWorldVertices(slot, float32View, index, 6);\n    }\n\n    const vertexSize = this.vertexSize;\n\n    const parentColor: number = this.renderable.groupColor; // BGR\n    const parentAlpha: number = this.renderable.groupAlpha;\n\n    const slotColor: { r: number; g: number; b: number; a: number } = slot.color;\n\n    let abgr: number;\n\n    const mixedA = slotColor.a * parentAlpha * 255;\n\n    if (parentColor !== 0xffffff) {\n      const parentB = (parentColor >> 16) & 0xff;\n      const parentG = (parentColor >> 8) & 0xff;\n      const parentR = parentColor & 0xff;\n\n      const mixedR = slotColor.r * parentR * 255;\n      const mixedG = slotColor.g * parentG * 255;\n      const mixedB = slotColor.b * parentB * 255;\n\n      abgr = (mixedA << 24) | (mixedB << 16) | (mixedG << 8) | mixedR;\n    } else {\n      abgr = (mixedA << 24) | ((slotColor.b * 255) << 16) | ((slotColor.g * 255) << 8) | (slotColor.r * 255);\n    }\n\n    const uvs = attachment.uvs;\n\n    const matrix = this.renderable.groupTransform;\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xffff);\n\n    for (let i = 0; i < vertexSize; i++) {\n      // index++;\n      // float32View[index++] *= -1;\n      const x = float32View[index];\n      const y = -float32View[index + 1];\n\n      float32View[index++] = a * x + c * y + tx;\n      float32View[index++] = b * x + d * y + ty;\n\n      // uv\n      float32View[index++] = uvs[i * 2];\n      float32View[index++] = uvs[i * 2 + 1];\n\n      // color\n      uint32View[index++] = abgr;\n\n      // texture id\n      uint32View[index++] = textureIdAndRound;\n    }\n  }\n}\n","/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { BigPool, ExtensionType, type Renderer, type RenderPipe, Texture } from 'pixi.js';\nimport { BatchableClippedSpineSlot } from './BatchableClippedSpineSlot';\nimport { BatchableSpineSlot } from './BatchableSpineSlot';\nimport { Spine } from './Spine';\nimport type { Bone } from '../spine-core';\nimport { ClippingAttachment, Color, MeshAttachment, RegionAttachment, SkeletonClipping } from '../spine-core';\n\nconst QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\nconst QUAD_VERTS = new Float32Array(8);\nconst lightColor = new Color();\nconst darkColor = new Color();\n\n// eslint-disable-next-line max-len\nexport class SpinePipe implements RenderPipe<Spine> {\n\t/** @ignore */\n\tstatic extension = {\n\t\ttype: [ExtensionType.WebGLPipes, ExtensionType.WebGPUPipes, ExtensionType.CanvasPipes],\n\t\tname: 'spine',\n\t} as const;\n\t\n\trenderer: Renderer;\n\t\n\tprivate readonly activeBatchableSpineSlots: (BatchableSpineSlot | BatchableClippedSpineSlot)[] = [];\n\t\n\tconstructor(renderer: Renderer) {\n\t\tthis.renderer = renderer;\n\t\t\n\t\trenderer.runners.prerender.add({\n\t\t\tprerender: () => {\n\t\t\t\tthis.buildStart();\n\t\t\t},\n\t\t});\n\t}\n\t\n\tvalidateRenderable(_renderable: Spine): boolean {\n\t\treturn true;\n\t}\n\t\n\tbuildStart() {\n\t\tthis._returnActiveBatches();\n\t}\n\t\n\taddRenderable(spine: Spine) {\n\t\tconst batcher = this.renderer.renderPipes.batch;\n\t\t\n\t\tconst rootBone = spine.skeleton.getRootBone() as Bone;\n\t\t\n\t\trootBone.x = 0;\n\t\trootBone.y = 0;\n\t\trootBone.scaleX = 1;\n\t\trootBone.scaleY = 1;\n\t\trootBone.rotation = 0;\n\t\t\n\t\tspine.state.apply(spine.skeleton);\n\t\tspine.skeleton.updateWorldTransform();\n\t\t\n\t\tconst drawOrder = spine.skeleton.drawOrder;\n\t\t\n\t\tconst activeBatchableSpineSlot = this.activeBatchableSpineSlots;\n\t\t\n\t\tconst clipper = new SkeletonClipping();\n\t\t\n\t\tfor (let i = 0, n = drawOrder.length; i < n; i++) {\n\t\t\tconst slot = drawOrder[i];\n\t\t\tconst attachment = slot.getAttachment();\n\t\t\t\n\t\t\tif (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment) {\n\t\t\t\tif (clipper?.isClipping()) {\n\t\t\t\t\tif (attachment instanceof RegionAttachment) {\n\t\t\t\t\t\tconst temp = QUAD_VERTS;\n\t\t\t\t\t\t\n\t\t\t\t\t\tattachment.computeWorldVertices(slot, temp, 0, 2);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// TODO this function could be optimised.. no need to write colors for us!\n\t\t\t\t\t\tclipper.clipTriangles(\n\t\t\t\t\t\t\tQUAD_VERTS,\n\t\t\t\t\t\t\tQUAD_VERTS.length,\n\t\t\t\t\t\t\tQUAD_TRIANGLES,\n\t\t\t\t\t\t\tQUAD_TRIANGLES.length,\n\t\t\t\t\t\t\tattachment.uvs,\n\t\t\t\t\t\t\tlightColor,\n\t\t\t\t\t\t\tdarkColor,\n\t\t\t\t\t\t\tfalse, // useDarkColor\n\t\t\t\t\t\t);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// unwind it!\n\t\t\t\t\t\tif (clipper.clippedVertices.length > 0) {\n\t\t\t\t\t\t\tconst batchableSpineSlot = BigPool.get(BatchableClippedSpineSlot);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tactiveBatchableSpineSlot.push(batchableSpineSlot);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbatchableSpineSlot.texture = attachment.region?.texture.texture || Texture.WHITE;\n\t\t\t\t\t\t\tbatchableSpineSlot.roundPixels = (this.renderer._roundPixels | spine._roundPixels) as 0 | 1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbatchableSpineSlot.setClipper(clipper);\n\t\t\t\t\t\t\tbatchableSpineSlot.renderable = spine;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbatcher.addToBatch(batchableSpineSlot);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst batchableSpineSlot = BigPool.get(BatchableSpineSlot);\n\t\t\t\t\t\n\t\t\t\t\tactiveBatchableSpineSlot.push(batchableSpineSlot);\n\t\t\t\t\t\n\t\t\t\t\tbatchableSpineSlot.renderable = spine;\n\t\t\t\t\t\n\t\t\t\t\tbatchableSpineSlot.setSlot(slot);\n\t\t\t\t\t\n\t\t\t\t\tbatchableSpineSlot.texture = attachment.region?.texture.texture || Texture.EMPTY;\n\t\t\t\t\tbatchableSpineSlot.roundPixels = (this.renderer._roundPixels | spine._roundPixels) as 0 | 1;\n\t\t\t\t\t\n\t\t\t\t\tbatcher.addToBatch(batchableSpineSlot);\n\t\t\t\t}\n\t\t\t} else if (attachment instanceof ClippingAttachment) {\n\t\t\t\tclipper.clipStart(slot, attachment);\n\t\t\t} else {\n\t\t\t\tclipper.clipEndWithSlot(slot);\n\t\t\t}\n\t\t}\n\t\t\n\t\tclipper.clipEnd();\n\t}\n\t\n\tupdateRenderable(_renderable: Spine) {\n\t\t// this does not happen.. yet!\n\t\t// we assume that spine will always change its verts size..\n\t}\n\t\n\tdestroyRenderable(_renderable: Spine) {\n\t\tthis._returnActiveBatches();\n\t}\n\t\n\tdestroy() {\n\t\tthis._returnActiveBatches();\n\t\tthis.renderer = null as any;\n\t}\n\t\n\tprivate _returnActiveBatches() {\n\t\tconst activeBatchableSpineSlots = this.activeBatchableSpineSlots;\n\t\t\n\t\tfor (let i = 0; i < activeBatchableSpineSlots.length; i++) {\n\t\t\tBigPool.return(activeBatchableSpineSlots[i]);\n\t\t}\n\t\t\n\t\t// TODO this can be optimised\n\t\tactiveBatchableSpineSlots.length = 0;\n\t}\n}\n\n// extensions.add(SpinePipe);\n","/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { type Bone, ClippingAttachment, MeshAttachment, RegionAttachment, type Skeleton } from '../spine-core';\n\nimport type { Bounds } from 'pixi.js';\n\nconst QUAD_VERTS = new Float32Array(8);\nconst tempVerts: number[] = [];\n\nexport function getSkeletonBounds(skeleton: Skeleton, out: Bounds) {\n  out.clear();\n\n  const rootBone = skeleton.getRootBone() as Bone;\n\n  rootBone.x = 0;\n  rootBone.y = 0;\n  rootBone.scaleX = 1;\n  rootBone.scaleY = -1;\n  rootBone.rotation = 0;\n\n  skeleton.updateWorldTransform();\n\n  const drawOrder = skeleton.drawOrder;\n\n  for (let i = 0, n = drawOrder.length; i < n; i++) {\n    const slot = drawOrder[i];\n    const attachment = slot.getAttachment();\n\n    if (attachment instanceof RegionAttachment) {\n      const temp = QUAD_VERTS;\n\n      attachment.computeWorldVertices(slot, temp, 0, 2);\n\n      // TODO this can be skipped if matrix is local??\n      out.addVertexData(temp, 0, 8);\n    } else if (attachment instanceof MeshAttachment) {\n      attachment.computeWorldVertices(slot, 0, attachment.worldVerticesLength, tempVerts, 0, 2);\n\n      out.addVertexData(tempVerts as any as Float32Array, 0, attachment.worldVerticesLength);\n    } else if (attachment instanceof ClippingAttachment) {\n      console.warn('[Pixi Spine] ClippingAttachment bounds is not supported yet');\n    }\n  }\n}\n","/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Assets, Bounds, Cache, Container, ContainerOptions, DestroyOptions, PointData, Ticker, View } from 'pixi.js';\nimport { getSkeletonBounds } from './getSkeletonBounds';\nimport { ISpineDebugRenderer } from './SpineDebugRenderer';\nimport {\n  AnimationState,\n  AnimationStateData,\n  AtlasAttachmentLoader,\n  Bone,\n  Skeleton,\n  SkeletonBinary,\n  SkeletonBounds,\n  SkeletonData,\n  SkeletonJson,\n  type TextureAtlas,\n  TrackEntry,\n  Vector2,\n} from '../spine-core';\n\nexport type SpineFromOptions = {\n  skeleton: string;\n  atlas: string;\n  scale?: number;\n};\n\nconst vectorAux = new Vector2();\n\nexport interface SpineOptions extends ContainerOptions {\n  skeletonData: SkeletonData;\n  autoUpdate?: boolean;\n}\n\nexport interface SpineEvents {\n  complete: [trackEntry: TrackEntry];\n  dispose: [trackEntry: TrackEntry];\n  end: [trackEntry: TrackEntry];\n  event: [trackEntry: TrackEntry, event: Event];\n  interrupt: [trackEntry: TrackEntry];\n  start: [trackEntry: TrackEntry];\n}\n\nexport class Spine extends Container implements View {\n  // Pixi properties\n  public batched = true;\n  public buildId = 0;\n  public override readonly renderPipeId = 'spine';\n  public _didSpineUpdate = false;\n  public _boundsDirty = true;\n  // Spine properties\n  public skeleton: Skeleton;\n  public state: AnimationState;\n  public skeletonBounds: SkeletonBounds;\n  private autoUpdateWarned = false;\n\n  constructor(options: SpineOptions | SkeletonData) {\n    if (options instanceof SkeletonData) {\n      options = {\n        skeletonData: options,\n      };\n    }\n\n    super();\n\n    const skeletonData = options instanceof SkeletonData ? options : options.skeletonData;\n\n    this.skeleton = new Skeleton(skeletonData);\n    this.state = new AnimationState(new AnimationStateData(skeletonData));\n    this.autoUpdate = options?.autoUpdate ?? true;\n  }\n\n  public _roundPixels: 0 | 1;\n\n  /** Whether or not to round the x/y position of the sprite. */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n\n  set roundPixels(value: boolean) {\n    this._roundPixels = value ? 1 : 0;\n  }\n\n  private _bounds: Bounds = new Bounds();\n\n  get bounds() {\n    if (this._boundsDirty) {\n      this.updateBounds();\n    }\n\n    return this._bounds;\n  }\n\n  private _debug?: ISpineDebugRenderer | undefined = undefined;\n\n  public get debug(): ISpineDebugRenderer | undefined {\n    return this._debug;\n  }\n\n  public set debug(value: ISpineDebugRenderer | undefined) {\n    if (this._debug) {\n      this._debug.unregisterSpine(this);\n    }\n    if (value) {\n      value.registerSpine(this);\n    }\n    this._debug = value;\n  }\n\n  private _autoUpdate = true;\n\n  public get autoUpdate(): boolean {\n    return this._autoUpdate;\n  }\n\n  public set autoUpdate(value: boolean) {\n    if (value) {\n      Ticker.shared.add(this.internalUpdate, this);\n      this.autoUpdateWarned = false;\n    } else {\n      Ticker.shared.remove(this.internalUpdate, this);\n    }\n    this._autoUpdate = value;\n  }\n\n  static from({ skeleton, atlas, scale = 1 }: SpineFromOptions) {\n    const cacheKey = `${skeleton}-${atlas}`;\n\n    if (Cache.has(cacheKey)) {\n      return new Spine(Cache.get<SkeletonData>(cacheKey));\n    }\n\n    const skeletonAsset = Assets.get<any | Uint8Array>(skeleton);\n\n    const atlasAsset = Assets.get<TextureAtlas>(atlas);\n    const attachmentLoader = new AtlasAttachmentLoader(atlasAsset);\n    // eslint-disable-next-line max-len\n    const parser =\n      skeletonAsset instanceof Uint8Array ? new SkeletonBinary(attachmentLoader) : new SkeletonJson(attachmentLoader);\n\n    // TODO scale?\n    parser.scale = scale;\n    const skeletonData = parser.readSkeletonData(skeletonAsset);\n\n    Cache.set(cacheKey, skeletonData);\n\n    return new Spine({\n      skeletonData,\n    });\n  }\n\n  public update(dt: number): void {\n    if (this.autoUpdate && !this.autoUpdateWarned) {\n      // eslint-disable-next-line max-len\n      console.warn(\n        'You are calling update on a Spine instance that has autoUpdate set to true. This is probably not what you want.',\n      );\n      this.autoUpdateWarned = true;\n    }\n    this.internalUpdate(0, dt);\n  }\n\n  public setBonePosition(bone: string | Bone, position: PointData): void {\n    const boneAux = bone;\n\n    if (typeof bone === 'string') {\n      bone = this.skeleton.findBone(bone) as Bone;\n    }\n\n    if (!bone) throw Error(`Cant set bone position, bone ${String(boneAux)} not found`);\n    vectorAux.set(position.x, position.y);\n\n    if (bone.parent) {\n      const aux = bone.parent.worldToLocal(vectorAux);\n\n      bone.x = aux.x;\n      bone.y = aux.y;\n    } else {\n      bone.x = vectorAux.x;\n      bone.y = vectorAux.y;\n    }\n  }\n\n  public getBonePosition(bone: string | Bone, outPos?: PointData): PointData | undefined {\n    const boneAux = bone;\n\n    if (typeof bone === 'string') {\n      bone = this.skeleton.findBone(bone) as Bone;\n    }\n\n    if (!bone) {\n      console.error(`Cant set bone position! Bone ${String(boneAux)} not found`);\n\n      return outPos;\n    }\n\n    if (!outPos) {\n      outPos = { x: 0, y: 0 };\n    }\n\n    outPos.x = bone.worldX;\n    outPos.y = bone.worldY;\n\n    return outPos;\n  }\n\n  updateState(dt: number) {\n    this.state.update(dt);\n    this._boundsDirty = true;\n    this.onViewUpdate();\n  }\n\n  onViewUpdate() {\n    // increment from the 12th bit!\n    this._didChangeId += 1 << 12;\n    this._didSpineUpdate = true;\n\n    this._didSpineUpdate = true;\n    this._boundsDirty = true;\n\n    if (this.didViewUpdate) return;\n    this.didViewUpdate = true;\n\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n\n    this.debug?.renderDebug(this);\n  }\n\n  updateBounds() {\n    this._boundsDirty = false;\n\n    this.skeletonBounds ||= new SkeletonBounds();\n\n    const skeletonBounds = this.skeletonBounds;\n\n    skeletonBounds.update(this.skeleton, true);\n\n    if (skeletonBounds.minX === Infinity) {\n      this.state.apply(this.skeleton);\n\n      // now region bounding attachments..\n      getSkeletonBounds(this.skeleton, this._bounds);\n    } else {\n      this._bounds.minX = skeletonBounds.minX;\n      this._bounds.minY = skeletonBounds.minY;\n      this._bounds.maxX = skeletonBounds.maxX;\n      this._bounds.maxY = skeletonBounds.maxY;\n    }\n  }\n\n  addBounds(bounds: Bounds) {\n    bounds.addBounds(this.bounds);\n  }\n\n  // passed local space..\n  public containsPoint(_point: PointData) {\n    return false;\n  }\n\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  public override destroy(options: DestroyOptions = false) {\n    super.destroy(options);\n    Ticker.shared.remove(this.internalUpdate, this);\n    this.state.clearListeners();\n    this.debug = undefined;\n    this.skeleton = null as any;\n    this.state = null as any;\n  }\n\n  protected internalUpdate(_deltaFrame: any, deltaSeconds?: number): void {\n    // Because reasons, pixi uses deltaFrames at 60fps.\n    // We ignore the default deltaFrames and use the deltaSeconds from pixi ticker.\n    this.updateState(deltaSeconds ?? Ticker.shared.deltaMS / 1000);\n  }\n}\n","import { Plugin } from '../Plugin';\nimport { extensions } from 'pixi.js';\nimport { Spine, spineLoaderExtension, SpinePipe, spineTextureAtlasLoader } from './pixi-spine';\n\nexport class SpinePlugin extends Plugin {\n  public readonly id = 'SpinePlugin';\n\n  public async initialize() {\n    extensions.add(spineTextureAtlasLoader);\n    extensions.add(spineLoaderExtension);\n    extensions.add(SpinePipe);\n    (window as any).Spine = Spine;\n  }\n}\n"],"names":["StringSet","value","contains","values","oldSize","i","n","Color","r","g","b","a","color","hex","c","MathUtils","min","max","degrees","x","y","mode","u","d","_Utils","source","sourceStart","dest","destStart","numElements","j","array","fromIndex","toIndex","size","defaultValue","alpha","blend","element","identity","type","name","Utils","Pool","instantiator","item","items","Vector2","len","Attachment","_VertexAttachment","slot","start","count","worldVertices","offset","stride","skeleton","deformArray","vertices","bones","bone","v","w","vx","vy","skip","skeletonBones","wx","wy","weight","deform","f","attachment","VertexAttachment","_Sequence","copy","index","region","basePath","result","frame","Sequence","SequenceMode","SequenceModeValues","Animation","timelines","duration","ids","lastTime","time","loop","events","direction","MixBlend","MixBlend2","MixDirection","MixDirection2","Property","Timeline","frames","step","frameCount","propertyIds","CurveTimeline","bezierCount","newCurves","bezier","time1","value1","cx1","cy1","cx2","cy2","time2","value2","curves","tmpx","tmpy","dddx","dddy","ddx","ddy","dx","dy","frameIndex","valueOffset","CurveTimeline1","propertyId","ii","curveType","before","CurveTimeline2","propertyId1","propertyId2","RotateTimeline","boneIndex","TranslateTimeline","t","TranslateXTimeline","TranslateYTimeline","ScaleTimeline","bx","by","ScaleXTimeline","ScaleYTimeline","ShearTimeline","ShearXTimeline","ShearYTimeline","RGBATimeline","slotIndex","setup","RGBTimeline","AlphaTimeline","RGBA2Timeline","light","dark","setupLight","setupDark","r2","g2","b2","RGB2Timeline","AttachmentTimeline","attachmentName","DeformTimeline","firedEvents","slotAttachment","vertexCount","vertexAttachment","setupVertices","lastVertices","percent","prevVertices","nextVertices","prev","_EventTimeline","frameTime","event","EventTimeline","_DrawOrderTimeline","idx","drawOrderToSetupIndex","drawOrder","slots","DrawOrderTimeline","IkConstraintTimeline","ikConstraintIndex","constraint","mix","softness","bendDirection","compress","stretch","TransformConstraintTimeline","transformConstraintIndex","data","rotate","scaleX","scaleY","shearY","mixRotate","mixX","mixY","mixScaleX","mixScaleY","mixShearY","PathConstraintPositionTimeline","pathConstraintIndex","position","PathConstraintSpacingTimeline","spacing","PathConstraintMixTimeline","_SequenceTimeline","modeAndIndex","delay","SequenceTimeline","_AnimationState","EventQueue","TrackEntry","delta","tracks","current","currentDelta","next","nextTime","from","to","finished","applied","animationLast","animationTime","applyTime","applyEvents","timelineCount","timeline","timelineMode","shortestRotation","firstFrame","timelineBlend","SUBSEQUENT","setupState","SETUP","attachments","alphaHold","alphaMix","timelineHoldMix","FIRST","HOLD_SUBSEQUENT","HOLD_FIRST","holdMix","CURRENT","timelinesRotation","r1","total","diff","lastTotal","lastDiff","dir","entry","animationStart","animationEnd","trackLastWrapped","complete","oldDrainDisabled","trackIndex","interrupt","animationName","animation","last","mixDuration","timelinesCount","propertyIDs","outer","HOLD_MIX","listener","AnimationState","animState","objects","listeners","AnimationStateData","skeletonData","fromName","toName","key","BoundingBoxAttachment","ClippingAttachment","Texture","image","TextureFilter","TextureWrap","TextureRegion","TextureAtlas","atlasText","reader","TextureAtlasReader","pageFields","page","regionFields","line","names","TextureAtlasRegion","field","entryValues","TextureAtlasPage","_a","assetManager","pathPrefix","text","colon","lastMatch","comma","texture","MeshAttachment","path","regionUVs","uvs","width","height","textureWidth","textureHeight","parentMesh","PathAttachment","PointAttachment","point","cos","sin","_RegionAttachment","regionScaleX","regionScaleY","localX","localY","localX2","localY2","radians","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","vertexOffset","offsetX","offsetY","RegionAttachment","AtlasAttachmentLoader","atlas","skin","sequence","regions","BoneData","parent","TransformMode","TransformMode2","Bone","rotation","shearX","rotationY","sx","sy","pa","pb","pc","pd","la","lb","lc","ld","s","prx","rx","ry","za","zc","zb","zd","pid","ia","id","ib","ic","ra","rb","rc","rd","det","world","invDet","local","worldRotation","localRotation","ConstraintData","order","skinRequired","Event","EventData","IkConstraint","target","targetX","targetY","uniform","p","rotationIK","tx","ty","sa","sc","dd","child","bendDir","px","py","psx","psy","csx","os1","os2","s2","cx","cy","cwx","cwy","pp","l1","l2","a1","a2","td","sd","aa","bb","ta","c1","c2","q","r0","minAngle","minX","minDist","minY","maxAngle","maxX","maxDist","maxY","os","IkConstraintData","boneData","PathConstraintData","slotData","PositionMode","PositionMode2","SpacingMode","SpacingMode2","RotateMode","RotateMode2","_PathConstraint","tangents","scale","boneCount","spacesCount","spaces","lengths","setupLength","sum","length","lengthSpacing","positions","boneX","boneY","offsetRotation","tip","out","closed","verticesLength","curveCount","prevCurve","pathLength","multiplier","o","curve","space","x1","y1","x2","y2","dddfx","dddfy","ddfx","ddfy","dfx","dfy","segments","curveLength","segment","temp","tt","ttt","uu","uuu","ut","ut3","uut3","utt3","PathConstraint","Slot","TransformConstraint","translate","tb","tc","degRadReflect","offsetShearY","_Skeleton","ikConstraintData","transformConstraintData","pathConstraintData","updateCache","skinBones","ikConstraints","transformConstraints","pathConstraints","ikCount","transformCount","pathCount","constraintCount","constrained","slotBone","pathBones","nn","rootBone","updatable","boneName","slotName","skinName","newSkin","constraintName","ikConstraint","mesh","Skeleton","SkeletonData","skins","eventDataName","animations","SkinEntry","Skin","contained","dictionary","entries","slotAttachments","oldSkin","skinAttachment","SlotData","BlendMode","BlendMode2","TransformConstraintData","SkeletonBinary","attachmentLoader","binary","input","BinaryInput","lowHash","highHash","nonessential","str","darkColor","defaultSkin","linkedMesh","eventName","slotCount","box","triangles","hullLength","edges","inheritTimelines","LinkedMesh","constantSpeed","endSlotIndex","clip","Vertices","weights","bonesArray","timelineType","frameLast","SLOT_ATTACHMENT","SLOT_RGBA","CURVE_STEPPED","CURVE_BEZIER","setBezier","SLOT_RGB","SLOT_RGBA2","nr","ng","nb","na","nr2","ng2","nb2","SLOT_RGB2","SLOT_ALPHA","BONE_ROTATE","readTimeline1","BONE_TRANSLATE","readTimeline2","BONE_TRANSLATEX","BONE_TRANSLATEY","BONE_SCALE","BONE_SCALEX","BONE_SCALEY","BONE_SHEAR","BONE_SHEARX","BONE_SHEARY","mix2","softness2","mixRotate2","mixX2","mixY2","mixScaleX2","mixScaleY2","mixShearY2","PATH_POSITION","PATH_SPACING","PATH_MIX","iii","nnn","ATTACHMENT_DEFORM","weighted","deformLength","end","vn","ATTACHMENT_SEQUENCE","drawOrderCount","offsetCount","unchanged","originalIndex","unchangedIndex","eventCount","eventData","strings","buffer","optimizePositive","byteCount","chars","LinkedMesh$1","inheritDeform","nvalue1","nvalue2","SkeletonBounds","updateAabb","boundingBoxes","polygons","polygonPool","boundingBox","polygon","m","bounds","prevIndex","inside","vertexY","prevY","vertexX","width12","height12","det1","x3","y3","x4","y4","det2","width34","height34","det3","Triangulator","indices","previous","p1x","p1y","p2x","p2y","p3x","p3y","verticesArray","isConcave","p1","p2","p3","previousIndex","nextIndex","convexPolygons","convexPolygonsIndices","polygonIndices","fanBaseIndex","lastWinding","t1","t2","t3","merged","winding1","winding2","firstIndex","lastIndex","prevPrevX","prevPrevY","prevX","firstX","firstY","secondX","secondY","winding","otherIndices","otherFirstIndex","otherSecondIndex","otherLastIndex","otherPoly","SkeletonClipping","verticeslength","area","lastX","other","clippingPolygon","clippingPolygons","trianglesLength","twoColor","clipOutput","clippedVertices","clippedTriangles","polygonsCount","vertexSize","u1","v1","u2","v2","u3","v3","clipOutputLength","d0","d1","d2","d4","clipOutputCount","clipOutputItems","clippedVerticesItems","c0","clippedTrianglesItems","clippingArea","output","originalOutput","clipped","clippingVertices","clippingVerticesLast","edgeX","edgeY","edgeX2","edgeY2","deltaX","deltaY","inputVertices","inputVerticesLength","outputStart","inputX","inputY","inputX2","inputY2","side2","ua","SkeletonJson","json","root","skeletonMap","boneMap","parentName","getValue","slotMap","constraintMap","targetName","skinMap","entryName","eventMap","animationMap","map","scaledVertices","timelineName","timelineMap","keyMap","nextMap","newColor","readCurve","color2","newColor2","constraintIndex","attachmentsName","attachmentsMap","slotMapName","attachmentMapName","attachmentMap","timelineMapName","verticesValue","lastDelay","drawOrderMap","offsets","offsetMap","keys","name1","name2","property","_SpineTexture","PixiTexture","filter","wrap","minFilter","magFilter","style","uWrap","vWrap","SpineTexture","spineTextureAtlasLoader","ExtensionType","LoaderParserPriority","url","checkExtension","DOMAdapter","asset","options","isExtensionRight","isString","loader","metadata","retval","TextureSource","pixiTexture","textureLoadingPromises","pageName","providedPage","pixiPromise","isJson","resource","isBuffer","spineLoaderExtension","response","isJsonSpineModel","isBinarySpineModel","BatchableClippedSpineSlot","clipper","copyArray","indexBuffer","indicesOffset","float32View","uint32View","textureId","abgr","textureIdAndRound","localIndex","QUAD_TRIANGLES","BatchableSpineSlot","parentColor","parentAlpha","slotColor","mixedA","parentB","parentG","parentR","mixedR","mixedG","mixedB","matrix","QUAD_VERTS","lightColor","_SpinePipe","renderer","_renderable","spine","batcher","activeBatchableSpineSlot","batchableSpineSlot","BigPool","_b","activeBatchableSpineSlots","SpinePipe","tempVerts","getSkeletonBounds","vectorAux","Spine","Container","Bounds","Ticker","cacheKey","Cache","skeletonAsset","Assets","atlasAsset","parser","dt","boneAux","aux","outPos","renderGroup","skeletonBounds","_point","_deltaFrame","deltaSeconds","SpinePlugin","Plugin","extensions"],"mappings":"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"}