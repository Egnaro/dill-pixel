{"version":3,"file":"dill-pixel-plugin-snap-physics.mjs","sources":["../src/SpatialHashGrid.ts","../src/Entity.ts","../src/Solid.ts","../src/Wall.ts","../src/utils.ts","../src/System.ts","../src/SnapPhysicsPlugin.ts","../src/Actor.ts","../src/Sensor.ts"],"sourcesContent":["import { Graphics, Rectangle } from 'pixi.js';\nimport { Entity } from './Entity';\nimport { SpatialHashGridFilter } from './types';\nimport { System } from './System';\n\ntype GridKey = string;\n\nexport class SpatialHashGrid {\n  private cells: Map<GridKey, Set<Entity>> = new Map();\n\n  constructor(cellSize: number, insertEntities: boolean = false) {\n    this._cellSize = cellSize;\n    if (insertEntities) {\n      System.all.forEach((entity) => this.insert(entity));\n    }\n  }\n\n  private _cellSize: number;\n\n  get cellSize(): number {\n    return this._cellSize;\n  }\n\n  set cellSize(size: number) {\n    this._cellSize = size;\n    this.cells.clear();\n    this.updateAll();\n  }\n\n  destroy() {\n    this.cells.clear();\n  }\n\n  insert(entity: Entity): void {\n    const bounds = entity.getBoundingBox();\n\n    const startX = Math.floor(bounds.x / this._cellSize);\n    const startY = Math.floor(bounds.y / this._cellSize);\n    const endX = Math.floor((bounds.x + bounds.width) / this._cellSize);\n    const endY = Math.floor((bounds.y + bounds.height) / this._cellSize);\n\n    for (let x = startX; x <= endX; x++) {\n      for (let y = startY; y <= endY; y++) {\n        const key = this.getGridKey(x * this._cellSize, y * this._cellSize); // Use actual world coordinates\n        if (!this.cells.has(key)) {\n          this.cells.set(key, new Set());\n        }\n\n        this.cells.get(key)?.add(entity);\n      }\n    }\n  }\n\n  remove(entity: Entity): void {\n    this.cells.forEach((entities) => {\n      entities.delete(entity);\n    });\n  }\n\n  query(range: Rectangle, filter?: SpatialHashGridFilter | string[]): Entity[] {\n    const foundEntities = new Set<Entity>();\n\n    // Ensure we handle negative or reverse ranges appropriately\n    const startX = Math.floor(Math.min(range.x, range.x + range.width) / this._cellSize);\n    const startY = Math.floor(Math.min(range.y, range.y + range.height) / this._cellSize);\n    const endX = Math.floor(Math.max(range.x, range.x + range.width) / this._cellSize);\n    const endY = Math.floor(Math.max(range.y, range.y + range.height) / this._cellSize);\n\n    for (let x = startX; x <= endX; x++) {\n      for (let y = startY; y <= endY; y++) {\n        const key = this.getGridKey(x * this._cellSize, y * this._cellSize);\n\n        const cellEntities = this.cells.get(key);\n        if (cellEntities) {\n          cellEntities.forEach((entity) => {\n            if (filter !== undefined) {\n              if (Array.isArray(filter)) {\n                if (filter.includes(entity.type)) {\n                  foundEntities.add(entity);\n                }\n              } else {\n                if (filter(entity)) {\n                  foundEntities.add(entity);\n                }\n              }\n            } else {\n              foundEntities.add(entity);\n            }\n          });\n        }\n      }\n    }\n    return [...foundEntities];\n  }\n\n  updateAll() {\n    System.all.forEach((entity) => this.updateEntity(entity));\n  }\n\n  updateEntity(entity: Entity): void {\n    // Remove the entity from its current cell\n    this.remove(entity);\n\n    // Re-insert the entity into the grid based on its new position\n    this.insert(entity);\n  }\n\n  draw(gfx: Graphics) {\n    const rects = this._getDebugRects();\n    rects.forEach((rect) => {\n      gfx.rect(rect.left, rect.top, rect.width, rect.height);\n      gfx.stroke({ color: 0x00ff00 });\n    });\n  }\n\n  private _getDebugRects() {\n    const rects: Rectangle[] = [];\n    this.cells.forEach((_cell, key) => {\n      const [x, y] = key.split(':').map(Number);\n      if (_cell.size) {\n        rects.push(new Rectangle(x * this._cellSize, y * this._cellSize, this._cellSize, this._cellSize));\n      }\n    });\n    return rects;\n  }\n\n  private getGridKey(x: number, y: number): GridKey {\n    const cellX = Math.floor(x / this._cellSize);\n    const cellY = Math.floor(y / this._cellSize);\n    return `${cellX}:${cellY}`;\n  }\n}\n","import type { Container as PIXIContianer } from 'pixi.js';\nimport { Bounds, Rectangle, Sprite } from 'pixi.js';\nimport { Application, Container } from 'dill-pixel';\nimport { ICollider } from './ICollider';\nimport { System } from './System';\nimport { EntityType } from './types';\n\nexport class Entity<T = any, A extends Application = Application> extends Container<A> implements ICollider {\n  isActor: boolean = false;\n  isSolid: boolean = false;\n  isSensor: boolean = false;\n  debug: boolean = false;\n  debugColors = {\n    bounds: 0xff0000,\n    outerBounds: 0x00ff00,\n  };\n  type: EntityType = 'Solid';\n  view: PIXIContianer;\n  isCollideable: boolean = true;\n  xRemainder: number = 0;\n  yRemainder: number = 0;\n  config: T;\n\n  constructor(config?: Partial<T>) {\n    super();\n    this.config = config as T;\n  }\n\n  protected _cachedBounds: Bounds | Rectangle | null = null;\n\n  get cachedBounds(): Bounds | Rectangle {\n    if (!this._cachedBounds || this._dirtyBounds) {\n      const bounds = this.view.getBounds();\n      bounds.scale(1 / this.system.container.worldTransform.d);\n      this._cachedBounds = bounds;\n    }\n    return this._cachedBounds || new Rectangle();\n  }\n\n  set cachedBounds(value: Bounds) {\n    this._cachedBounds = value;\n  }\n\n  protected _dirtyBounds: boolean = true;\n\n  get dirtyBounds() {\n    return this._dirtyBounds;\n  }\n\n  set dirtyBounds(value: boolean) {\n    this._dirtyBounds = value;\n  }\n\n  get top(): number {\n    return this.getBoundingBox().top;\n  }\n\n  get bottom(): number {\n    return this.getBoundingBox().bottom;\n  }\n\n  get left(): number {\n    return this.getBoundingBox().left;\n  }\n\n  get right(): number {\n    return this.getBoundingBox().right;\n  }\n\n  get system(): typeof System {\n    return System;\n  }\n\n  get collideables(): Entity[] {\n    return [];\n  }\n\n  getWorldBounds(): Bounds | Rectangle {\n    const pos = this.system.container.toLocal(this.view.getGlobalPosition());\n    const bounds = this.cachedBounds;\n    bounds.x = pos.x;\n    bounds.y = pos.y;\n\n    if (this.view instanceof Sprite && this.view.anchor) {\n      bounds.x -= this.view.width * this.view.anchor.x;\n      bounds.y -= this.view.height * this.view.anchor.y;\n    }\n\n    return bounds;\n  }\n\n  getBoundingBox(): Rectangle {\n    const bounds = this.getWorldBounds();\n    return bounds instanceof Bounds ? bounds.rectangle : bounds;\n  }\n\n  getOuterBoundingBox(): Rectangle | null {\n    return null;\n  }\n\n  protected initialize() {}\n}\n","import { Application } from 'dill-pixel';\nimport { Actor } from './Actor';\nimport { Entity } from './Entity';\nimport { System } from './System';\n\nexport class Solid<T = any, A extends Application = Application> extends Entity<T, A> {\n  type = 'Solid';\n  isSolid = true;\n\n  get collideables(): Entity[] {\n    return System.getNearbyEntities(this, (entity) => entity.isActor);\n  }\n\n  added() {\n    System.addSolid(this);\n  }\n\n  removed() {\n    System.removeSolid(this);\n  }\n\n  move(x: number, y: number): void {\n    this.xRemainder += x;\n    this.yRemainder += y;\n    const moveX = Math.round(this.xRemainder);\n    const moveY = Math.round(this.yRemainder);\n    const ridingActors = this.getAllRidingActors();\n    if (moveX !== 0 || moveY !== 0) {\n      // Temporarily make this solid non-collidable\n      this.isCollideable = false;\n\n      // Move on the Y axis\n      this.y += moveY;\n      this.yRemainder -= moveY;\n      this.handleActorInteractions(0, moveY, ridingActors);\n\n      // Move on the X axis\n      this.x += moveX;\n      this.xRemainder -= moveX;\n      this.handleActorInteractions(moveX, 0, ridingActors);\n\n      // Re-enable collisions\n      this.isCollideable = true;\n    }\n    System.updateEntity(this);\n  }\n\n  getAllRidingActors(): Actor[] {\n    // Implement logic to get all actors riding this solid\n    return (this.collideables as Actor[]).filter((actor: Actor) => {\n      return actor.isRiding(this);\n    });\n  }\n\n  // Simple collision detection between this solid and an actor\n  collidesWith(entity: Entity, dx: number, dy: number): boolean {\n    return System.getRectangleIntersection(entity, this, dx, dy);\n  }\n\n  public handleActorInteractions(\n    deltaX: number,\n    deltaY: number,\n    ridingActors: Actor[] = this.getAllRidingActors(),\n  ): void {\n    (this.collideables as Actor[]).forEach((actor) => {\n      if (ridingActors.includes(actor)) {\n        // Move riding actors along with this solid\n        actor.moveY(deltaY);\n        actor.moveX(deltaX);\n      } else if (\n        !actor.passThroughTypes.includes(this.type) &&\n        !actor.isPassingThrough(this) &&\n        this.collidesWith(actor, deltaX, deltaY)\n      ) {\n        // Push actors only the minimum amount necessary to avoid overlap\n        const overlapX =\n          deltaX !== 0\n            ? deltaX > 0\n              ? this.getBoundingBox().right - actor.getBoundingBox().left\n              : this.getBoundingBox().left - actor.getBoundingBox().right\n            : 0;\n\n        if (overlapX !== 0) {\n          actor.moveX(overlapX, actor.squish, null, this);\n        }\n\n        const overlapY =\n          deltaY !== 0\n            ? deltaY > 0\n              ? this.getBoundingBox().bottom - actor.getBoundingBox().top\n              : this.getBoundingBox().top - actor.getBoundingBox().bottom\n            : 0;\n\n        if (overlapY !== 0) {\n          actor.moveY(overlapY, actor.squish, null, this);\n        }\n      }\n    });\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected handleCollisionChange(_isColliding?: boolean) {}\n}\n","import { Texture } from 'pixi.js';\nimport { Solid as SnapSolid } from './Solid';\n\nexport type WallConfig = {\n  width: number;\n  height: number;\n  debugColor: number;\n};\n\nconst defaults: WallConfig = {\n  width: 10,\n  height: 10,\n  debugColor: 0x00ffff,\n};\n\nexport class Wall extends SnapSolid<WallConfig> {\n  type = 'Wall';\n\n  constructor(config: Partial<WallConfig> = {}) {\n    super({ ...defaults, ...config });\n    this.initialize();\n  }\n\n  protected initialize() {\n    this.view = this.add.sprite({\n      asset: Texture.WHITE,\n      width: this.config.width,\n      height: this.config.height,\n      tint: this.config.debugColor,\n      anchor: 0.5,\n    });\n  }\n}\n","import { Point, Rectangle } from 'pixi.js';\nimport { Entity } from './Entity';\nimport { ICollider } from './ICollider';\nimport { Collision } from './types';\n\nexport function checkPointIntersection(point: Point, collider: ICollider): boolean {\n  return point.x > collider.left && point.x < collider.right && point.y > collider.top && point.y < collider.bottom;\n}\n\ntype Overlap = {\n  x: number;\n  y: number;\n  area: number;\n};\n\nexport function getIntersectionArea(rectA: Rectangle, rectB: Rectangle): Overlap {\n  // Calculate the coordinates of the intersection rectangle\n  const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));\n  const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));\n\n  // The area of the intersection is the product of overlapping width and height\n  return { x: xOverlap, y: yOverlap, area: xOverlap * yOverlap };\n}\n\nexport function checkCollision(\n  rectA: Rectangle,\n  rectB: Rectangle,\n  entity1: Entity,\n  entity2: Entity,\n): Collision | false {\n  const overlap: Collision = {\n    top: false,\n    bottom: false,\n    left: false,\n    right: false,\n    entity1,\n    entity2,\n    type: `${entity1?.type}|${entity2?.type}`,\n  };\n\n  if (rectA.intersects(rectB)) {\n    overlap.left = rectA.left < rectB.right && rectA.left > rectB.left;\n    overlap.right = rectA.right > rectB.left && rectA.right < rectB.right;\n    overlap.top = rectA.top < rectB.bottom && rectA.top > rectB.top;\n    overlap.bottom = rectA.bottom > rectB.top && rectA.bottom < rectB.bottom;\n    return overlap;\n  }\n  return false;\n}\n","import { Container, Graphics, Point } from 'pixi.js';\nimport { IApplication, ICamera, Logger, Signal } from 'dill-pixel';\nimport { Actor } from './Actor';\nimport { Entity } from './Entity';\nimport { Sensor } from './Sensor';\nimport { Solid } from './Solid';\nimport { SpatialHashGrid } from './SpatialHashGrid';\nimport { Collision, EntityType, Side, SpatialHashGridFilter } from './types';\nimport { Wall } from './Wall';\nimport { getIntersectionArea } from './utils';\nimport { SnapPhysicsPlugin } from './SnapPhysicsPlugin';\n\ntype SystemBoundary = {\n  width: number;\n  height: number;\n  padding: number;\n};\n\ntype SnapPhysicsBoundaryOptions = {\n  width: number;\n  height: number;\n  thickness: number;\n  padding: number;\n  sides: Side[];\n};\ntype OptionalSnapPhysicsBoundaryOptions = Partial<SnapPhysicsBoundaryOptions>;\ntype RequiredWidthAndHeight = Required<Pick<SnapPhysicsBoundaryOptions, 'width' | 'height'>>;\ntype CustomSnapPhysicsBoundaryOptions = OptionalSnapPhysicsBoundaryOptions & RequiredWidthAndHeight;\n\ntype SnapPhysicsSystemOptions = {\n  gravity: number;\n  fps: number;\n  container: Container;\n  debug: boolean;\n  boundary: CustomSnapPhysicsBoundaryOptions;\n  collisionResolver: (collision: Collision) => boolean;\n  useSpatialHashGrid: boolean;\n  cellSize: number;\n};\n\nexport class System {\n  public static DEFAULT_COLLISION_THRESHOLD: number = 2;\n  public static plugin: SnapPhysicsPlugin;\n  public static app: IApplication;\n  public static container: Container<any>;\n  public static grid: SpatialHashGrid | null;\n  public static fps: number;\n  //\n  static debug: boolean = true;\n  static typeMap: Map<EntityType, Entity[]> = new Map();\n  static actors: Actor[] = [];\n  static solids: Solid[] = [];\n  static sensors: Sensor[] = [];\n  static enabled: boolean = true;\n  static gravity: number = 10;\n  static onCollision: Signal<(collision: Collision) => void> = new Signal<(collision: Collision) => void>();\n  static worldBounds: Wall[] = [];\n  static boundary: SystemBoundary;\n  static camera?: ICamera;\n  static collisionThreshold = 8;\n  private static gfx: Graphics;\n\n  private static _collisionResolver: ((collision: Collision) => boolean) | null = null;\n\n  static set collisionResolver(collisionResolverMethod: (collision: Collision) => boolean) {\n    System._collisionResolver = collisionResolverMethod;\n  }\n\n  static get worldWidth() {\n    return System.boundary?.width ? System.boundary.width + (System.boundary.padding ?? 0) : System.container.width;\n  }\n\n  static get worldHeight() {\n    return System.boundary?.height ? System.boundary.height + (System.boundary.padding ?? 0) : System.container.height;\n  }\n\n  static get all(): Entity[] {\n    return [...System.actors, ...System.solids];\n  }\n\n  static get totalEntities(): number {\n    return System.actors.length + System.solids.length + System.sensors.length;\n  }\n\n  static useSpatialHashGrid(cellSize: number) {\n    if (System.grid) {\n      System.grid.cellSize = cellSize;\n    } else {\n      System.grid = new SpatialHashGrid(cellSize, true);\n    }\n    System.plugin.options.useSpatialHashGrid = true;\n  }\n\n  static removeSpatialHashGrid() {\n    if (System.grid) {\n      System.grid.destroy();\n      System.grid = null;\n    }\n  }\n\n  static resolveCollision(collision: Collision) {\n    // Implement collision resolution logic\n    return System._collisionResolver ? System._collisionResolver(collision) : true;\n  }\n\n  static addEntity(entity: Entity) {\n    if (!System.typeMap.has(entity.type)) {\n      System.typeMap.set(entity.type, []);\n    }\n    System.typeMap.get(entity.type)!.push(entity);\n\n    if (System.grid) {\n      System.grid.insert(entity);\n    }\n  }\n\n  static removeEntity(entity: Entity) {\n    if (System.grid) {\n      System.grid.remove(entity);\n    }\n    if (System.typeMap.has(entity.type)) {\n      const entities = System.typeMap.get(entity.type)!;\n      const index = entities.indexOf(entity);\n      if (index !== -1) {\n        entities.splice(index, 1);\n      }\n    }\n  }\n\n  static getEntitiesByType<T extends Entity = Entity>(...type: EntityType[]): T[] {\n    if (type.length === 0) {\n      return (System.typeMap.get(type[0]) as T[]) || [];\n    }\n    return type.reduce((acc: T[], t: EntityType) => {\n      const entities = System.typeMap.get(t) as T[];\n      if (entities?.length) {\n        return [...acc, ...entities];\n      }\n      return acc;\n    }, []);\n  }\n\n  static addActor(actor: Actor) {\n    System.actors.push(actor);\n    System.addEntity(actor);\n  }\n\n  static addSolid(solid: Solid) {\n    System.solids.push(solid);\n    System.addEntity(solid);\n  }\n\n  static addSensor(sensor: Sensor) {\n    System.sensors.push(sensor);\n    System.addEntity(sensor);\n  }\n\n  static removeActor(actor: Actor) {\n    System.removeEntity(actor);\n    const index = System.actors.indexOf(actor);\n    if (index !== -1) {\n      System.actors.splice(index, 1);\n    }\n  }\n\n  static removeSolid(solid: Solid) {\n    System.removeEntity(solid);\n    const index = System.solids.indexOf(solid);\n    if (index !== -1) {\n      System.solids.splice(index, 1);\n    }\n  }\n\n  static removeSensor(sensor: Sensor) {\n    System.removeEntity(sensor);\n    const index = System.sensors.indexOf(sensor);\n    if (index !== -1) {\n      System.sensors.splice(index, 1);\n    }\n  }\n\n  static getNearbyEntities(entity: Entity, onlyTypes?: string[]): Entity[];\n\n  static getNearbyEntities(entity: Entity, filter?: SpatialHashGridFilter): Entity[];\n\n  static getNearbyEntities(entity: Entity, filter?: SpatialHashGridFilter | string[]): Entity[] {\n    if (System.grid) {\n      const bounds = entity.getBoundingBox();\n      return System.grid.query(bounds, filter);\n    }\n    return System.all.filter((e: Entity) => {\n      if (filter) {\n        if (Array.isArray(filter)) {\n          return filter.includes(e.type);\n        } else {\n          return filter(e);\n        }\n      }\n      return true;\n    });\n  }\n\n  /**\n   * @param entity1\n   * @param entity2\n   * @param dx\n   * @param dy\n   */\n  static getRectangleIntersection(entity1: Entity, entity2: Entity, dx: number, dy: number): boolean {\n    const bounds1 = entity1.getBoundingBox();\n    const bounds2 = entity2.getBoundingBox().clone();\n    bounds2.x += dx;\n    bounds2.y += dy;\n    const intersection = getIntersectionArea(bounds1, bounds2);\n    return intersection.area > 0 && intersection.area > System.collisionThreshold;\n  }\n\n  static update(\n    deltaTime: number,\n    preUpdateHooks?: ((deltaTime: number) => void)[],\n    postUpdateHooks?: ((deltaTime: number) => void)[],\n  ) {\n    if (!System.enabled) {\n      return;\n    }\n    if (!System.container) {\n      Logger.error('SnapPhysicsPlugin: World container not set!');\n    }\n    if (preUpdateHooks) {\n      preUpdateHooks.forEach((hook) => hook(deltaTime));\n    }\n    // Implement world step logic\n    System.actors.forEach((actor: Actor) => {\n      actor.update(deltaTime);\n    });\n    System.solids.forEach((solid: Solid) => {\n      solid.update(deltaTime);\n    });\n    System.sensors.forEach((sensor: Sensor) => {\n      sensor.update(deltaTime);\n    });\n\n    if (postUpdateHooks) {\n      postUpdateHooks.forEach((hook) => hook(deltaTime));\n    }\n\n    if (System.debug) {\n      System.drawDebug();\n    } else {\n      if (System.gfx) {\n        System.gfx.clear();\n      }\n    }\n\n    if (System.camera) {\n      System.camera.update();\n    }\n  }\n\n  static addBoundary(\n    width: number,\n    height: number,\n    size: number = 10,\n    padding: number = 5,\n    sides: Side[] = ['top', 'bottom', 'left', 'right'],\n  ) {\n    if (!System.container) {\n      throw new Error('System container not set. Set World.container before calling System.addBoundary().');\n    }\n    if (System.worldBounds.length > 0) {\n      // World bounds already added\n      // remove existing bounds\n      System.worldBounds.forEach((wall: Wall) => {\n        wall.parent.removeChild(wall);\n        wall.destroy();\n      });\n      System.worldBounds = [];\n    }\n    const pos = new Point(0, 0);\n    const container = System.container;\n    let wall: Wall;\n    if (sides.includes('bottom')) {\n      wall = container.addChild(new Wall({ width, height: size }));\n      wall.position.set(pos.x + width * 0.5, pos.y + height + padding);\n      System.worldBounds.push(wall);\n    }\n    if (sides.includes('top')) {\n      wall = container.addChild(new Wall({ width, height: size }));\n      wall.position.set(pos.x + width * 0.5, pos.y + size * 0.5);\n      System.worldBounds.push(wall);\n    }\n\n    if (sides.includes('left')) {\n      wall = container.addChild(new Wall({ width: size, height }));\n      wall.position.set(pos.x - size * 0.5 - padding, pos.y + height * 0.5 + size * 0.5);\n      System.worldBounds.push(wall);\n    }\n\n    if (sides.includes('right')) {\n      wall = container.addChild(new Wall({ width: size, height }));\n      wall.position.set(pos.x + width + padding + size * 0.5, pos.y + height * 0.5);\n      System.worldBounds.push(wall);\n    }\n\n    if (System.grid) {\n      System.worldBounds.forEach((wall: Wall) => {\n        System.grid?.remove(wall);\n        System.grid?.insert(wall);\n      });\n    }\n  }\n\n  static collide(collision: Collision) {\n    if (!collision.type && collision.entity1 && collision.entity2) {\n      collision.type = `${collision.entity1.type}|${collision.entity2.type}`;\n    }\n    this.onCollision.emit(collision);\n  }\n\n  static drawDebug() {\n    if (!System.container) {\n      return;\n    }\n    if (!System.gfx) {\n      System.gfx = new Graphics();\n      System.container.addChild(System.gfx);\n    }\n    // move to top\n    System.container.setChildIndex(System.gfx, System.container.children.length - 1);\n    System.gfx.clear();\n    [...System.actors, ...System.solids, ...System.sensors].forEach((entity: Entity) => {\n      const bounds = entity.getBoundingBox();\n      const outerBounds = entity.getOuterBoundingBox();\n      System.gfx\n        .rect(bounds.x, bounds.y, bounds.width, bounds.height)\n        .stroke({ width: 1, color: entity.debugColors.bounds, alignment: 0.5 });\n      if (outerBounds) {\n        System.gfx\n          .rect(outerBounds.x, outerBounds.y, outerBounds.width, outerBounds.height)\n          .stroke({ width: 1, color: entity.debugColors.outerBounds, alignment: 0.5 });\n      }\n    });\n\n    if (System.grid) {\n      System.grid.draw(System.gfx);\n    }\n  }\n\n  static setContainer(container: Container) {\n    System.container = container;\n  }\n\n  static initialize(opts: Partial<SnapPhysicsSystemOptions>) {\n    System.enabled = true;\n    if (opts.gravity) {\n      System.gravity = opts.gravity;\n    }\n    if (opts.fps) {\n      System.fps = opts.fps;\n      this.app.ticker.maxFPS = opts.fps;\n    }\n    if (opts.container) {\n      System.setContainer(opts.container);\n    }\n    if (opts.debug !== undefined) {\n      System.debug = opts.debug;\n    }\n    if (opts.collisionResolver) {\n      System.collisionResolver = opts.collisionResolver;\n    }\n    if (opts.boundary) {\n      System.boundary = {\n        width: opts.boundary.width,\n        height: opts.boundary.height,\n        padding: opts.boundary.padding ?? 0,\n      };\n      if (opts.boundary.width && opts.boundary.height) {\n        System.addBoundary(\n          opts.boundary.width,\n          opts.boundary.height,\n          opts.boundary.thickness,\n          opts.boundary.padding,\n          opts.boundary.sides,\n        );\n      } else {\n        Logger.error('SnapPhysicsPlugin System.initialize: Boundary width and height required.');\n      }\n    }\n\n    if (opts.useSpatialHashGrid) {\n      System.useSpatialHashGrid(opts.cellSize ?? 100);\n    }\n  }\n\n  static updateEntity(entity: Entity) {\n    if (System.grid) {\n      System.grid.updateEntity(entity);\n    }\n  }\n\n  static cleanup() {\n    if (System.worldBounds) {\n      System.worldBounds.forEach((wall: Wall) => {\n        wall.parent.removeChild(wall);\n        wall.destroy();\n      });\n      System.worldBounds = [];\n    }\n\n    if (System.container) {\n      System.container.removeChildren();\n      // @ts-expect-error container can't be null\n      System.container = null;\n    }\n    if (System.gfx) {\n      System.gfx.clear();\n      // @ts-expect-error GFX can't be null\n      System.gfx = null;\n    }\n\n    if (System.grid) {\n      System.grid.destroy();\n      System.grid = null;\n    }\n\n    if (System.camera) {\n      // @ts-expect-error camera can't be null\n      System.camera = null;\n    }\n\n    this.solids = [];\n    this.actors = [];\n    this.sensors = [];\n    this.typeMap.clear();\n    this.worldBounds = [];\n  }\n}\n","import { IApplication, Plugin } from 'dill-pixel';\nimport { System } from './System';\n\ntype SnapPhysicsPluginOptions = {\n  useSpatialHashGrid: boolean;\n  gridCellSize: number;\n  fps: number;\n};\n\nconst defaultOptions = {\n  useSpatialHashGrid: false,\n  gridCellSize: -1,\n  fps: -1,\n};\n\nexport class SnapPhysicsPlugin extends Plugin {\n  public readonly id = 'SnapPhysicsPlugin';\n  public options: SnapPhysicsPluginOptions;\n\n  get gridCellSize(): number {\n    return this.options.gridCellSize;\n  }\n\n  set gridCellSize(value: number) {\n    this.options.gridCellSize = value;\n    if (this.options.useSpatialHashGrid && this.options.gridCellSize > 0) {\n      System.useSpatialHashGrid(this.options.gridCellSize);\n    }\n  }\n\n  get useSpatialHashGrid(): boolean {\n    return this.options.useSpatialHashGrid;\n  }\n\n  set useSpatialHashGrid(value: boolean) {\n    this.options.useSpatialHashGrid = value;\n\n    if (this.options.useSpatialHashGrid && this.options.gridCellSize > 0) {\n      System.useSpatialHashGrid(this.options.gridCellSize);\n    } else {\n      System.removeSpatialHashGrid();\n    }\n  }\n\n  set fps(value: number) {\n    this.options.fps = value;\n    System.fps = value;\n    this.app.ticker.maxFPS = value;\n  }\n\n  public get system(): typeof System {\n    return System;\n  }\n\n  destroy() {\n    this.system.enabled = false;\n    System.cleanup();\n    super.destroy();\n  }\n\n  public async initialize(app: IApplication, options?: Partial<SnapPhysicsPluginOptions>) {\n    this.options = { ...defaultOptions, ...options };\n    this.system.app = app;\n    this.system.plugin = this;\n    this.system.enabled = true;\n\n    if (this.options.useSpatialHashGrid && this.options.gridCellSize > 0) {\n      this.system.useSpatialHashGrid(this.options.gridCellSize);\n    }\n    if (this.options.fps > 0) {\n      System.fps = this.options.fps;\n      app.ticker.maxFPS = System.fps;\n    }\n  }\n}\n","import { Point, Rectangle } from 'pixi.js';\nimport { Application } from 'dill-pixel';\nimport { Entity } from './Entity';\nimport { System } from './System';\nimport { Collision, EntityType } from './types';\nimport { checkCollision } from './utils';\n\nexport class Actor<T = any, A extends Application = Application> extends Entity<T, A> {\n  type = 'Actor';\n  isActor = true;\n  passThroughTypes: EntityType[] = [];\n  passingThrough: Set<Entity> = new Set();\n  riding: Set<Entity> = new Set();\n  ridingAmounts: Map<Entity, number> = new Map();\n\n  get collideables(): Entity[] {\n    return System.getNearbyEntities(this, (e) => e.isSolid);\n  }\n\n  get mostRidingSolid(): Entity | null {\n    let mostRiding: Entity | null = null;\n    let mostRidingAmount = 0;\n    for (const [solid, amount] of this.ridingAmounts) {\n      if (amount > mostRidingAmount) {\n        mostRiding = solid;\n        mostRidingAmount = amount;\n      }\n    }\n    return mostRiding;\n  }\n\n  added() {\n    System.addActor(this);\n  }\n\n  removed() {\n    System.removeActor(this);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  squish(_collision?: Collision, _pushingEntity?: Entity, _direction?: Point) {}\n\n  moveX(\n    amount: number,\n    onCollide?: ((collision: Collision, pushingEntity?: Entity, direction?: Point) => void) | null,\n    onNoCollisions?: (() => void) | null,\n    pushingEntity?: Entity,\n  ): void {\n    this.xRemainder += amount;\n    let move = Math.round(this.xRemainder);\n    const sign = Math.sign(move);\n    if (pushingEntity) {\n      pushingEntity.isCollideable = false;\n    }\n    while (move !== 0) {\n      const nextX = this.x + (move ? sign : 0); // Predict the next X position\n      const collisions: Collision[] | false = this.collideAt(nextX - this.x, 0, this.getBoundingBox(), [\n        'left',\n        'right',\n      ]);\n      if (collisions) {\n        if (onCollide) {\n          collisions.forEach((collision) => {\n            onCollide(collision, pushingEntity, new Point(nextX - this.x, 0));\n          });\n        }\n        for (const collision of collisions) {\n          if (!this.isRiding(collision.entity2)) {\n            this.xRemainder = 0;\n          }\n        }\n        break;\n      } else {\n        this.x = nextX;\n        move -= sign;\n        this.xRemainder -= sign;\n        if (onNoCollisions) {\n          onNoCollisions();\n        }\n      }\n    }\n    System.updateEntity(this);\n    if (pushingEntity) {\n      pushingEntity.isCollideable = true;\n    }\n  }\n\n  moveY(\n    amount: number,\n    onCollide?: ((collision: Collision, pushingEntity?: Entity, direction?: Point) => void) | null,\n    onNoCollisions?: (() => void) | null,\n    pushingEntity?: Entity,\n  ): void {\n    this.yRemainder += amount;\n    let move = Math.round(this.yRemainder);\n    const sign = Math.sign(move);\n    if (pushingEntity) {\n      pushingEntity.isCollideable = false;\n    }\n\n    while (move !== 0) {\n      const nextY = this.y + (move ? sign : 0); // Predict the next Y position\n      const collisions: Collision[] | false = this.collideAt(0, nextY - this.y, this.getBoundingBox(), [\n        'top',\n        'bottom',\n      ]);\n      if (collisions) {\n        if (onCollide) {\n          collisions.forEach((collision) => onCollide(collision, pushingEntity, new Point(0, nextY - this.y)));\n        }\n        this.yRemainder = 0;\n        break;\n      } else {\n        this.y = nextY;\n        move -= sign;\n        this.yRemainder -= sign;\n        if (onNoCollisions) {\n          onNoCollisions();\n        }\n      }\n    }\n    System.updateEntity(this);\n    if (pushingEntity) {\n      pushingEntity.isCollideable = true;\n    }\n  }\n\n  // Simple bounding box collision check\n  collideAt(\n    x: number,\n    y: number,\n    box: Rectangle,\n    sides?: ('top' | 'right' | 'bottom' | 'left')[],\n  ): Collision[] | false {\n    const nextPosition = new Rectangle(box.x + x, box.y + y, box.width, box.height);\n    const collisions = [];\n    // Iterate through all solids in the level to check for collisions\n    for (const entity of this.collideables) {\n      if (!entity.isCollideable || this.passThroughTypes.includes(entity.type)) {\n        continue;\n      }\n\n      const solidBounds = entity.getBoundingBox();\n      let collisionResult = checkCollision(nextPosition, solidBounds, this, entity);\n      if (sides?.length && collisionResult) {\n        // check to be sure collision includes all sides\n        const collisionSides = sides.filter((side) => (collisionResult as Collision)[side]);\n        if (!collisionSides.length) {\n          collisionResult = false;\n        }\n      }\n      if (collisionResult) {\n        System.collide(collisionResult);\n        // if the collision resolver returns true,\n        // we should stop and return this collision\n        // this will stop actor movement if returned\n        if (System.resolveCollision(collisionResult)) {\n          collisions.push(collisionResult);\n        }\n      }\n    }\n    return collisions.length ? collisions : false;\n  }\n\n  isRiding(solid: Entity): boolean {\n    const result =\n      this.bottom >= solid.top - 2 &&\n      this.bottom <= solid.top + 2 &&\n      this.left < solid.right &&\n      this.right > solid.left;\n\n    if (result) {\n      this.riding.add(solid);\n      this.ridingAmounts.set(solid, Math.max(solid.right - this.left, this.right - solid.left));\n      return true;\n    } else {\n      if (this.riding.has(solid)) {\n        this.riding.delete(solid);\n        this.ridingAmounts.delete(solid);\n      }\n      return false;\n    }\n  }\n\n  setPassingThrough(entity: Entity) {\n    this.passingThrough.add(entity);\n  }\n\n  removePassingThrough(entity: Entity) {\n    this.passingThrough.delete(entity);\n  }\n\n  isPassingThrough(entity: Entity) {\n    return this.passingThrough.has(entity);\n  }\n}\n","import { Application, Logger } from 'dill-pixel';\nimport { Actor } from './Actor';\nimport { Entity } from './Entity';\nimport { System } from './System';\nimport { checkCollision } from './utils';\nimport { Collision, EntityType } from './types';\n\nexport class Sensor<T = any, A extends Application = Application> extends Actor<T, A> {\n  type = 'Sensor';\n  isSensor = true;\n  isColliding = false;\n  /**\n   * Types of entities that can pass through this sensor without triggering a collision\n   * All actors by default, so sensors can still be pushed by and ride on solids,\n   * but we don't check collisions with other actors in the moveX and moveY methods\n   * You can call \"resolveAllCollisions\" to still resolve collisions for actors,\n   * but not have this sensor be \"pushed\" by them\n   */\n  passThroughTypes: EntityType[] = ['Actor', 'Player'];\n\n  protected _activeCollisions = null as null | Collision[];\n  get activeCollisions() {\n    return this._activeCollisions;\n  }\n\n  set activeCollisions(value) {\n    this._activeCollisions = value;\n  }\n\n  get collideables(): Entity[] {\n    return System.actors;\n  }\n\n  added() {\n    System.addSensor(this);\n  }\n\n  removed() {\n    System.removeSensor(this);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  update(_deltaTime?: number) {\n    this.activeCollisions = this.resolveAllCollisions();\n    this.isColliding = !!this.activeCollisions;\n  }\n\n  /**\n   * Resolve all collisions for this sensor\n   * ignores passThroughTypes\n   */\n  resolveAllCollisions(): null | Collision[] {\n    const collisions = [];\n    // Iterate through all solids in the level to check for collisions\n    for (const entity of this.collideables) {\n      if (!entity.isCollideable) {\n        continue;\n      }\n      const collisionResult = checkCollision(this.getBoundingBox(), entity.getBoundingBox(), this, entity);\n      if (collisionResult) {\n        collisions.push(collisionResult);\n      }\n      if (collisionResult) {\n        System.collide(collisionResult);\n        // if the collision resolver returns true,\n        // we should stop and return this collision\n        // this will stop actor movement if returned\n        if (System.resolveCollision(collisionResult)) {\n          collisions.push(collisionResult);\n        }\n      }\n    }\n    return collisions.length ? collisions : null;\n  }\n\n  getOuterCollisions(collideables = this.collideables) {\n    const outerBoundingBox = this.getOuterBoundingBox();\n    if (!outerBoundingBox) {\n      Logger.error(this.type, 'has no outer bounding box. Returning empty array.');\n      return [];\n    }\n    const collisions: Collision[] = [];\n    for (const entity of collideables) {\n      if (!entity.isCollideable) {\n        continue;\n      }\n      const collisionResult = checkCollision(outerBoundingBox, entity.getBoundingBox(), this, entity);\n      if (collisionResult) {\n        collisions.push(collisionResult);\n      }\n    }\n    return collisions;\n  }\n}\n"],"names":["SpatialHashGrid","cellSize","insertEntities","System","entity","size","bounds","startX","startY","endX","endY","x","y","key","_a","entities","range","filter","foundEntities","cellEntities","gfx","rect","rects","_cell","Rectangle","cellX","cellY","Entity","Container","config","value","pos","Sprite","Bounds","Solid","moveX","moveY","ridingActors","actor","dx","dy","deltaX","deltaY","overlapX","overlapY","_isColliding","defaults","Wall","SnapSolid","Texture","checkPointIntersection","point","collider","getIntersectionArea","rectA","rectB","xOverlap","yOverlap","checkCollision","entity1","entity2","overlap","_System","collisionResolverMethod","collision","index","type","acc","t","solid","sensor","e","bounds1","bounds2","intersection","deltaTime","preUpdateHooks","postUpdateHooks","Logger","hook","width","height","padding","sides","wall","Point","container","_b","Graphics","outerBounds","opts","Signal","defaultOptions","SnapPhysicsPlugin","Plugin","app","options","Actor","mostRiding","mostRidingAmount","amount","_collision","_pushingEntity","_direction","onCollide","onNoCollisions","pushingEntity","move","sign","nextX","collisions","nextY","box","nextPosition","solidBounds","collisionResult","side","Sensor","_deltaTime","collideables","outerBoundingBox"],"mappings":"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"}